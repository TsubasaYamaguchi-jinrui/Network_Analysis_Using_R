[["index.html", "Network Analysis Using R 本稿の目的", " Network Analysis Using R Tsubasa Yamaguchi 2022-11-13 本稿の目的 本稿はネットワーク分析の簡単な概要と、Rで分析を行う方法をまとめたものである。 本稿で扱うのは、以下の内容である。 社会ネットワーク分析の概要(第1章) rawデータからマトリックス(隣接行列)を作成する方法(第2章) 各ネットワーク指標の解説と算出法(第3章) ネットワークデータでの統計分析（第4章) 参考にしたのは主に以下の文献である。 なお、本稿の作成に使用したファイルとRのコードは筆者のGithubですべて閲覧できる。 鈴木努(2017) ネットワーク分析 第2版 (鈴木, 2017) Whitehead(2008) Analyzing Animal Societies (Whitehead, 2008) Croft et al. (2008) Exploring Animal Social Network (D. Croft et al., 2008) Farine &amp; Whitehead (2015) Constructing, conducting and interpreting animal social network analysis (Farine &amp; Whitehead, 2015) Farine (2017) A guide to null models for animal social network analysis (Farine, 2017) Sosa et al. (2020) A multilevel statistical toolkit to study animal social networks: the Animal Network Toolkit Software (ANTs) R package. (Sosa et al., 2020) Network Analysis in R (Dai Shizukaのホームページ) References Croft, D., James, R., &amp; Krause, J. (2008). 動物の社会ネットワーク分析 (島田将喜., Trans.). 東海大学出版部. Farine, D. R. (2017). A guide to null models for animal social network analysis. Methods Ecol. Evol., 8(10), 1309–1320. Farine, D. R., &amp; Whitehead, H. (2015). Constructing, conducting and interpreting animal social network analysis. J. Anim. Ecol., 84(5), 1144–1163. Sosa, S., Puga-Gonzalez, I., Hu, F., Pansanel, J., Xie, X., &amp; Sueur, C. (2020). A multilevel statistical toolkit to study animal social networks: The animal network toolkit software (ANTs) R package. Sci. Rep., 10(1), 12507. Whitehead, H. (2008). Analyzing animal societies. The University of Chicago Press. 鈴木努. (2017). R で学ぶデータサイエンス 8 ネットワーク分析 第2版 (金明哲., Ed.). 共立出版. "],["パッケージの読み込み.html", "0. パッケージの読み込み", " 0. パッケージの読み込み 本稿では、基本的にネットワークデータのハンドリングにはtidygraphパッケージを用いる。このパッケージを使うことで、データフレームとしてネットワークデータを扱うことができるので非常に便利である。ネットワークグラフの描画にはggraphパッケージを用いる。このパッケージでは、基本的にggplot2と同じ文法でネットワークグラフを描くことができる。 各指標の算出や統計分析には、主にasnipeパッケージ、ANTsパッケージ、igraphパッケージ、snaパッケージを用いる。 tidygraph ggraph asnipe(Farine, 2013) ANTS(Sosa et al., 2020) igraph(Csardi et al., 2006) sna(Butts, 2008) ## ネットワーク分析関連 library(tidygraph) library(ggraph) library(asnipe) library(sna) library(ANTs) library(igraph) library(clValid) library(assortnet) library(hwig) ## データハンドリング library(tidyverse) library(easystats) library(data.table) ## グラフや表関連 library(patchwork) library(DT) library(knitr) library(kableExtra) library(dagitty) library(ggdag) library(ggforce) library(concaveman) library(ggsci) ## フォント関連 library(extrafont) require(systemfonts) なお、本稿はRの基本操作とtidyverseパッケージによるデータハンドリングができることを前提としている。tidyverseパッケージを用いたデータ処理については、以下の書籍などを参照。 R for Data Science (Wickham &amp; Grolemund, 2016) 電子書籍, 日本語 R Graphics Coocbook 2nd Edition (Chang, 2018) 電子書籍, 日本語 RユーザのためのRstudio[実践]入門~tidyverseによるモダンな分析フローの世界 改訂2版 (松村 et al., 2021) 出版社サイト References Butts, C. T. (2008). Social network analysis with sna. J. Stat. Softw., 24, 1–51. Chang, W. (2018). R graphics cookbook: Practical recipes for visualizing data. “O’Reilly Media, Inc.” Csardi, G., Nepusz, T., &amp; Others. (2006). The igraph software package for complex network research. InterJournal, Complex Systems, 1695(5), 1–9. Farine, D. R. (2013). Animal social network inference and permutations for ecologists inRusingasnipe. Methods Ecol. Evol., 4(12), 1187–1194. Sosa, S., Puga-Gonzalez, I., Hu, F., Pansanel, J., Xie, X., &amp; Sueur, C. (2020). A multilevel statistical toolkit to study animal social networks: The animal network toolkit software (ANTs) R package. Sci. Rep., 10(1), 12507. Wickham, H., &amp; Grolemund, G. (2016). R for data science: Import, tidy, transform, visualize, and model data. “O’Reilly Media, Inc.” 松村優哉., 湯谷啓明., 紀ノ定保礼., &amp; 前田和. (2021). RユーザのためのRstudio[実践]入門 tidyverseによるモダンな分析フローの世界 改訂2版. 技術評論社. "],["c1.html", "1 社会ネットワーク分析の概説 1.1 社会ネットワーク分析(SNA)とは 1.2 社会ネットワークの基礎", " 1 社会ネットワーク分析の概説 1.1 社会ネットワーク分析(SNA)とは 社会ネットワークとは，相互に社会的なつながりをもつ個体の集まりのことを指す(Krause et al., 2015)。多くの生物において、集団を構成する個体たちはランダムランダム・均一に他個体と関わりあっているわけではなく、その関係の強度やタイプ、ダイナミクスは非常に多様である。社会ネットワークは、このような多様な関係によって構成されている(D. Croft et al., 2008)。 霊長類のように多くの個体が集団生活を行う種においては、個体の行動は一対一の社会関係だけではなく、集団全体の関係構造(e.g., 誰と誰がどのような関係を持つか)に強く影響を受ける。例えば、個体\\(A\\)が個体\\(B\\)に攻撃を仕掛けるかは、個体\\(B\\)が誰と/何頭と親密な関係を持つかや、その関係の強度に大きく依存するだろう。また、どのように行動や感染症等が個体間を伝播するのかにも、ネットワーク構造が大きくかかわっている。以上のことから、集団で生活する種を対象に研究を行う際には、その背後にある社会ネットワークについて理解することが非常に重要だと分かる(Krause et al., 2015; Sueur, Jacobs, et al., 2011)。 社会ネットワーク分析（SNA: Social Network Analysis）とは，集団内の2個体間の社会関係に基づいて社会ネットワークを描写することで，その社会関係の構造や構成個体の特性を調べる分析手法のことである(D. Croft et al., 2008; Krause et al., 2015)。SNAの手法を用いることで、社会ネットワークの構造が個体の行動に与える影響などを検討することが可能になる。 近年、霊長類でもSNAの手法を用いた研究がかなり増加しており(Sueur, Jacobs, et al., 2011)、Primatesでも2019年に特集号が組まれた(Puga-Gonzalez et al., 2019)。SNAを用いた霊長類の研究には以下のようなものがある。このような研究を理解するためにもSNAの手法を学ぶことは有用だ。 オス間の親和的交渉のネットワークが移籍の成否や繁殖成功に与える影響を調べた研究(Gilby et al., 2013; Kawazoe &amp; Sosa, 2019) メス間の親和的交渉のネットワークがメスの適応度に与える影響を調べた研究(Cheney et al., 2016; Lehmann et al., 2016) 毛づくろいネットワークが寄生虫への感染に与える影響を調べた研究(Duboscq et al., 2016; MacIntosh et al., 2012) 社会ネットワークが行動の社会的伝達に与える影響を検討した研究(Canteloup et al., 2020; Hobaiter et al., 2014) 異なる行動指標のネットワーク間の関連を調べた研究(Campbell et al., 2018; Shimada &amp; Sueur, 2018) 種間のネットワークを比較した研究(Balasubramaniam et al., 2018; Sueur, Petit, et al., 2011) 1.2 社会ネットワークの基礎 1.2.1 グラフ SNAでは、ネットワークの構造を頂点(ノード)と辺(エッジ)の集合によって表す。これを、グラフと呼ぶ。頂点は個体などを、辺は何らかの個体間の社会関係を表す。 関係の有無(1か0か)だけを考慮するグラフと、関係の強さ(交渉頻度など)も考慮するグラフがある。後者は特に重み付きグラフといい、関係の強さを「重み(weight)」という。グラフでは、エッジの太さで関係の強さを表す(図1.1)。 関係の向きを考える(\\(A \\rightarrow B\\)と\\(A \\leftarrow B\\)を区別)グラフを有向グラフ、考えないグラフを無向グラフという。有向グラフの場合は、辺に矢印を用いることが多い(図1.1のB)。 図1.1: 例1. 無向グラフ(A)と有向グラフ(B)の例 1.2.2 隣接行列(マトリックス) ネットワーク分析では、データを隣接行列(adjacency matrix)の形で表現することが多い。隣接行列はグラフのノード間の関係が記された行列で、ノードの数が\\(n\\)個ならば、\\(n \\times n\\)の正方行列になる。Rの分析でも、基本的に隣接行列を用いることが多い。 Rでは、matrix()関数によって以下のように作成できる。 mat_example &lt;- matrix(## 数値のベクトル c(0,0,0,2, 1.5,0,2,0, 3,0,0,1, 0,1,3,0), ## 行数と列数 ncol = 4, nrow = 4, ## TRUEなら、1行目から順に数値を入れていく byrow = TRUE) ## 列名と行名を入れられる colnames(mat_example) &lt;- c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;) rownames(mat_example) &lt;- c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;) ## 完成したのがこちら mat_example %&gt;% kable(digits = 2, align = &quot;c&quot;,caption = &quot;作成した隣接行列&quot;) %&gt;% kable_styling(font_size = 10, full_width = FALSE) 表1.1: 作成した隣接行列 A B C D A 0.0 0 0 2 B 1.5 0 2 0 C 3.0 0 0 1 D 0.0 1 3 0 Excel等で作成したcsvファイルをデータフレームとして読み込み、それをマトリックスに変換する方法もある。 ## 1列目を行名に指定 mat_example2 &lt;- read.csv(&quot;data/example.csv&quot;, row.names = 1) ## マトリックスに変換 mat_example2 &lt;- as.matrix(mat_example2) mat_example2 %&gt;% kable(digits = 2, align = &quot;c&quot;) %&gt;% kable_styling(font_size = 10, full_width = FALSE) A B C D E F G H A 0.00 0.55 0.15 0.93 0.86 0.29 0.63 0.24 B 0.41 0.00 0.86 0.95 0.20 0.99 0.36 0.59 C 0.09 0.41 0.00 0.87 0.63 0.85 0.29 0.80 D 0.83 0.68 0.07 0.00 0.60 0.54 0.14 0.42 E 0.80 0.82 0.34 0.68 0.00 0.70 0.41 0.43 F 0.80 0.05 0.78 0.17 0.95 0.00 0.04 0.37 G 0.75 0.42 0.90 0.95 0.51 0.16 0.00 0.05 H 0.87 0.16 0.02 0.05 0.31 0.85 0.13 0.00 1.2.3 Rでのグラフの描画 本稿ではggraphパッケージを用いる。このパッケージを用いる利点は主に以下の2点である。 tidygraphと併用することで、データフレーム形式のデータをそのままグラフにできる。それによって、データの加工とグラフの描画をシームレスに行いやすい。 ggplotパッケージの拡張なので、ggplotと同じ文法で描ける。 1.2.3.1 tbl_graphクラスへの変換 ggraphでグラフを描くには、データをtbl_graphクラスに変換する必要がある。隣接行列をas_tbl_graph()で変換してあげればよい。すると、ノードの名前nameと辺リスト(辺の始点、終点、重みが書いてあるリスト)が入ったオブジェクトを返してくれる。 ## 有向グラフであれば directed = TRUE、無向グラフならFALSE graph_mat_example2 &lt;- as_tbl_graph(mat_example2, directed = TRUE) graph_mat_example2 ## # A tbl_graph: 8 nodes and 56 edges ## # ## # A directed simple graph with 1 component ## # ## # Node Data: 8 × 1 (active) ## name ## &lt;chr&gt; ## 1 A ## 2 B ## 3 C ## 4 D ## 5 E ## 6 F ## # … with 2 more rows ## # ## # Edge Data: 56 × 3 ## from to weight ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 2 0.552 ## 2 1 3 0.153 ## 3 1 4 0.930 ## # … with 53 more rows なお、各ノードの名前以外の情報もグラフに反映させたい場合は、以下のように情報を追加できる。ここでは、各個体の年齢の情報を追加した。 graph_mat_example2 %&gt;% mutate(age = c(12,10,15,6,20,13,8,7)) -&gt; graph_mat_example2 graph_mat_example2 ## # A tbl_graph: 8 nodes and 56 edges ## # ## # A directed simple graph with 1 component ## # ## # Node Data: 8 × 2 (active) ## name age ## &lt;chr&gt; &lt;dbl&gt; ## 1 A 12 ## 2 B 10 ## 3 C 15 ## 4 D 6 ## 5 E 20 ## 6 F 13 ## # … with 2 more rows ## # ## # Edge Data: 56 × 3 ## from to weight ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 2 0.552 ## 2 1 3 0.153 ## 3 1 4 0.930 ## # … with 53 more rows グラフに使用するデータを絞り込むなどの作業をする場合は、一度隣接行列を辺リストのデータフレームに変換してから(mat.to.edgl()で可能)データフレームを加工し、その後にas_tbl_graph()を用いるとよい。以下では、重みが0.7以上の辺のみを抽出している。 mat_example2 %&gt;% ## 辺リストのデータフレームに変換 mat.to.edgl() %&gt;% ## weightが0.5以上のものに限定する filter(weight &gt;= 0.5) %&gt;% ## tbl_graphクラスに変換 as_tbl_graph(directed = TRUE) %&gt;% mutate(age = c(12,10,15,6,20,13,8,7)) -&gt; graph_mat_example2_b graph_mat_example2 ## # A tbl_graph: 8 nodes and 56 edges ## # ## # A directed simple graph with 1 component ## # ## # Node Data: 8 × 2 (active) ## name age ## &lt;chr&gt; &lt;dbl&gt; ## 1 A 12 ## 2 B 10 ## 3 C 15 ## 4 D 6 ## 5 E 20 ## 6 F 13 ## # … with 2 more rows ## # ## # Edge Data: 56 × 3 ## from to weight ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 2 0.552 ## 2 1 3 0.153 ## 3 1 4 0.930 ## # … with 53 more rows 1.2.3.2 ggraphを用いた描画 ggraphでグラフを描画するときには、主に以下の3つを指定してあげればよい。 レイアウト: グラフでノードと辺をどのような規則に基づいて配置するかを決める。 例. line: 一直線、circle: 円上、nicely: いい感じに?、randomly: ランダムに、… 詳細はこちらやこちらを参照。 ノード: geom_node_*()(*には色々入る)という関数群でノードについて指定。関数の中でsize =で大きさ、color =で色、shape =で形などをggplotと同じように指定できる。 例. geom_node_point(): 普通のノード、geom_node_text(): ノードのラベル、… 辺(エッジ): geom_edge_*()(*には色々入る)という関数群でノードについて指定。関数の中でwidth =で太さ、color =で色などをggplotと同じように指定できる。 例: geom_edge_link(): 直線、geom_edge_fan(): 曲線、… 図1.2は実際に以下のコードで描いた例である。 layout = \"nicely\"とすると、グラフが見やすいように配置してくれる。関係のある(= 辺がある)個体同士はより近くに配置される傾向があるため、絶対とはいえないが、結果的に多くの個体と繋がっている個体が中心部に来る傾向がある。 何らかの指標を出さない限りグラフのみから何かを結論付けることはできないが、パッと見て関係構造の全体図を掴んだり、仮説を立てたりしようとする際にはグラフを見ることが非常に有用である。 graph_mat_example2_b %&gt;% # layoutの指定 ggraph(layout = &quot;nicely&quot;)+ # 曲線のエッジ、weightを太さに geom_edge_fan(aes(width = weight), ## 矢印について指定 arrow = arrow(angle = 15, type = &quot;closed&quot;,length = unit(0.18, &quot;inches&quot;)), ## 矢印の終点のノードからの距離 end_cap = circle(2.5,&quot;mm&quot;), ## 矢印の始点のノードからの距離 start_cap = circle(2.5,&quot;mm&quot;), ## 透明度(alpha)と色(color)指定 alpha =0.7, color = &quot;grey60&quot;)+ # エッジの太さの範囲を決める scale_edge_width(range = c(0,1.3))+ ## 四角のノード。大きさは年齢によって変化するとする。 geom_node_point(aes(size = age), shape = 18)+ ## ノードのラベルは個体名 scale_size(range = c(3,6))+ geom_node_text(aes(label = name), ## ノードと重ならないようにする repel=TRUE, size =6)+ theme_graph()+ ## 縦横比 theme(aspect.ratio = 0.7) 図1.2: ggraphで描いたグラフの例 References Balasubramaniam, K. N., Beisner, B. A., Berman, C. M., De Marco, A., Duboscq, J., Koirala, S., Majolo, B., Macintosh, A. J. J. J., McFarland, R., Molesti, S., Ogawa, H., Petit, O., Schino, G., Sosa, S., Sueur, C., Thierry, B., Waal, F. B. M. M. de, &amp; McCowan, B. (2018). The influence of phylogeny, social style, and sociodemographic factors on macaque social network structure. Am. J. Primatol., 80(1), e22727. Campbell, L. A. D., Tkaczynski, P. J., Lehmann, J., Mouna, M., &amp; Majolo, B. (2018). Social thermoregulation as a potential mechanism linking sociality and fitness: Barbary macaques with more social partners form larger huddles. Sci. Rep., 8(1), 6074. Canteloup, C., Hoppitt, W., &amp; Waal, E. van de. (2020). Wild primates copy higher-ranked individuals in a social transmission experiment. Nat. Commun., 11(1), 459. Cheney, D. L., Silk, J. B., &amp; Seyfarth, R. M. (2016). Network connections, dyadic bonds and fitness in wild female baboons. Royal Society Open Science, 3(7), 160255. Croft, D., James, R., &amp; Krause, J. (2008). 動物の社会ネットワーク分析 (島田将喜., Trans.). 東海大学出版部. Duboscq, J., Romano, V., Sueur, C., &amp; Macintosh, A. J. J. (2016). Network centrality and seasonality interact to predict lice load in a social primate. Sci. Rep., 6(FEBRUARY), 22095. Gilby, I. C., Brent, L. J. N., Wroblewski, E. E., Rudicell, R. S., Hahn, B. H., Goodall, J., &amp; Pusey, A. E. (2013). Fitness benefits of coalitionary aggression in male chimpanzees. Behav. Ecol. Sociobiol., 67(3), 373–381. Hobaiter, C., Poisot, T., Zuberbühler, K., Hoppitt, W., &amp; Gruber, T. (2014). Social network analysis shows direct evidence for social transmission of tool use in wild chimpanzees. PLoS Biol., 12(9), e1001960. Kawazoe, T., &amp; Sosa, S. (2019). Social networks predict immigration success in wild japanese macaques. Primates, 60(3), 213–222. Krause, J., James, R., Franks, D. W., &amp; Croft, D. P. (2015). Animal social networks. Oxford University Press. Lehmann, J., Majolo, B., &amp; McFarland, R. (2016). The effects of social network position on the survival of wild barbary macaques, macaca sylvanus. Behav. Ecol., 27(1), 20–28. MacIntosh, A. J. J., Jacobs, A., Garcia, C., Shimizu, K., Mouri, K., Huffman, M. A., &amp; Hernandez, A. D. (2012). Monkeys in the middle: Parasite transmission through the social network of a wild primate. PLoS One, 7(12), 15–21. Puga-Gonzalez, I., Sosa, S., &amp; Sueur, C. (2019). Editorial: Social networks analyses in primates, a multilevel perspective. Primates, 60, 163–165. Shimada, M., &amp; Sueur, C. (2018). Social play among juvenile wild japanese macaques (macaca fuscata) strengthens their social bonds. Am. J. Primatol., 80(1). Sueur, C., Jacobs, A., Amblard, F., Petit, O., &amp; King, A. J. (2011). How can social network analysis improve the study of primate behavior? American Journal of Primatology, 73(8), 703–719. Sueur, C., Petit, O., De Marco, A., Jacobs, A. T., Watanabe, K., &amp; Thierry, B. (2011). A comparative network analysis of social style in macaques. Anim. Behav., 82(4), 845–852. "],["c2.html", "2 データの読み込みとマトリックスの作成 2.1 2個体間の交渉を記録したデータフレーム 2.2 Group by individual", " 2 データの読み込みとマトリックスの作成 R上でSNAを行うためには、個体間の関係データを隣接行列にしなければならないことが多い。しかし多くの場合、個体間のassociationの生データは隣接行列の形では表されていない。例えば個体追跡のデータでは、以下(表??)のように1分ごとに毛づくろい相手のIDを記録したものをまずExcelファイルなどに記入する、というようなことが多いだろう。ここでは、R上でこのような生データから隣接行列を作成する方法を学ぶ。 表2.1: 生データの例 min groomer groomee 1 A B 2 A B 3 A C 4 B A 5 B A 2.1 2個体間の交渉を記録したデータフレーム ここでは、2個体間の交渉(例えば、毛づくろいなど)を記録したデータフレームから隣接行列を作る。 例えば、以下は金華山島\\(B_1\\)群で2018年時点で6歳以上のメスを個体追跡した際のデータであり、1分間の瞬間サンプリングで以下を記録したデータフレームである。 no_focal: 個体追跡セッション番号 subject: 追跡個体名 time: 個体追跡開始からの経過時間 activity: 個体の活動(G: 毛づくろい、R: 休息、F: 採食、M: 移動、O: その他) TG: 樹上(T)にいたか地上(G)にいたか groomer: activityが毛づくろいだったときのgroomer geoomee: activityが毛づくろいだったときのgroomer groom &lt;- read_csv(&quot;data/focal_demo.csv&quot;) groom %&gt;% head(50) %&gt;% datatable(rownames = FALSE) 追跡したメスのIDは以下のとおりである。 adult &lt;- c(&quot;Kil&quot;,&quot;Kit&quot;,&quot;Koh&quot;,&quot;Kur&quot;,&quot;Kun&quot;,&quot;Kor&quot;,&quot;Ntr&quot;, &quot;Ten&quot;,&quot;Aka&quot;,&quot;Ako&quot;,&quot;Tam&quot;,&quot;Tot&quot;,&quot;Hen&quot;,&quot;Hot&quot;, &quot;Mal&quot;,&quot;Mik&quot;,&quot;Mei&quot;) このデータをもとに、個体追跡中にメス間が毛づくろいをした頻度を示したマトリックスを作成する。 ここで、頻度は以下の式で表すものとする。 \\(G_{AB}\\): \\(A\\)から\\(B\\)への毛づくろい頻度 \\(x_{AB}\\): \\(A\\)から\\(B\\)への毛づくろいが確認された瞬間サンプリングポイント数 \\(y_A\\): \\(A\\)の個体追跡時間(瞬間サンプリングポイント総数) \\(y_B\\): \\(B\\)の個体追跡時間(瞬間サンプリングポイント総数) \\[ G_{AB} = \\frac{x_{AB}}{y_{A} + y_{B}} \\] 分母となる各個体の個体追跡時間(\\(y_A, y_B, ...\\))を算出する。 groom %&gt;% group_by(subject) %&gt;% summarise(duration = n()) -&gt; duration duration %&gt;% datatable(rownames = FALSE) 追跡個体がのactivityが毛づくろいで、かつ地上にいたポイントのみを抽出する。 また、毛づくろい相手が大人だったのみを抽出。 groom_G &lt;- groom %&gt;% filter(activity == &quot;G&quot;) %&gt;% filter(Groomer %in% adult &amp; Groomee %in% adult) 毛づくろい頻度はANTsパッケージのdf.to.mat()関数で以下のように求められる。 groom_mat &lt;- df.to.mat(groom_G, ## 行動の行い手を表す列 actor = &quot;Groomer&quot;, ## 行動の受け手を表す列 receiver = &quot;Groomee&quot;, ## 追跡時間 tobs = duration$duration, ## 交渉の方向を考慮するか。FALSEでする。 sym = FALSE) 隣接行列は以下のようになる(表2.2)。 表2.2: 方向性を考慮した毛づくろい頻度の隣接行列 Aka Ako Hen Hot Kil Kit Koh Kor Kun Kur Mal Mei Mik Ntr Tam Ten Tot Aka 0.00 0.04 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 Ako 0.07 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.01 0.00 Hen 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.01 0.00 0.00 0.00 0.00 0.00 Hot 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 Kil 0.00 0.00 0.00 0.00 0.00 0.01 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 Kit 0.00 0.00 0.00 0.00 0.02 0.00 0.01 0.00 0.00 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 Koh 0.00 0.00 0.00 0.00 0.01 0.01 0.00 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 Kor 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.01 0.02 0.00 0.00 0.00 0.01 0.00 0.00 0.00 Kun 0.00 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.00 Kur 0.00 0.00 0.00 0.00 0.01 0.01 0.00 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 Mal 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.02 0.00 0.00 0.00 0.01 Mei 0.01 0.01 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 Mik 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.03 0.00 0.00 0.00 0.00 0.00 0.00 Ntr 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.01 0.00 0.00 0.01 0.00 0.00 0.01 0.00 Tam 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 Ten 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.01 0.00 0.00 0.00 Tot 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.01 0.00 0.00 0.01 0.00 0.00 0.00 0.01 0.00 0.00 もし交渉の方向性を考慮しない場合は、sym = TRUEとすればよい。 groom_mat_b &lt;- df.to.mat(groom_G, ## 行動の行い手を表す列 actor = &quot;Groomer&quot;, ## 行動の受け手を表す列 receiver = &quot;Groomee&quot;, ## 追跡時間 tobs = duration$duration, sym = TRUE) その場合の隣接行列は以下の通り(表2.3)。 表2.3: 方向性を考慮しない毛づくろい頻度の隣接行列 Aka Ako Hen Hot Kil Kit Koh Kor Kun Kur Mal Mei Mik Ntr Tam Ten Tot Aka 0.00 0.11 0.00 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.00 0.00 Ako 0.11 0.00 0.01 0.00 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.02 0.00 0.01 0.00 0.01 0.00 Hen 0.00 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.01 0.00 0.00 0.01 0.01 0.00 Hot 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 Kil 0.00 0.00 0.00 0.00 0.00 0.04 0.02 0.00 0.01 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 Kit 0.00 0.00 0.00 0.00 0.04 0.00 0.03 0.01 0.00 0.02 0.00 0.00 0.00 0.00 0.00 0.00 0.00 Koh 0.00 0.00 0.00 0.00 0.02 0.03 0.00 0.02 0.01 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.00 Kor 0.00 0.01 0.00 0.00 0.00 0.01 0.02 0.00 0.01 0.02 0.00 0.00 0.01 0.01 0.00 0.01 0.01 Kun 0.00 0.00 0.00 0.00 0.01 0.00 0.01 0.01 0.00 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.00 Kur 0.00 0.00 0.00 0.00 0.01 0.02 0.00 0.02 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.01 0.00 Mal 0.00 0.00 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.04 0.00 0.00 0.00 0.01 Mei 0.01 0.02 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.01 0.01 0.00 0.00 0.00 Mik 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.01 0.00 0.04 0.01 0.00 0.01 0.01 0.00 0.00 Ntr 0.00 0.01 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.01 0.00 0.01 0.01 0.00 0.00 0.01 0.01 Tam 0.00 0.00 0.01 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.02 Ten 0.00 0.01 0.01 0.00 0.00 0.00 0.00 0.01 0.00 0.01 0.00 0.00 0.00 0.01 0.00 0.00 0.00 Tot 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.01 0.00 0.00 0.01 0.00 0.00 0.01 0.02 0.00 0.00 グラフを描画すると図2.1のようになる。ノードの大きさは順位を、辺の太さは毛づくろい頻度を表す。血縁個体同士(同じアルファベットで始まる個体)は交渉頻度が高く、近くに配置されていることが分かる。順位の低い個体がネットワークの周辺にいることが多いことも分かるだろう。 ## 順位 rank &lt;- c(9,10,13,14,1,2,3,6,5,4,15,17,16,7,11,8,12) groom_mat_b %&gt;% as_tbl_graph(directed = FALSE) %&gt;% ## 順位の情報を入れる mutate(rank = rank) %&gt;% ggraph(layout = &quot;nicely&quot;)+ # 曲線のエッジ、weightを太さに geom_edge_fan(aes(width = weight), ## 透明度(alpha)と色(color)指定 alpha =0.7, color = &quot;grey60&quot;)+ # エッジの太さの範囲を決める scale_edge_width(range = c(0.3,3))+ ## 四角のノード。大きさは年齢によって変化するとする。 geom_node_point(aes(size = -rank), shape = 18)+ ## ノードのラベルは個体名 scale_size(range = c(1,5))+ geom_node_text(aes(label = name), ## ノードと重ならないようにする repel=TRUE, size =6)+ theme_graph()+ ## 縦横比 theme(aspect.ratio = 0.7)+ labs(width = &quot;毛づくろい頻度&quot;) 図2.1: 毛づくろい頻度ネットワークのグラフ 2.2 Group by individual 個体間のassociationを表したデータとして、以下のようにある時点・場所において確認された個体を0/1で記録した”group by individual”と呼ばれる形式のものがある。 例えば、以下は金華山島\\(B_1\\)群で2021年交尾期の各観察日に9歳以上のメスが観察されたか否かを示したものである。 presence &lt;- read_csv(&quot;data/presence_demo.csv&quot;) presence %&gt;% datatable(rownames = FALSE) このようなデータでは、同じグループで観察された個体をassociateしていたとみなすことが多い(=gambit of the group)(Farine &amp; Whitehead, 2015)。Group by individualの形式のデータでは、以下のような指標で個体間の強さを表すことが多い。なお、各指標の詳細については Hoppitt &amp; Farine (2018) を参照。 \\(x\\): 個体\\(a\\)と\\(b\\)が一緒に観察された回数 \\(y_a\\): \\(a\\)だけが確認された回数 \\(y_b\\): \\(b\\)だけが確認された回数 \\(y_{ab}\\): \\(a\\)と\\(B\\)が共に観察されたが、associateはしてない回数(今回の例では存在しない) \\(y_{null}\\) どちらも観察されなかった回数 SRI: simple ratio index \\(= x/(y_a + y_b + y_{ab} + x)\\) ▶ 単純に一緒に観察された割合。観察ミス(個体がいたにもかかわらずいなかったと記録してしまうこと)が少ない場合にはこちらで問題ない。 HWI: half-weight index \\(= x/(\\frac{1}{2}(y_a + y_b) + y_{ab} + x)\\) ▶ 観察ミスが多いと考えられる場合、補正を行う。 HWIG (Godde et al., 2013) \\(= HWI_{ab} \\times \\frac{\\sum_i \\sum_j HWI_{ij}}{\\sum_i HWI_{ai} \\times \\sum_i HWI_{bi}}\\) ▶ それぞれの個体のgregariousnessを考慮したHWI。互いのgregariousnessを考慮したとき、ランダムにassociateしているのであれば1になり、１よりおおきければランダムの場合よりもよくassociateしていることになる。 asnipeパッケージのget_network()関数では、こうしたデータからSRIとHWIを算出し、マトリックスを作成することが可能である。 presence_mat &lt;- get_network(presence %&gt;% dplyr::select(-date), ## gambit of the group data_format = &quot;GBI&quot;, ## &quot;HWI&quot;の場合は、&quot;HWI&quot; association_index = &quot;SRI&quot;) ## Generating 15 x 15 matrix 得られた隣接行列は以下の通り(表2.4)。 表2.4: SRIの隣接行列 Mik Kil Koh Aka Ntr Ten Tot Hen Hot Mei Ako Kor Mal Kit Kun Mik 0.00 0.43 0.45 0.63 0.41 0.46 0.41 0.39 0.32 0.43 0.45 0.43 0.32 0.42 0.42 Kil 0.43 0.00 0.98 0.45 0.93 0.95 0.95 0.94 0.80 0.98 0.80 0.98 0.88 0.95 0.95 Koh 0.45 0.98 0.00 0.45 0.95 0.95 0.95 0.94 0.78 0.98 0.80 0.98 0.86 0.95 0.95 Aka 0.63 0.45 0.45 0.00 0.44 0.46 0.42 0.42 0.39 0.43 0.53 0.43 0.35 0.43 0.41 Ntr 0.41 0.93 0.95 0.44 0.00 0.90 0.90 0.89 0.76 0.93 0.77 0.93 0.86 0.93 0.93 Ten 0.46 0.95 0.95 0.46 0.90 0.00 0.93 0.89 0.76 0.95 0.77 0.95 0.83 0.93 0.93 Tot 0.41 0.95 0.95 0.42 0.90 0.93 0.00 0.89 0.78 0.95 0.77 0.95 0.86 0.95 0.95 Hen 0.39 0.94 0.94 0.42 0.89 0.89 0.89 0.00 0.81 0.92 0.76 0.92 0.91 0.92 0.92 Hot 0.32 0.80 0.78 0.39 0.76 0.76 0.78 0.81 0.00 0.78 0.65 0.78 0.79 0.78 0.78 Mei 0.43 0.98 0.98 0.43 0.93 0.95 0.95 0.92 0.78 0.00 0.78 0.98 0.86 0.95 0.95 Ako 0.45 0.80 0.80 0.53 0.77 0.77 0.77 0.76 0.65 0.78 0.00 0.78 0.70 0.78 0.78 Kor 0.43 0.98 0.98 0.43 0.93 0.95 0.95 0.92 0.78 0.98 0.78 0.00 0.88 0.95 0.95 Mal 0.32 0.88 0.86 0.35 0.86 0.83 0.86 0.91 0.79 0.86 0.70 0.88 0.00 0.88 0.88 Kit 0.42 0.95 0.95 0.43 0.93 0.93 0.95 0.92 0.78 0.95 0.78 0.95 0.88 0.00 0.98 Kun 0.42 0.95 0.95 0.41 0.93 0.93 0.95 0.92 0.78 0.95 0.78 0.95 0.88 0.98 0.00 HWIGはhwigパッケージのcalc_hwig()関数で算出することができる。 ## まずHWIを算出 presence_mat_HWI &lt;- get_network(presence %&gt;% dplyr::select(-date), data_format = &quot;GBI&quot;, association_index = &quot;HWI&quot;) ## Generating 15 x 15 matrix ## HWIGの算出 presence_mat_HWIG &lt;- presence_mat_HWI %&gt;% ## data.table形式に直す必要 as.data.table() %&gt;% calc_hwig() %&gt;% as.matrix() rownames(presence_mat_HWIG) &lt;- rownames(presence_mat_HWI) 得られた隣接行列は以下の通り(表2.5)。 表2.5: HWIGの隣接行列 Mik Kil Koh Aka Ntr Ten Tot Hen Hot Mei Ako Kor Mal Kit Kun Mik 0.00 0.51 0.52 0.96 0.50 0.54 0.49 0.48 0.45 0.51 0.57 0.51 0.43 0.50 0.50 Kil 0.51 0.00 0.54 0.50 0.54 0.54 0.54 0.54 0.54 0.55 0.53 0.55 0.55 0.54 0.54 Koh 0.52 0.54 0.00 0.50 0.55 0.54 0.54 0.54 0.53 0.55 0.53 0.55 0.54 0.54 0.54 Aka 0.96 0.50 0.50 0.00 0.51 0.52 0.49 0.49 0.50 0.49 0.62 0.49 0.45 0.49 0.48 Ntr 0.50 0.54 0.55 0.51 0.00 0.54 0.54 0.54 0.54 0.54 0.53 0.54 0.55 0.54 0.55 Ten 0.54 0.54 0.54 0.52 0.54 0.00 0.54 0.54 0.53 0.55 0.53 0.54 0.54 0.54 0.54 Tot 0.49 0.54 0.54 0.49 0.54 0.54 0.00 0.54 0.54 0.55 0.53 0.55 0.54 0.55 0.55 Hen 0.48 0.54 0.54 0.49 0.54 0.54 0.54 0.00 0.56 0.54 0.53 0.54 0.57 0.54 0.54 Hot 0.45 0.54 0.53 0.50 0.54 0.53 0.54 0.56 0.00 0.54 0.52 0.54 0.57 0.54 0.54 Mei 0.51 0.55 0.55 0.49 0.54 0.55 0.55 0.54 0.54 0.00 0.53 0.55 0.54 0.54 0.54 Ako 0.57 0.53 0.53 0.62 0.53 0.53 0.53 0.53 0.52 0.53 0.00 0.53 0.52 0.53 0.53 Kor 0.51 0.55 0.55 0.49 0.54 0.54 0.55 0.54 0.54 0.55 0.53 0.00 0.55 0.54 0.54 Mal 0.43 0.55 0.54 0.45 0.55 0.54 0.54 0.57 0.57 0.54 0.52 0.55 0.00 0.55 0.55 Kit 0.50 0.54 0.54 0.49 0.54 0.54 0.55 0.54 0.54 0.54 0.53 0.54 0.55 0.00 0.55 Kun 0.50 0.54 0.54 0.48 0.55 0.54 0.55 0.54 0.54 0.54 0.53 0.54 0.55 0.55 0.00 得られたSRIの隣接行列についてグラフを描画すると図2.2のようになる。ノードの大きさは年齢、色は順位を、辺の太さはHWIGを表す。MikとAkaは他の個体と一緒にいることが少ないことが分かるだろう(年齢も影響しそう？)。順位の高い個体はネットワークの中心にいることが多そう? age &lt;- c(18,17,15,15,13,13,13,13,13,13,12,11,11,10,9) rank2 &lt;- c(16,1,3,9,7,8,12,13,14,17,10,6,15,2,5) set.seed(129) presence_mat %&gt;% as_tbl_graph(directed = FALSE) %&gt;% ggraph(layout = &quot;nicely&quot;)+ # 曲線のエッジ、weightを太さに geom_edge_link(aes(width = weight), ## 透明度(alpha)と色(color)指定 alpha =0.7, color = &quot;grey67&quot;)+ # エッジの太さの範囲を決める scale_edge_width(range = c(0,1.5))+ ## 四角のノード。大きさは年齢によって変化するとする。 geom_node_point(aes(size = age, color = rank2),shape = 16)+ ## ノードのラベルは個体名 scale_size(range = c(2,5))+ geom_node_text(aes(label = name), ## ノードと重ならないようにする repel=TRUE, size =6)+ theme_graph()+ ## 縦横比 theme(aspect.ratio = 0.7) 図2.2: SRIネットワークのグラフ References Farine, D. R., &amp; Whitehead, H. (2015). Constructing, conducting and interpreting animal social network analysis. J. Anim. Ecol., 84(5), 1144–1163. Godde, S., Humbert, L., Côté, S. D., Réale, D., &amp; Whitehead, H. (2013). Correcting for the impact of gregariousness in social network analyses. Anim. Behav., 85(3), 553–558. Hoppitt, W. J. E., &amp; Farine, D. R. (2018). Association indices for quantifying social relationships: How to deal with missing observations of individuals or groups. Anim. Behav., 136, 227–238. "],["c3.html", "3 ネットワーク指標の算出 3.1 ノードについての諸指標(中心性指標) 3.2 ネットワーク構造の諸指標", " 3 ネットワーク指標の算出 本章では、ネットワークの構造や構成個体の特徴を表すための指標について概説し、それらをRで算出する方法を学ぶ。指標を算出することで定量的な分析が可能になり、グラフを見るだけでは定性的にしか言えなかったことを示すことができるようになる。 本稿では主にANTsパッケージ、またはsnaパッケージで指標の算出を行う。各指標についての説明は 鈴木 (2017) や Sosa et al. (2020) 、 Farine &amp; Whitehead (2015) なども参照。 3.1 ノードについての諸指標(中心性指標) ここでは、各ノードのネットワーク内での特性を表す指標についてまとめる。中心性指標は、いずれもあるノードがそのグラフでどのくらい「中心的」であるかを表す指標である。以下で見るように、中心性を評価する方法は数多く提案されている。 基本的には、いずれもANTsパッケージのmet.*()関数で出力できる(*には中心性指標の名前)。これらの関数は、各ノードについて算出した中心性を各ノードの属性データ(例えば年齢や順位など)を記したデータフレームに追加していってくれるので、分析を行う際に非常に便利である。 属性データの例(年齢と順位) attr &lt;- data.frame(name = c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;), age = c(12,13,12,11,14,15,18,9), rank = c(2,3,4,1,8,1,7,6)) attr %&gt;% datatable(rownames = FALSE, width = &quot;55%&quot;) 3.1.1 近接中心性(closeness centrality) グラフの「中心」のイメージとしてよく思い浮かぶのは、「他のノードとの距離が小さいノードほどより中心的である」というものである。近接中心性は他のノードとの最短距離の合計が小さいほど大きくなる中心性指標で、以下のように定式化され、0から1の値をとる。 \\[ C_c(i) = \\frac{n-1}{\\sum_{j=1}^n d_{ij}} \\] なお\\(n\\)はノード数で、\\(d_{ij}\\)はノード\\(i\\)から\\(j\\)に最短で到達するために通る辺の数(= 最短距離)である。例えば、以下のグラフ(図3.1)において、AからHへの最短距離は2、GからHへの最短距離は4である。分子に\\(n-1\\)があるのは、最大値が1になるようにするためである。 図3.1: 近接中心性算出のための無向グラフの例 例として図3.1のグラフの各ノードの近接中心性を求める。Rでは基本的に隣接行列の形でデータを扱うことが多い。今回も中心性指標の算出のため、図3.1の隣接行列を以下のように作成する。 mat_undir &lt;- matrix(c(0,1,1,1,1,1,0,0, 1,0,1,0,0,0,1,0, 1,1,0,0,0,0,0,0, 1,0,0,0,1,0,0,1, 1,0,0,1,0,1,0,0, 1,0,0,0,1,0,0,0, 0,1,0,0,0,0,0,0, 0,0,0,1,0,0,0,0), nrow = 8, ncol = 8) colnames(mat_undir) &lt;- c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;) rownames(mat_undir) &lt;- c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;) 近接中心性はsnaパッケージのcloseness()関数で求められる。ノードAの中心性の値が最も高いことが分かる。 sna::closeness(mat_undir, ## 有向グラフなら &quot;digraph&quot; gmode = &quot;graph&quot;, ## 重み付きグラフなら FALSE ignore.eval = TRUE) ## [1] 0.7777778 0.5833333 0.5384615 0.5833333 0.5833333 0.5000000 0.3888889 ## [8] 0.3888889 3.1.2 次数中心性(Degree centrality) 最も簡便で適用範囲の広い中心性が次数中心性である(鈴木, 2017)。重みなしグラフについて算出でき、各ノードに辺で接続しているノードの数を、そのノードの次数中心性とする。例えば、図3.1では、Aの次数中心性は5、Dの次数中心性は3である。 例として、図3.1の次数中心性を求める。ANTsパッケージでは、met.degree()関数で求められる。以下のようにdf =に属性が入ったデータフレームを指定することで、算出した次数中心性をそのデータフレームに追加してくれる。 met.degree(mat_undir, ## 属性データフレーム df = attr, ## 個体IDの列番号 dfid = 1) %&gt;% kable(align = &quot;c&quot;) %&gt;% kable_styling(font_size = 12, full_width = FALSE) name age rank degree A 12 2 5 B 13 3 3 C 12 4 2 D 11 1 3 E 14 8 3 F 15 1 2 G 18 7 1 H 9 6 1 有向グラフでは、他のノードから入ってくる辺の数である入次数(indegree)と他のノードへ入っていく辺の数である出次数(outdegree)が区別される。図3.2では、Aの入次数は2、出次数は3である。 図3.2: 次数中心性算出のための有向グラフの例 ANTsパッケージでは、それぞれmet.indegree()とmet.outdegree()で求められる。 ## このようにすれば、2つの中心性指標を共に属性データに結合できる。 met.indegree( ## 隣接行列 mat_dir, ## 属性データフレーム df = attr, ## 個体IDの列番号 dfid = 1) -&gt; attr_b met.outdegree(mat_dir, ## 属性データフレーム(入次数の情報も含む) df = attr_b, ## 個体IDの列番号 dfid = 1) %&gt;% kable(align = &quot;c&quot;) %&gt;% kable_styling(font_size = 12, full_width = FALSE) name age rank indegree outdegree A 12 2 2 3 B 13 3 3 1 C 12 4 1 2 D 11 1 1 2 E 14 8 1 0 F 15 1 2 1 G 18 7 1 3 H 9 6 1 0 3.1.3 重み付き中心性(Strength centrality) 重み付き中心性は、各ノードに接続している辺の重みの合計で表される中心性である。図3.3は表3.1の隣接行列(mat_undir_b)のグラフである。グラフの辺上の数字は重みを表す。このとき、Aの重み付き中心性は\\(3 + 2+ 2+ 1 +1=9\\)、Cの重み付き中心性は\\(3 + 2 = 5\\)である。 表3.1: 隣接行列(mat_undir_b) A B C D E F G H A 0 2 3 1 2 1 0 0 B 2 0 2 0 0 0 1 0 C 3 2 0 0 0 0 0 0 D 1 0 0 0 3 0 0 1 E 2 0 0 3 0 2 0 0 F 1 0 0 0 2 0 0 0 G 0 1 0 0 0 0 0 0 H 0 0 0 1 0 0 0 0 図3.3: 重み付き中心性算出のための無向グラフの例 ANTsパッケージでは、met.strength()で求められる。まお、ANTsパッケージでは常に有向グラフとして計算されてしまうようなので、1/2してあげる必要がある。 met.strength(mat_undir_b/2, ## 属性データフレーム df = attr, ## 個体IDの列番号 dfid = 1) %&gt;% kable(align = &quot;c&quot;) %&gt;% kable_styling(font_size = 12, full_width = FALSE) name age rank strength A 12 2 9 B 13 3 5 C 12 4 5 D 11 1 5 E 14 8 7 F 15 1 3 G 18 7 1 H 9 6 1 なお、有向データについては次数中心性と同じようにinstrengthとoutstrengthで区別することもできる。その場合は、それぞれANTsパッケージのmet.indegree()とmet.outstrength()で算出できる。 おまけ snaパッケージでは、次数中心性と重み付き中心性を全てdegree()関数で求められる。 sna::degree(mat_undir_b, ## 重みなしの場合 TRUE ignore.eval = FALSE, ## 有向グラフの場合は &quot;digraph&quot;, gmode = &quot;graph&quot;, ## indegreeの場合は &quot;indegree&quot;、outdegreeの場合は&quot;outdegree&quot;, cmode = &quot;freeman&quot;) ## [1] 9 5 5 5 7 3 1 1 3.1.4 固有ベクトル中心性(Eigenvector centrality) 次数中心性や重み付け中心性は、あるノードに接続する辺の数や重みの合計に基づく中心性指標であった。つまり、例えば毛づくろい頻度ネットワークでは、多くの個体と毛づくろいしている個体や、毛づくろい頻度の合計が多い個体の中心性が高く評価される。しかし、この方法は中心性を評価する指標として適切ではない場合がある。例えば、毛づくろいを通してある行動がネットワーク内をどのように伝播するかを考えるとき、毛づくろい相手の多い個体と毛づくろいすることは、毛づくろい相手の少ない個体と毛づくろいするよりも高く評価するべきかもしれない。 このことを考慮するためは、あるノードの中心性を評価するときに、そのノードと繋がっているノードの中心性の大きさを反映させる必要がある。例えば、あるノードの中心性がそれとつながるノードの中心性の和に比例する方法が考えられる。このとき、ある無向グラフの隣接行列を\\(A = (a_{ij})\\)とし、そこに含まれるノードの中心性を成分とする列ベクトルを\\(c=c_i\\)とすると、ノード\\(i\\)の中心性\\(c_i\\)は次のように表現できる。ただし、\\(\\lambda\\)は正の比例定数である。 \\[ \\begin{aligned} c_i &amp;= \\frac{1}{\\lambda} \\sum_{j=1}^{n} a_{ij}c_j \\end{aligned} \\] 行列とベクトルで表すと、以下のように書ける。 \\[ \\begin{aligned} c &amp;= \\frac{1}{\\lambda} Ac\\\\ \\therefore \\lambda c &amp;= Ac \\end{aligned} \\] 例えば、4個体について以下の隣接行列\\(A\\)と中心性を成分とするベクトル\\(c\\)を考える。 $$ \\[\\begin{aligned} &amp;A = (a_{ij}) = \\begin{pmatrix} 0 &amp; 1 &amp; 0 &amp; 0\\\\ 1 &amp; 0 &amp; 1 &amp; 1\\\\ 0 &amp; 1 &amp; 0 &amp; 1\\\\ 0 &amp; 1 &amp; 1 &amp; 0\\\\ \\end{pmatrix}\\\\ \\\\ &amp;c = \\begin{pmatrix} c_1\\\\ c_2\\\\ c_3\\\\ c_4 \\end{pmatrix} \\end{aligned}\\] $$ このとき、以下のような式を満たす\\(c\\)と\\(\\lambda\\)を求めることになる。 $$ \\[\\begin{aligned} \\lambda \\begin{pmatrix}c_1\\\\ c_2\\\\ c_3\\\\ c_4 \\end{pmatrix} &amp;= \\begin{pmatrix} 0 &amp; 1 &amp; 0 &amp; 0\\\\ 1 &amp; 0 &amp; 1 &amp; 1\\\\ 0 &amp; 1 &amp; 0 &amp; 1\\\\ 0 &amp; 1 &amp; 1 &amp; 0 \\end{pmatrix} \\begin{pmatrix} c_1\\\\ c_2\\\\ c_3\\\\ c_4\\\\ \\end{pmatrix}\\\\ \\\\ \\therefore \\lambda \\begin{pmatrix} c_1\\\\ c_2\\\\ c_3\\\\ c_4\\\\ \\end{pmatrix} &amp;= \\begin{pmatrix} c_2\\\\ c_1 +c_3+ c_4\\\\ c_2+c_4\\\\ c_2+c_3\\\\ \\end{pmatrix} \\end{aligned}\\] $$ ここで、これを満たす\\(\\lambda\\)は正方行列\\(A\\)の固有値、\\(c\\)は固有ベクトルになる1。つまり、隣接行列の固有ベクトルを求めれば、隣接するノードの中心性を反映した中心性を求めることができる(なお、固有値と固有ベクトルの組み合わせは\\(A\\)の列数と同じだけある)。特に絶対値が最大となる固有値に対応する第1固有ベクトルを中心性指標としたものを、固有ベクトル中心性(eigenvector centrality)という。 あるノードの固有ベクトル中心性は、そのノードにつながるノードの中心性を反映しているが、それらのノードは更にそれらにつながるノードの中心性を反映している。このように、固有ベクトル中心性は、そのノードから辺をたどって到達できるすべてのノードの中心性を反映している。 先ほどの例の\\(A\\)の第1固有ベクトルは以下のように求められる。固有ベクトルは負の値をとることもあるため、絶対値をとることが多い。また、最大値を1とした比で表すことも多い。 A = matrix(c(0,1,0,0, 1,0,1,1, 0,1,0,1, 0,1,1,0), nrow = 4, byrow = TRUE) ## 第1固有ベクトル。絶対値をとる。 evc &lt;- abs(eigen(A)$vectors[,1]) ## 最大値を1とするようにする evc/max(evc) ## [1] 0.4608111 1.0000000 0.8546377 0.8546377 ANTsパッケージではmet.eigen()関数で、snaパッケージではevcent()関数で固有ベクトル中心性を求められる。前者は最大が1になるように変形しているのに対し、後者はそのような変形はしていない(定数倍しただけなので、分析上はどちらでも構わない)。 ## ANTs met.eigen(A) ## [1] 0.4608111 1.0000000 0.8546377 0.8546377 ## sna sna::evcent(A) ## [1] 0.2818452 0.6116285 0.5227207 0.5227207 以上は重みなしグラフについて算出を行ったが、重み付きグラフについても同様に算出できる。 隣接行列mat_undir_b(表3.1)ついて、それぞれ重み付き中心性(左)と固有ベクトル中心性(右)の値をノードの大きさに反映させたグラフが図3.4である。 set.seed(123) ## 重み付き中心性の算出 met.strength(mat_undir_b/2, df = attr, dfid = 1) -&gt; attr_st ## 固有ベクトル中心性の算出 met.eigen(mat_undir_b, df = attr_st, dfid = 1) -&gt; attr_st_evc ## 重み付き中心性のグラフ mat_undir_b %&gt;% as_tbl_graph(directed = FALSE) %&gt;% ## `tbl_graph`に重み付き中心性の情報を追加 mutate(strength = attr_st_evc$strength) %&gt;% ggraph(layout = &quot;nicely&quot;)+ geom_node_point(aes(size = strength), shape = 16, color = &quot;black&quot;)+ scale_size(range = c(6,13))+ geom_edge_link(aes(width = weight),color = &quot;grey65&quot;, end_cap = circle(0.5,&quot;cm&quot;), start_cap = circle(0.5,&quot;cm&quot;))+ geom_node_text(aes(label = name), color = &quot;white&quot;)+ scale_edge_width(range = c(1,3))+ labs(title = &quot;重み付き中心性&quot;)+ theme_graph() -&gt; p_strength ## 固有ベクトル中心性のグラフ mat_undir_b %&gt;% as_tbl_graph(directed = FALSE) %&gt;% ## `tbl_graph`に固有ベクトル中心性の情報を追加 mutate(eigen = attr_st_evc$eigen) %&gt;% ggraph(layout = &quot;nicely&quot;)+ geom_node_point(aes(size = eigen), shape = 16, color = &quot;black&quot;)+ scale_size(range = c(6,13))+ geom_edge_link(aes(width = weight),color = &quot;grey65&quot;, end_cap = circle(0.5,&quot;cm&quot;), start_cap = circle(0.5,&quot;cm&quot;))+ geom_node_text(aes(label = name), color = &quot;white&quot;)+ scale_edge_width(range = c(1,3))+ labs(title = &quot;固有ベクトル中心性&quot;)+ theme_graph() -&gt; p_eigen p_strength + p_eigen 図3.4: 重み付き中心性(左)と固有ベクトル中心性(右)の値をノードの大きさに反映させたグラフ 3.1.5 PageRank 固有ベクトル中心性は、分離したグラフや有向グラフの中心性分析には使えない。PageRankは固有ベクトルに基づきながら、これらのグラフにも適用できる中心性指標である。もともとはウェブページの評価法として、Google創業者であるラリー・ペイジとセルゲイ・ブリンらによって開発され(Page et al., 1999)、他ページからのリンクが多いページほどランキングが高く、ランキングの高いページからのリンクや、他のページへのリンクが少ないページからのリンクを高く評価するというアルゴリズムに従う。詳細な算出方法は複雑なので、ここでは説明しない。詳しくは 鈴木 (2017) を参照。 PageRankはigraphパッケージを用いて算出できる。表3.2の隣接行列(mat_dir_b)のPageRankを算出する。 表3.2: 隣接行列(mat_dir_b) A B C D E F G H A 0 2 0 1 0 1 0 0 B 0 0 2 0 0 0 1 0 C 3 2 0 0 0 0 0 0 D 1 0 0 0 0 0 0 0 E 2 0 0 3 0 0 0 0 F 0 0 0 0 2 0 0 2 G 0 1 0 0 0 1 0 0 H 0 0 0 1 0 0 0 0 igraphパッケージでデータを扱う際には、まず隣接行列をigraphクラスにしなくてはならない。graph_from_adjacency_matrix()関数でigraphクラスに変換した後、page.rank()関数でPageRankを算出する。 mat_dir %&gt;% ## 隣接行列をgraphに変換 graph_from_adjacency_matrix(weighted = NULL, mode = &quot;directed&quot;) %&gt;% ## PageRankの算出 page.rank(directed = TRUE) -&gt; page_rank page_rank$vector ## A B C D E F G ## 0.12584798 0.18619542 0.14217932 0.07093242 0.06542177 0.12576921 0.19354160 ## H ## 0.09011228 PageRankの値をノードの大きさに反映したグラフが図3.5である。 set.seed(123) mat_dir_b %&gt;% as_tbl_graph(directed = TRUE) %&gt;% ## `tbl_graph`にPageRankの情報を追加 mutate(PageRank = page_rank$vector) %&gt;% ggraph(layout = &quot;nicely&quot;)+ geom_node_point(aes(size = PageRank),shape = 16, color = &quot;black&quot;)+ scale_size(range = c(6,13))+ geom_edge_fan(aes(width = weight), color = &quot;grey65&quot;, arrow = arrow(angle = 30, length = unit(4,units = &quot;mm&quot;), type = &quot;closed&quot;), end_cap = circle(0.5,&quot;cm&quot;), start_cap = circle(0.5,&quot;cm&quot;))+ geom_node_text(aes(label = name), color = &quot;white&quot;)+ scale_edge_width(range = c(0,2))+ labs(title = &quot;PageRank&quot;)+ theme_graph()+ scale_x_continuous(expand = c(0.05,0.05))+ scale_y_continuous(expand = c(0.05,0.05))-&gt; p_pr p_pr 図3.5: PageRankの値をノードの大きさに反映させたグラフ 3.1.6 媒介中心性(Betweeness centrality) ネットワークにおける媒介や伝達に着目した中心性に媒介中心性がある。媒介中心性は、他のノード同士をつなぐ最短経路上に位置するノードは、ノード間の仲介や情報の伝達に与える影響が大きいという点で有力であり、より多くのノード間の最短経路上にあるノードほどその影響力が大きいとする指標である。 ノード\\(i\\)の媒介中心性は以下の式で定式化される。なお、\\(g_{jk}\\)はノード\\(j\\)と\\(k\\)の間の最短経路数であり、\\(g_{ij}(i)\\)はノード\\(j\\)と\\(k\\)の間の最短経路のうちノード\\(i\\)を通るものの数である。無向グラフの場合、\\(j &lt; k\\)である。 \\[ C_b(i) = \\sum_{i \\neq j \\neq k} \\frac {g_{jk}(i)}{g_{jk}} \\] ANTsパッケージではmet.betweeness()関数で、snaパッケージではsna::betweeness()関数で媒介中心性を求められる。表3.2の隣接行列(mat_dir_b)について算出すると、以下のようになる。 ## ANTs met.betweenness(mat_dir_b, ## 重みなしならTRUE binary = FALSE, ## 無向グラフならTRUE sym = FALSE, ## 最も重みの合計が高い経路を最短とする shortest.weight = TRUE, df = attr, dfid = 1) %&gt;% kable(align = &quot;c&quot;) %&gt;% kable_styling(font_size = 12, full_width = FALSE) name age rank norm.short.outbetweenness A 12 2 22.0 B 13 3 13.5 C 12 4 1.0 D 11 1 8.5 E 14 8 2.5 F 15 1 15.0 G 18 7 5.5 H 9 6 5.5 ## sna sna::betweenness(mat_dir_b, ## 無向グラフなら&quot;undirected&quot; cmode = &quot;directed&quot;, ## 重みなしならTRUE ignore.eval = FALSE) ## [1] 22.0 13.5 1.0 8.5 2.5 15.0 5.5 5.5 媒介中心性の値をノードの大きさに反映したグラフが図3.6である。 図3.6: 媒介中心性の値をノードの大きさに反映させたグラフ 3.1.7 情報中心性(Information centrality) 媒介中心性は最短経路以外の経路や、経路の長さを考慮していなかった。しかし、実際の情報の伝達は最短経路のみでなされるとは限らないし、情報伝達に関わる人が多いほど情報の精度が下がるような可能性もある。そこで、ノード間の最短経路以外の経路や経路の長さを考慮した指標として、情報中心性が考案された。 情報中心性の算出では、経路が短いほど高く評価されるように経路の長さの逆数で重みづけされる。例えば、図3.7のノード\\(2\\)と\\(4\\)について考える。これらのノードの間の経路には\\(2-1-4\\)と\\(2-3-1-4\\)の2通りがあり、それぞれの長さは2と3である。ただし、2つの経路には\\(1-4\\)という共通の経路が存在する。 図3.7: 情報中心性算出のための無向グラフの例 このとき、ノード\\(2\\)と\\(4\\)について以下の行列\\(D_{24}\\)を考える。なお、行列の対角成分にはそれぞれの経路の長さが、それ以外の成分には2つの経路で共通する辺の数が入る。 \\(D_{24} = \\begin{pmatrix} 2 &amp; 1 \\\\1 &amp; 3\\end{pmatrix}\\) そして、この行列の逆行列2\\(D_{24}^{-1}\\)の各行の成分の合計を、各経路の情報量とする。この場合、\\(0.6-0.2 = 0.4\\)が経路\\(2-1-4\\)の、\\(-0.2 + 0.4 = 0.2\\)が経路\\(2-3-1-4\\)の情報量である。また、その和(\\(0.4+0.2=0.6\\))をノード\\(2\\)と\\(4\\)のペアについての情報量(\\(I_{24}\\))とする。このように全てのノードペアについての情報量を算出する(自身との情報量は\\(I_{ii} = \\infty\\)である)。 \\(D_{24}^{-1} = \\begin{pmatrix} 0.6 &amp; -0.2 \\\\ -0.2 &amp; 0.4 \\end{pmatrix}\\) このとき、各ノード\\(i\\)の情報中心性(\\(C_{inf}(i)\\))は、ノード\\(i\\)が含まれるノードペアの情報量の調和平均3になる。数式では以下のように書ける。ただし、\\(n\\)は全ノードの数である。 \\(C_{inf}(i) = \\frac{n}{\\sum_{j=1}^n 1/I_{ij}}\\) 情報中心性はsnaパッケージのinfocent()関数で求められる。表3.2の隣接行列(mat_dir_b)について算出すると、以下のようになる。 infocent(mat_dir_b, ##無向グラフなら &quot;graph&quot; gmode = &quot;digraph&quot;) ## [1] 1.881874 1.408537 1.157895 1.439252 1.483146 1.714286 1.200000 1.168142 情報中心性の値をノードの大きさに反映したグラフを、それぞれPageRankと媒介中心性の値をノードの大きさに反映した2つのグラフと並べたものがが図3.8である。 図3.8: PageRank・媒介中心性・情報中心性の値をノードの大きさに反映させたグラフ 3.2 ネットワーク構造の諸指標 ここでは、ネットワーク全体の構造の特徴を表す指標についてまとめる。 3.2.1 集中度(Centralization) 前節では、各ノードがグラフ内でどの程度中心的かを表す指標として中心性指標を扱ってきた。それらを用いてグラフにおいて特定のノードに高い中心性がどの程度集中しているのかを示す指標が集中度である。グラフの集中度(\\(C_x\\))は以下の式によって定式化され、0から1の値をとる。ただし、各ノードの中心性指標を\\(C_x(i)\\)、グラフにおけるその中心性指標の最大値を\\(C_x(i^*)\\)とする。また、そのグラフと同数のノード(n個)を持つグラフにおける\\(\\sum_{i=1}^n [C_x(i^*)-C_x(i)]\\)の最大値を\\(max\\sum_{i=1}^n [C_x(i^*)-C_x(i)]\\)とする。 \\(C_x = \\frac {\\sum_{i=1}^n [C_x(i^*)-C_x(i)]}{max\\sum_{i=1}^n [C_x(i^*)-C_x(i)]}\\) 例として、第2章で算出した毛づくろい頻度ネットワークgroom_mat_b(表2.3)の集中度を求める。igraphパッケージでは、様々な中心性指標についての中心度を求められる。graph_from_adjacency_matrix()でigraphクラスに変換した後に算出する。 ## igraphクラスに変換 graph_groom &lt;- graph_from_adjacency_matrix(groom_mat_b, ## 有向グラフなら &quot;directed&quot; mode= &quot;undirected&quot;, ## 重みなしなら NULL weighted = TRUE) ## 次数中心性 centr_degree(graph_groom, ## 入次数、出次数ならそれぞれ &quot;in&quot;と&quot;out mode = &quot;all&quot;)$centralization -&gt; cent_deg cent_deg ## [1] 0.2904412 ## 固有ベクトル中心性 centr_eigen(graph_groom, ## 有向グラフならTRUE directed = FALSE)$centralization -&gt; cent_eig cent_eig ## [1] 0.3104138 ## 媒介中心性 centr_betw(graph_groom, directed = TRUE)$centralization -&gt; cent_bet cent_bet ## [1] 0.04678902 各指標の大きさをノードサイズに反映したグラフを以下に示した(図3.9)。集中度はそこまで高くないといえそう(特に媒介中心性は)? 図3.9: 次数中心性・固有ベクトル中心性・媒介中心性の値をノードの大きさに反映したグラフと各指標における集中度。 ノードが赤い個体が各指標の最も大きい個体を示す 3.2.2 密度(Density) 密度は、社会ネットワークにおける関係の緊密さの指標になりうる。密度が低いとき、社会ネットワーク内の個体間の直接的な関係は少なく、両者の関係は媒介者を通じた間接的なものが多いということができる(D. Croft et al., 2008)。 重み無しグラフの場合: 実際の辺の数をグラフに張ることが可能な辺の最大数で割ったもの ノードの数を\\(n\\)、実際の辺の数を\\(m\\)としたとき、\\(2m/n(n-1)\\)(無向グラフ)または\\(m/n(n-1)\\)(有向グラフ) 重み付きグラフの場合: 全辺の重みの合計をグラフに張ることが可能な辺の最大数で割ったもの ノードの数を\\(n\\)、重みの合計を\\(w\\)としたとき、\\(2w/n(n-1)\\)(無向グラフ)または\\(2m/n(n-1)\\)(有向グラフ) ここでは、表3.1の隣接行列を用いて密度を算出する。 ANTsパッケージでは、met.density()で計算可能。ただし、重みなしグラフとして算出されるよう。また、list()関数で複数の隣接行列をリスト化することで、同時に2つ以上の隣接行列について密度を算出できる。 met.density(mat_undir_b) ## Density ## 0.3571429 ## リスト化 list_mat &lt;- list(mat_undir_b, mat_dir_b) met.density(list_mat) ## [[1]] ## [1] 0.3571429 ## ## [[2]] ## [1] 0.2678571 snaパッケージでは、gden()で計算可能。ignore.value = FALSEとすると重み付きグラフとして扱われる。ANTsパッケージと同様、リスト化した複数の隣接行列の密度を同時に算出できる。 ## 重み付き gden(mat_undir_b, ## 重み無グラフならば、TRUE ignore.eval = FALSE, ## 有向グラフならば &quot;digraph&quot; mode = &quot;graph&quot;) ## [1] 0.6428571 ## リスト化 gden(list_mat) ## [1] 0.6428571 0.4464286 3.2.3 同類性(Assortativity) ネットワーク内において、似ているノード同士が結びつきやすい/結びつきにくいかを表したのが同類性である。ネットワーク内の辺の両端にあるノードの中心性指標や属性の相関係数を算出したものであり、-1から1の値をとる(重み付きグラフの場合は、それで重み付けされているよう)。各ノードの離散的な属性(性別、順位カテゴリなど)と連続的な属性(中心性指標、年齢など)のいずれにも適用できる。計算方法の詳細は Farine (2014) を参照。 ここでは例として、再び毛づくろい頻度ネットワークgroom_mat_b(表2.3)を使用する。同類性はassortnetパッケージ(Farine, 2014)の関数群を用いて算出できる。 3.2.3.1 連続的な属性の場合 年齢が近い個体同士が結びつきやすいかを調べる。連続的な属性の同類性はassortment.continuous()関数で算出できる。係数は-0.397…となり、年齢の近い個体同士は結びつきにくいという結果になった。 ## 年齢(2019年時点) age &lt;- c(13,10,11,11,15,8,13,9,7,18,9,11,16,11,14,11,11) ## 同類性 assortment.continuous(groom_mat_b, ## 各ノードの属性 vertex_values = age, ## 重みなしなら FALSE weighted = TRUE) ## $r ## [1] -0.397096 3.2.3.2 離散的な属性の場合 同じ年齢カテゴリ(低順位: m、中順位: m、高順位: h)の個体同士が結びつきやすいかを調べる。離散的な属性の同類性はassortment.discrete()関数で算出できる。係数はかなり高く(0.484…)、同順位カテゴリ―の個体同士がよく結びつく傾向がある。 ## 順位カテゴリ rank &lt;- c(&quot;m&quot;,&quot;m&quot;,&quot;l&quot;,&quot;l&quot;,&quot;h&quot;,&quot;h&quot;,&quot;h&quot;,&quot;h&quot;,&quot;h&quot;,&quot;h&quot;,&quot;l&quot;,&quot;l&quot;,&quot;l&quot;,&quot;m&quot;,&quot;m&quot;,&quot;m&quot;,&quot;m&quot;) ## 同類性 assortment.discrete(groom_mat_b, ## 各ノードの属性 types = rank, ## 重みなしなら FALSE weighted = TRUE) -&gt; assort_rank assort_rank$r ## [1] 0.4840036 各カテゴリ間のノードのweightの合計を計算した隣接行列も出力してくれる(表3.3)。この表からも、同順位カテゴリ間での交渉が多いことが分かる。 assort_rank$mixing_matrix %&gt;% kable(digits = 2, align = &quot;c&quot;,caption = &quot;各カテゴリ間のweightの合計&quot;) %&gt;% kable_styling(font_size = 12, full_width = FALSE) 表3.3: 各カテゴリ間のweightの合計 m l h ai m 0.25 0.08 0.06 0.40 l 0.08 0.13 0.02 0.23 h 0.06 0.02 0.28 0.36 bi 0.40 0.23 0.36 1.00 なお離散的な属性については、ANTsパッケージのmet.assortativity()関数を用いると、node permutation(詳細は4.2)で生成したランダムなネットワークにおける同類性を指定した数だけ生成してくれる。それらの何%より実際の同類性の数値が大きい/小さいかを検討することで、統計的な検定が行える。今回の例では、実測値はランダムな値の全てより小さいので、ランダムな場合より有意に小さいと言える(図3.10)。 ## node label permutationで生成したランダムなネットワーク100個についてassortativityを算出 met.assortativity(groom_mat_b, ## 各ノードの固有ベクトル中心性 attr = rank, ## 重みなしの場合 FALSE weighted = TRUE, ## node label permutationをするか perm.nl = TRUE, ## permutationの数 nperm = 10000) -&gt; nlperm_rank ### ランダムなassortativityの何%より小さい？ sum(nlperm_rank &gt; assort_rank$r)/10000 ## [1] 1e-04 図3.10: ランダムなネットワークの同類性の分布(灰色)と実測値(赤) 3.2.4 推移性(Transitivity) ネットワークにおいて、頂点\\(i\\)と\\(j\\)の間、および頂点\\(j\\)と\\(k\\)の間に関係があり、頂点\\(i\\)と\\(k\\)の間にも関係があるとき、関係が推移的であるという。例えば、図3.11で頂点A, B, Cの関係は推移的だが、頂点A, B, Gは推移的ではない。 図3.11: 推移性の説明のための無向グラフの例 有向グラフの場合は、頂点\\(i\\)から\\(j\\)、頂点\\(j\\)から\\(k\\)に有向辺があり、かつ頂点\\(i\\)から\\(k\\)に有向辺があるとき推移的であるという(図3.12)。 図3.12: 推移性の説明のための有向グラフの例 推移性はネットワーク内で推移的な関係が成り立っている比率を指す。例えば無向グラフの場合には、頂点\\(i\\)と\\(j\\)、\\(j\\)と\\(k\\)の間に辺があるとき、頂点\\(i\\)と\\(k\\)にも辺がある割合である。推移性はネットワークがどの程度クラスター化されているかの指標になる(Farine &amp; Whitehead, 2015)。そのため、クラスター係数と呼ばれることもある。 例として、毛づくろい頻度ネットワークgroom_mat_b(表2.3)の推移性を算出する。推移性はigraphパッケージのtransitivity()関数で求められる。推移性は高い？ transitivity(graph_groom, ## 有向グラフなら &quot;directed&quot; type = &quot;undirected&quot;) ## [1] 0.6909722 3.2.5 Modularity 霊長類のネットワークの種間比較でよく用いられる指標にNewmanのmodularity(Newman, 2004; Whitehead, 2008)がある。この指標は、ネットワーク内を複数のクラスターに分けたとき、クラスター内の個体間での交渉がクラスター間の個体間の交渉よりどの程度多いかを示したもので、0から1の値をとる。値が高い(1に近い)ほどその差が大きいことを示し、クラスターの分け方が妥当であることを示す。Newman (2004) は、modularityが0.3以上のとき、クラスター間がよく分断されているとしている。例えばマカクの種間比較研究では、血縁ごとにクラスター分けしたとき、寛容性が低い種は高い種よりもmodularityが高い(0.33±0.08 vs 0.21 ±0.03)、つまり交渉がより血縁に偏っていることが分かっている(Sueur, Petit, et al., 2011)。 Modularityは以下のように定式化される(Csardi et al., 2006)。 \\(Q = \\frac{1}{2m} \\sum_{i,j} (A_{ij} - \\gamma \\frac{k_i k_j}{2m}) \\delta(c_i,c_j)\\) なお、\\(m\\)は辺の数、\\(A_{ij}\\)は隣接行列の\\(i\\)行目\\(j\\)列目の成分、\\(k_i\\)と\\(k_j\\)はノード\\(i\\)と\\(j\\)の重み付き中心性を表す(\\(k_i\\)と\\(k_j\\)に固有ベクトル中心性を使っている論文もある(Balasubramaniam et al., 2018))。また、\\(\\delta(c_i,c_j)\\)はノード\\(i\\)と\\(j\\)が同じクラスターに属しているときは1、そうでないときは0になる。なお、\\(\\gamma \\frac{k_i k_j}{2m}\\)の部分は、ランダムに交渉が行割れていると仮定したときの\\(A_{ij}\\)の値である。\\(\\delta\\)はデフォルトでは1だが変化させることができ、大きい値をとるほどクラスター数が多くなる。 ここでは例として、毛づくろい頻度ネットワークgroom_mat_b(表2.3)を用いて、各順位カテゴリ内(低順位・中順位・高順位)の交渉がカテゴリ間の交渉よりどの程度多いかを、\\(Q\\)を算出することで求める。 Rでは、igraphパッケージのmodularity()関数で求めることができる。graph_from_adjacency_matrix()でigraphクラスに変換した後に算出する。また、weight =で明示的に各エッジのweightを与えてあげる必要があるよう。modularityは0.315…とそこそこ大きい値であるので、順位カテゴリ内に毛づくろいが偏っていることを示している。 ## 順位カテゴリごとに番号を振る rank &lt;- c(2,2,1,1,3,3,3,3,3,3,1,1,1,2,2,2,2) ## igraphに変換 graph_groom &lt;- graph_from_adjacency_matrix(groom_mat_b, ## 有向グラフなら &quot;directed&quot; mode= &quot;undirected&quot;, ## 重みなしなら NULL weighted = TRUE) modularity(graph_groom, ## クラスターの分け方 membership = rank, ## deltaの値 resolution = 1, ## 有向グラフなら TRUE directed = FALSE, ## グラフのweightを与える weights = E(graph_groom, directed = FALSE)$weight) ## [1] 0.3152957 3.2.6 応用例(下位集団の検出) ネットワーク内に下位集団(クラスター)が存在するかを調べる方法はたくさんあるが(詳細は 鈴木, 2017)、ここでは主に2つの方法に焦点を当てて紹介する。 3.2.6.1 Modularityを用いる方法 一つの方法としてmodularityが最大になるような分け方がある。igraphパッケージでは、cluster_optimal()でそのようなクラスタの分け方を算出してくれる。なお、ノード数が多い場合には時間がかかるため、様々な近似計算法が考案されている(cluster_fast_greedy()、cluster_walktrap()など)。 例として、毛づくろい頻度ネットワークgroom_mat_b(表2.3)について算出する。その結果、4つのクラスターに分類され、そのときのmodularityは0.40だった。概ね順位ごとに分かれていることが分かる(同じアルファベットから始まる個体が同一家系である)。高順位、中順位(2つに分かれている)、低順位にほぼ綺麗に分かれた。 ## 算出 cluster_optimal(graph_groom, weights = E(graph_groom)$weight) -&gt; cluster_groom ## 結果 cluster_groom ## IGRAPH clustering optimal, groups: 4, mod: 0.4 ## + groups: ## $`1` ## [1] &quot;Aka&quot; &quot;Ako&quot; &quot;Mei&quot; ## ## $`2` ## [1] &quot;Hen&quot; &quot;Hot&quot; &quot;Mal&quot; &quot;Mik&quot; &quot;Tam&quot; &quot;Tot&quot; ## ## $`3` ## [1] &quot;Kil&quot; &quot;Kit&quot; &quot;Koh&quot; &quot;Kor&quot; &quot;Kun&quot; &quot;Kur&quot; ## ## $`4` ## + ... omitted several groups/vertices ## modularity modularity(cluster_groom,directed = FALSE, weights = NULL) ## [1] 0.4020546 ## 確認 modularity(graph_groom, ## クラスターの分け方 membership = membership(cluster_groom), ## deltaの値 resolution = 1, ## 有向グラフなら TRUE directed = FALSE, weights = E(graph_groom)$weight) ## [1] 0.4020546 クラスターごとに色分けして図示すると図3.13のようになる。 set.seed(125) graph_groom %&gt;% as_tbl_graph(directed = FALSE) %&gt;% ## 各個体がどのクラスターに属するかを指定 mutate(member = as.factor(cluster_groom$membership)) %&gt;% ggraph(layout = &quot;nicely&quot;)+ ## クラスターごとに囲う geom_mark_hull(aes(x=x,y=y,fill = member), concavity = 10)+ geom_node_point(aes(color = member),shape = 16, size = 12)+ geom_edge_link(start_cap = circle(0.5,&quot;cm&quot;), end_cap = circle(0.5,&quot;cm&quot;), color = &quot;grey55&quot;, aes(width = weight))+ scale_edge_width(range = c(0,3))+ geom_node_text(aes(label = name), color = &quot;white&quot;)+ theme_graph()+ scale_color_nejm()+ scale_fill_nejm()+ theme(aspect.ratio = 0.9)+ scale_x_continuous(expand = c(0.12,0.12))+ scale_y_continuous(expand = c(0.1,0.1)) 図3.13: Modularityに基づいてクラスターごとに色分けした毛づくろい頻度のグラフ 3.2.6.2 構造類似性を用いる方法 他の方法として、ノード間でネットワーク内での構造的な位置が類似している程度(= 構造類似性)を用いる方法がある。構造類似性の指標として良く用いられるのがユークリッド距離や相関係数である。このような構造類似性の指標を用い、ネットワーク上における位置の似た頂点をひとまとめにし、ネットワークをより少ないいくつかのブロック同士の関係に分けることをブロックモデリングという。 ユークリッド距離 ノード\\(i\\)と\\(j\\)のユークリッド距離(\\(d_{ij}\\))は隣接行列\\(A = (a_{ij})\\)について以下のように定式化される。\\(d_{ij}\\)が大きいほど類似性は低い。 \\[ d_{ij} = \\sqrt {\\sum_{k =1}^{n}(a_{ij}-a_{jk})^2 + (a_{ki}-a_{kj})^2 } \\] 相関係数 ノード\\(i\\)とノード\\(j\\)の相関係数(\\(r_{ij}\\)は隣接行列\\(A = (a_{ij})\\)について以下のように定式化される。\\(r_{ij}\\)が大きいほど類似性は高い。 \\[ r_{ij} = \\frac{(i列とj列の共分散) + (i行とj行の共分散)}{(i列とi行の標準偏差) \\times (j列とj行の標準偏差)} \\] snaパッケージのequiv.clust()関数を用いることで、構造同値性に基づいたクラスター分析ができる。ここでは、毛づくろい頻度ネットワークgroom_mat_b(表2.3)のユークリッド距離を用いて分析を行う。method =で使用する構造類似性の指標を、clust.method =で階層クラスター分析の方法を指定する(方法の詳細はこちら) 。 ## ユークリッド距離 cluster_groom_euc &lt;- equiv.clust(groom_mat_b, ## 相関係数なら &quot;correlation&quot; method = &quot;euclidean&quot;, ## 階層クラスター分析の方法 cluster.method = &quot;complete&quot;) クラスター分析に基づくデンドログラムは図3.14のようになる。縦軸が互いのユークリッド距離を表す。 図3.14: クラスター分析結果に基づくデンドログラム この結果からblockmodel()関数でブロックモデルを作る。引数h =でクラスター(= ブロック)を作る基準となる高さを、もしくは引数k =でブロック数を指定できる。ここでは、ブロック数を3つに指定したときの結果を調べる。各個体がどのブロックに振り分けられたかは、表3.4の通りである。 blockmodel_groom_3 &lt;- blockmodel(## 隣接行列 groom_mat_b, ## クラスター分析結果 cluster_groom_euc, ## `k =`でクラスター数の指定。`h = `でクラスターの基準の高さも指定できる。 k = 3) ## メンバーシップ data.frame(femaleID = blockmodel_groom_3$plabels, block = blockmodel_groom_3$block.membership) %&gt;% arrange(femaleID) -&gt; membership_3 membership_3 %&gt;% pivot_wider(names_from = femaleID, values_from = block) %&gt;% kable(align = &quot;c&quot;, caption = &quot;ブロック数が3のときに各個体が属するブロック&quot;) %&gt;% kable_styling(font_size = 8, full_width = FALSE) 表3.4: ブロック数が3のときに各個体が属するブロック Aka Ako Hen Hot Kil Kit Koh Kor Kun Kur Mal Mei Mik Ntr Tam Ten Tot 1 1 2 2 3 3 3 3 2 3 2 2 2 2 2 2 2 ブロック数を2から5に変化させたときにmodularityがどうなるかを調べたところ、k = 3のときに最大になるよう(表3.5)。 k = 2:5 ## kを2~5にしたときに各個体が属するブロックを計算 map(k, ~blockmodel(## 隣接行列 groom_mat_b, ## クラスター分析結果 cluster_groom_euc, ## `k =`でクラスター数の指定。`h = `でクラスターの基準の高さも指定できる。 k = .)$block.membership) -&gt; member_list ## modularityを算出 data.frame(k = rep(k,each = 17),femaleID = blockmodel_groom_3$plabels, member = c(member_list[[1]],member_list[[2]],member_list[[3]],member_list[[4]])) %&gt;% group_by(k) %&gt;% nest() %&gt;% mutate(member2 = map(data,~arrange(., femaleID)$member)) %&gt;% select(k, member2) %&gt;% group_by(k) %&gt;% mutate(modularity = map(member2, ~modularity(graph_groom, membership = as.factor(.), weights = E(graph_groom, directed = FALSE)$weight))) %&gt;% select(k, modularity) %&gt;% unnest(cols = c(modularity)) %&gt;% kable(align = &quot;c&quot;, caption = &quot;ブロック数を2~5にしたときのmodularity&quot;) %&gt;% kable_styling(font_size = 13, full_width = FALSE) 表3.5: ブロック数を2~5にしたときのmodularity k modularity 2 0.2279996 3 0.3592285 4 0.3317726 5 0.2642927 clValidパッケージのclValid()関数では、様々な指標を用いてクラスター分けが妥当か算出してくれるよう。詳しくは、 Brock et al. (2008) もしくはこちらを参照。よく使用される指標であるDunn indexと silhouette widthの結果を見ると、3つのクラスターに分けるのが妥当だと示唆される。 clValid(obj = groom_mat_b, nClust = 2:5, clMethods = &quot;hierarchical&quot;, validation = &quot;internal&quot;, Metric = &quot;euclidean&quot;) -&gt; result summary(result) ## ## Clustering Methods: ## hierarchical ## ## Cluster sizes: ## 2 3 4 5 ## ## Validation Measures: ## 2 3 4 5 ## ## hierarchical Connectivity 2.9290 5.8579 8.8869 11.9270 ## Dunn 0.8946 1.3325 0.6119 0.6219 ## Silhouette 0.5547 0.5632 0.2284 0.1967 ## ## Optimal Scores: ## ## Score Method Clusters ## Connectivity 2.9290 hierarchical 2 ## Dunn 1.3325 hierarchical 3 ## Silhouette 0.5632 hierarchical 3 ３つのクラスターごとに色分けして図示すると図3.15のようになる。 set.seed(125) graph_groom %&gt;% as_tbl_graph(directed = FALSE) %&gt;% ## 各個体がどのブロックに属するかを指定 mutate(member = as.factor(membership_3$block)) %&gt;% ggraph(layout = &quot;nicely&quot;)+ ## ブロックごとに囲む geom_mark_hull(aes(x=x,y=y,fill = member), concavity = 10)+ geom_node_point(aes(color = member),shape = 16, size = 12)+ geom_edge_link(start_cap = circle(0.5,&quot;cm&quot;), end_cap = circle(0.5,&quot;cm&quot;), color = &quot;grey55&quot;, aes(width = weight))+ scale_edge_width(range = c(0,3))+ geom_node_text(aes(label = name), color = &quot;white&quot;)+ theme_graph()+ scale_color_nejm()+ scale_fill_nejm()+ theme(aspect.ratio = 0.9)+ scale_x_continuous(expand = c(0.1,0.1))+ scale_y_continuous(expand = c(0.1,0.1)) 図3.15: 構造類似性に基づいてクラスターごとに色分けした毛づくろい頻度のグラフ 3.2.7 その他 個体間の敵対的交渉の隣接行列を用いた順位序列についての各指標の算出については、筆者の別稿を参照。ここで紹介しきれなかった他の指標やクラスター分析の手法については、Whitehead (2008) , D. Croft et al. (2008) , 鈴木 (2017) などを参照。 References Balasubramaniam, K. N., Beisner, B. A., Berman, C. M., De Marco, A., Duboscq, J., Koirala, S., Majolo, B., Macintosh, A. J. J. J., McFarland, R., Molesti, S., Ogawa, H., Petit, O., Schino, G., Sosa, S., Sueur, C., Thierry, B., Waal, F. B. M. M. de, &amp; McCowan, B. (2018). The influence of phylogeny, social style, and sociodemographic factors on macaque social network structure. Am. J. Primatol., 80(1), e22727. Brock, G., Pihur, V., Datta, S., &amp; Datta, S. (2008). clValid: An R package for cluster validation. J. Stat. Softw., 25, 1–22. Croft, D., James, R., &amp; Krause, J. (2008). 動物の社会ネットワーク分析 (島田将喜., Trans.). 東海大学出版部. Csardi, G., Nepusz, T., &amp; Others. (2006). The igraph software package for complex network research. InterJournal, Complex Systems, 1695(5), 1–9. Farine, D. R. (2014). Measuring phenotypic assortment in animal social networks: Weighted associations are more robust than binary edges. Anim. Behav., 89, 141–153. Farine, D. R., &amp; Whitehead, H. (2015). Constructing, conducting and interpreting animal social network analysis. J. Anim. Ecol., 84(5), 1144–1163. Newman, M. E. J. (2004). Analysis of weighted networks. Phys. Rev. E Stat. Nonlin. Soft Matter Phys., 70(5 Pt 2), 056131. Page, L., Brin, S., Motwani, R., &amp; Winograd, T. (1999). The PageRank citation ranking: Bringing order to the web. Stanford InfoLab. Sosa, S., Puga-Gonzalez, I., Hu, F., Pansanel, J., Xie, X., &amp; Sueur, C. (2020). A multilevel statistical toolkit to study animal social networks: The animal network toolkit software (ANTs) R package. Sci. Rep., 10(1), 12507. Sueur, C., Petit, O., De Marco, A., Jacobs, A. T., Watanabe, K., &amp; Thierry, B. (2011). A comparative network analysis of social style in macaques. Anim. Behav., 82(4), 845–852. Whitehead, H. (2008). Analyzing animal societies. The University of Chicago Press. 鈴木努. (2017). R で学ぶデータサイエンス 8 ネットワーク分析 第2版 (金明哲., Ed.). 共立出版. 分からない場合はこちら↩︎ 分からない場合はこちら↩︎ 調和平均とは、逆数の平均の逆数である。例えば、1, 2, 4の調和平均は次のようになる。 \\[ \\frac{3}{\\frac{1}{1} + \\frac{1}{2} + \\frac{1}{4}} = \\frac{1}{\\frac{7}{12}} = \\frac{12}{7} \\]↩︎ "],["c4.html", "4 統計的検定 4.1 なぜランダム化検定が必要か？ 4.2 Network permutation 4.3 data stream randomization", " 4 統計的検定 4.1 なぜランダム化検定が必要か？ マトリックス内の数値やそこから算出されたネットワーク指標は互いに独立ではない(D. P. Croft et al., 2011; Farine, 2017; Farine &amp; Whitehead, 2015)。例えば、図4.1のグラフの重みづけ中心性について考える。ノードAとCの重みづけ中心性をそれぞれ計算するとき、どちらの計算にもAとCをつなぐ辺の重み(3)が入ってくる(A:1+1+2+3; C: 2+2+3)。つまり、これらのノードの重みづけ中心性は互いに関連しあっている(= 独立ではない)。これは、辺で繋がっている全てのノード同士の重み付き中心性について言える。このように、ネットワーク内のデータや中心性指標のほとんどは互いに独立ではない。 図4.1: ネットワークデータの非独立性の説明のためのグラフ これは、統計的な分析を行おうとするときに大きな問題になる。なぜなら、ほとんどの統計分析(t検定、相関分析、GLMなどの回帰分析、…)ではデータが互いに独立していることが仮定されているからである(D. P. Croft et al., 2011)。そのため、ネットワークデータにそのままこのような分析を適用すると、誤った結果が得られる確率が高くなってしまうのである。 この問題に対処するために最もよく用いられる方法がランダム化検定(randomization test)である(D. P. Croft et al., 2011; Farine, 2017; Farine &amp; Whitehead, 2015)。ランダム化検定とは、「ランダムな」ネットワークを大量(少なくとも1000回以上)に生成した後、それらから得られた統計検定量(実際にはt検定量や回帰係数など)の分布を帰無分布4として、実際の統計検定量の有意性を判定する方法である。 適切にランダム化検定を行うためには、検定の対象となる側面についてはランダム化する一方で、それ以外の側面(e.g., 各個体の観察回数、ノードと辺の数、ネットワークの構造など)については可能な限り一定になるようにランダムネットワークを生成することが重要である。この点を考慮するため、ネットワーク分析では実データをシャッフルすることでランダムなネットワークを生成するパーミュテーション検定(permutation test)がよく用いられる。パーミュテーション検定は、どの段階のデータをランダム化するかによって大きく2つに分けられる。以下では、それぞれについて詳しくみていく。より詳しい解説は D. P. Croft et al. (2011)、 Farine &amp; Whitehead (2015)、 Farine (2017) を参照。 Network permutation: 既に作られたネットワーク上のノードや辺をシャッフルする。 Pre-network permutation (Data stream permutation): ネットワークを作る前に、交渉やassociationの生データをシャッフルする。 なお、検定の際にはいずれかのランダム化のみを施すことが多いが、どちらのランダム化も同時に適用した方がより頑強な結果が得られるという報告もある(Farine &amp; Carter, 2022)。 4.2 Network permutation Network permutationには大きく分けて辺をシャッフルするedge permutationと、ノードをシャッフルするnode permutationに分けられるが、本節ではより一般的に用いられている後者についてのみ解説を行う。前者は生物のネットワークではあまり用いられないため(D. P. Croft et al., 2011; Farine, 2017)、ここでは解説しない。 Node permutationでは、ノードの属性(性別、順位など)をランダムにシャッフルして生成したランダムなネットワークにおける統計検定量の分布を帰無分布とし、実際のデータの統計検定量をそれと比較することで有意性を判定する方法である。 図4.2: Node permutationの例 有意性は以下のように実際の値がランダムに生成された1000このネットワークの値の何%より大きいかで判断する。 図4.3: Node permutationでの検定の例 4.2.1 線形回帰分析 例えば、上(1.1)で求めた毛づくろいネットワークにおいて、順位や年齢と固有ベクトル中心性に関連があるか知りたいとする。 以下のような一般化線形モデルを考える。 分布: 正規分布 応答変数: 固有ベクトル中心性 説明変数: 順位、年齢 それでは、node label permutationを行う ここでは、従属変数のラベルをランダム化する。 #perm_glm &lt;- perm.net.nl(female_metrics, # ## ランダマイゼーションするラベル # labels = &quot;eigen&quot;, # ## 回数 # nperm = 10000) 分析は以下の通り。 #r &lt;- stat.glm(perm_glm, # formula = eigen ~ age + rank, # family = &quot;gaussian&quot;) ランダムなネットワークにおける係数と実際のネットワークにおける係数の比較。 #r_ant &lt;- ant(r) 結果は以下の通り。 有意な結果は得られなかった。 #r_ant$model モデル診断。 #r_ant$model.diagnostic GLM以外にも、t検定や相関分析、GLMM等を同様に行うことができる。 4.2.2 ネットワーク同士の関連の検討 node label randomizationによってネットワーク同士の関連を調べることもできる。 例えば、上(1.2)で求めたメスが一緒に確認される割合が、個体間の血縁度や順位差と関連しているか調べるとする。 イメージとしては、以下のようにネットワーク同士で回帰分析を行うような感じである。 このような分析をMRQAP検定という(Dekker et al., 2007)。 MRQAP検定のイメージ 分析には、aninetパッケージを用いる(Franks et al., 2021)。 library(aninet) 血縁と順位差マトリクスの読み込み。 kin_mat &lt;- read.csv(&quot;data/kin_demo.csv&quot;, row.names=1) %&gt;% as.matrix() rank_mat &lt;- read.csv(&quot;data/rank_demo.csv&quot;,row.names = 1) %&gt;% as.matrix() ## マトリクスの順番を合わせる presence_mat &lt;- presence_mat[rownames(kin_mat),rownames(kin_mat)] glmqap()関数を用いれば様々な分布を用いたモデリングを行うことができる。 ここでは、SRIを応答変数とするので、二項分布を用いたモデリングを行う。 SRIの分母を以下のようにして求める。 denom &lt;- get_denominator(presence %&gt;% dplyr::select(-date), return = &quot;matrix&quot;, index = &quot;SRI&quot;) denom &lt;- denom[rownames(kin_mat),colnames(kin_mat)] 分析は以下の通り。 #r_qap &lt;- glmqap(presence_mat ~ rank_mat + kin_mat, # ## 分母のマトリクス # weights = denom, # family = &quot;binomial&quot;, # nperm = 10000, # permutation = &quot;DSP&quot; # ) 結果は以下の通り。 4.3 data stream randomization マトリクスを作る前にランダマイゼーションを行うpre-network randomizationという方法もある。 代表的なものはdata stream randamizationと呼ばれるものである。詳しくは、Farine &amp; Whitehead (2015)参照。 ANTsパッケージでdata stream randomizationを行うことができる。 ここでは、group by individualの形式で記録したメスの出欠データ(1.2参照)を用いる。 ランダマイゼーションを行うためには、縦長のデータフレームにする必要がある。 ## まずはデータフレームの形に直す。 presence_mat &lt;- presence %&gt;% column_to_rownames(&quot;date&quot;) %&gt;% as.matrix() ## gbi.to.df関数でデータフレーム形式に presence_df &lt;- gbi.to.df(presence_mat) perm.ds.grp()でdata stream randomizationを行うことができる。 ここでは、観察日ごとに個体の出欠を10000回シャッフルするが、もしあれば時間や場所などの情報もctrlfという引数で加えることが可能である。詳しくは、Farine (2017)を参照。 #perm_ds &lt;- perm.ds.grp(presence_df, # scan = &quot;scan&quot;, # nperm = 10000, # index = &quot;sri&quot;) 生成された10001(実データ1 + ランダマイゼーション×10000)それぞれについて、ネットワーク指標を算出して、メスの属性データと結合する。やり方は、第2節と同様であるが、map()を用いることで10001個のマトリクスそれぞれについて算出できる。 ## メスの属性データ #attribute_b &lt;- attribute %&gt;% #filter(femaleID != &quot;Tam&quot;&amp;femaleID != &quot;Kur&quot;) %&gt;% #arrange(femaleID) #list &lt;- map(perm_ds,met.eigen, df = attribute_b, dfid = 1) それでは、算出した値を用いて統計的検定を行う。 3.1.1と同様に、以下のような線形モデルを考える。 以下のような一般化線形モデルを考える。 分布: ガンマ分布 応答変数: 固有ベクトル中心性 説明変数: 順位、年齢 まず、算出したネットワーク指標を一つのデータフレームにまとめ、マトリクスごとにネスト化する。 #for(i in 2:10001){ # if(i == 2){ # female_met &lt;- bind_rows(list[[i-1]],list[[i]]) # } else{ # female_met &lt;- bind_rows(female_met,list[[i]]) # } # } #female_met %&gt;% # mutate(perm.no = rep(1:10001,each = 15)) %&gt;% # group_by(perm.no) %&gt;% # nest() -&gt; female_met_nest map()を用いて、それぞれのマトリクスごとにGLMを行う。 #r_ds &lt;- map(female_met_nest$data, ~ glm(formula = eigen ~ rank + age, data = .,family = &quot;Gamma&quot;)) 例えば、1つめのマトリクス(ここでは実測値)の結果は以下のようになる。 ここで算出されているp値はこんかいは用いることができない(データの独立性を仮定した結果なので)。 得られた係数(Coefficient)をランダム化されたマトリクスを用いた分析の係数と比較することで有意性を判定する。 #model_parameters(r_ds[[1]]) #coef_rank_r &lt;- r_ds[[1]]$coefficients[[2]] #coef_age_r &lt;- r_ds[[1]]$coefficients[[3]] ランダム化された10000個のマトリクスで算出された順位と血縁の係数をまとめたデータフレームを作成する。 #coef &lt;- data.frame(coef_rank = 0L, # coef_age = 0L) #for(i in 2:10001){ # coef[i-1,1] &lt;- r_ds[[i]]$coefficients[[2]] # coef[i-1,2] &lt;- r_ds[[i]]$coefficients[[3]] #} 実データの係数がランダム化されたマトリクスの係数のうち95%よりも大きい/小さいときに、実データの係数は有意に大きい/小さいとする。 順位については、以下のような結果になるので(p_upper = 0.0426)、順位の係数はランダムな場合よりも有意に大きい(＝固有ベクトル中心性に有意に正の関連がある)ということができる。 #p_upper1 &lt;- sum(coef$coef_rank &gt; coef_rank_r)/10000 #p_lower1 &lt;- sum(coef$coef_rank &lt; coef_rank_r)/10000 #p_upper1 #p_lower1 #coef %&gt;% # ggplot(aes(x=coef_rank))+ # geom_histogram(bins = 500)+ # geom_vline(xintercept = coef_rank_r, # color = &quot;red&quot;)+ # geom_text(aes(x = 0.0053, y = 60), # label = str_c(&quot;実測値\\n&quot;,&quot;p_upper =&quot;, p_upper1), # hjust=0)+ #theme_bw() 年齢については、以下のような結果になるので(p_upper = 0.057)、有意な影響はないとなる。 #p_upper2 &lt;- sum(coef$coef_age &gt; coef_age_r)/10000 #p_lower2 &lt;- sum(coef$coef_age &lt; coef_age_r)/10000 #p_upper2 #p_lower2 #coef %&gt;% # ggplot(aes(x=coef_age))+ # geom_histogram(bins = 500)+ # geom_vline(xintercept = coef_age_r, #color = &quot;red&quot;)+ # geom_text(aes(x = 0.045, y = 65), # label = str_c(&quot;実測値\\n&quot;,&quot;p_upper =&quot;, p_upper2), # hjust =0)+ # theme_bw() References Croft, D. P., Madden, J. R., Franks, D. W., &amp; James, R. (2011). Hypothesis testing in animal social networks. Trends in Ecology and Evolution, 26(10), 502–507. Dekker, D., Krackhardt, D., &amp; Snijders, T. A. B. (2007). Sensitivity of MRQAP tests to collinearity and autocorrelation conditions. Psychometrika, 72(4), 563–581. Farine, D. R. (2017). A guide to null models for animal social network analysis. Methods Ecol. Evol., 8(10), 1309–1320. Farine, D. R., &amp; Carter, G. G. (2022). Permutation tests for hypothesis testing with animal social network data: Problems and potential solutions. Methods Ecol. Evol., 13(1), 144–156. Farine, D. R., &amp; Whitehead, H. (2015). Constructing, conducting and interpreting animal social network analysis. J. Anim. Ecol., 84(5), 1144–1163. Franks, D. W., Weiss, M. N., Silk, M. J., Perryman, R. J. Y., &amp; Croft, D. P. (2021). Calculating effect sizes in animal social network analysis. Methods Ecol. Evol., 12(1), 33–41. 帰無仮説(今回の場合はランダムなネットワーク)が正しいとしたときの統計検定量の分布。↩︎ "],["おまけ.-csiの算出.html", "5 おまけ. CSIの算出", " 5 おまけ. CSIの算出 aninetパッケージを用いれば、CSI(Silk et al., 2006)を容易に算出できる。 上で算出すしたメス間の毛づくろいマトリクスと、以下の近接マトリクスを用いて算出する。 prox_mat &lt;- read.csv(&quot;data/prox_f.csv&quot;,row.names=1) %&gt;% as.matrix() rownames(prox_mat) &lt;- colnames(prox_mat) prox_mat %&gt;% data.frame() ## Kil Kit Koh Kun Kor Ntr ## Kil NA 0.148601399 0.10733945 0.029467085 0.04553818 0.04176334 ## Kit 0.148601399 NA 0.09505410 0.064403395 0.06003098 0.03628560 ## Koh 0.107339450 0.095054096 NA 0.059630607 0.08569119 0.02036660 ## Kun 0.029467085 0.064403395 0.05963061 NA 0.03599788 0.02032086 ## Kor 0.045538178 0.060030984 0.08569119 0.035997882 NA 0.06288281 ## Ntr 0.041763341 0.036285603 0.02036660 0.020320856 0.06288281 NA ## Ten 0.028753994 0.033859177 0.02167804 0.035676810 0.07162978 0.07420925 ## Aka 0.012272950 0.003680982 0.02267865 0.014269406 0.01630202 0.04887543 ## Ako 0.019413093 0.016774685 0.01431412 0.009326425 0.03188521 0.04016064 ## Tam 0.009839461 0.041470714 0.02734200 0.018833536 0.06112360 0.03535811 ## Tot 0.023706897 0.039956012 0.03969466 0.007371007 0.13045141 0.03121387 ## Hot 0.012256267 0.009532456 0.00477327 0.047682119 0.01579703 0.00531401 ## Hen 0.012953368 0.007698888 0.02062780 0.003039514 0.03372302 0.03356009 ## Mal 0.016464891 0.010917913 0.01268499 0.044943820 0.02416278 0.02735043 ## Mik 0.038844150 0.030964669 0.02571547 0.016429354 0.04615385 0.02933780 ## Mei 0.013828868 0.020940485 0.01453711 0.004435683 0.03182515 0.04557744 ## Ten Aka Ako Tam Tot Hot ## Kil 0.02875399 0.012272950 0.019413093 0.009839461 0.023706897 0.012256267 ## Kit 0.03385918 0.003680982 0.016774685 0.041470714 0.039956012 0.009532456 ## Koh 0.02167804 0.022678648 0.014314115 0.027341999 0.039694656 0.004773270 ## Kun 0.03567681 0.014269406 0.009326425 0.018833536 0.007371007 0.047682119 ## Kor 0.07162978 0.016302016 0.031885213 0.061123596 0.130451415 0.015797032 ## Ntr 0.07420925 0.048875433 0.040160643 0.035358114 0.031213873 0.005314010 ## Ten NA 0.061754685 0.030087094 0.032560214 0.069555302 0.037511871 ## Aka 0.06175468 NA 0.074620573 0.064176245 0.018974566 0.016905738 ## Ako 0.03008709 0.074620573 NA 0.027802295 0.018455744 0.021126761 ## Tam 0.03256021 0.064176245 0.027802295 NA 0.072121468 0.007583965 ## Tot 0.06955530 0.018974566 0.018455744 0.072121468 NA 0.025055928 ## Hot 0.03751187 0.016905738 0.021126761 0.007583965 0.025055928 NA ## Hen 0.02052655 0.009103977 0.045474614 0.013629480 0.055274262 0.043902439 ## Mal 0.03577441 0.008550855 0.006250000 0.042533081 0.015968064 0.030808081 ## Mik 0.05284888 0.033068783 0.021668029 0.057354302 0.016464132 0.037018756 ## Mei 0.03047619 0.027114529 0.039637599 0.026215645 0.021060276 0.017945267 ## Hen Mal Mik Mei ## Kil 0.012953368 0.016464891 0.03884415 0.013828868 ## Kit 0.007698888 0.010917913 0.03096467 0.020940485 ## Koh 0.020627803 0.012684989 0.02571547 0.014537108 ## Kun 0.003039514 0.044943820 0.01642935 0.004435683 ## Kor 0.033723022 0.024162781 0.04615385 0.031825153 ## Ntr 0.033560091 0.027350427 0.02933780 0.045577443 ## Ten 0.020526551 0.035774411 0.05284888 0.030476190 ## Aka 0.009103977 0.008550855 0.03306878 0.027114529 ## Ako 0.045474614 0.006250000 0.02166803 0.039637599 ## Tam 0.013629480 0.042533081 0.05735430 0.026215645 ## Tot 0.055274262 0.015968064 0.01646413 0.021060276 ## Hot 0.043902439 0.030808081 0.03701876 0.017945267 ## Hen NA 0.030732861 0.03748265 0.029187817 ## Mal 0.030732861 NA 0.14634146 0.051620648 ## Mik 0.037482647 0.146341463 NA 0.030255403 ## Mei 0.029187817 0.051620648 0.03025540 NA 毛づくろいマトリクスからKurのデータを除く(近接マトリクスと合わせるため)。 groom_mat_b &lt;- groom_mat_b[-10,-10] CSIは以下のように求められる。 3つ以上の数値を用いる場合でも、リストに追加していくだけで容易に求まる。 ## 2つのマトリクスをリスト化 list &lt;- list(groom_mat_b, prox_mat) CSI &lt;- dyadic_csi(list) マトリクスは以下の通り。 rownames(CSI) &lt;- rownames(prox_mat) colnames(CSI) &lt;- colnames(prox_mat) CSI %&gt;% data.frame() ## Kil Kit Koh Kun Kor Ntr Ten ## Kil NA 13.1042381 1.5443971 0.98428757 0.6552021 0.60088982 0.7643802 ## Kit 13.1042381 NA 1.8809200 0.92663431 0.8915746 0.78716555 0.5420480 ## Koh 1.5443971 1.8809200 NA 1.23209198 1.2329225 0.61536768 0.3119031 ## Kun 0.9842876 0.9266343 1.2320920 NA 0.5179366 0.31860411 0.5133170 ## Kor 0.6552021 0.8915746 1.2329225 0.51793656 NA 4.64249260 2.6668403 ## Ntr 0.6008898 0.7871655 0.6153677 0.31860411 4.6424926 NA 3.7141526 ## Ten 0.7643802 0.5420480 0.3119031 0.51331698 2.6668403 3.71415256 NA ## Aka 0.1765829 0.5510337 0.3528585 0.23124757 0.4808443 1.25067658 2.5067746 ## Ako 0.2793151 0.4266683 0.3668997 0.13418835 1.4817507 0.97271675 1.1957603 ## Tam 0.1415699 0.6511851 1.4155272 0.54053793 0.8794447 0.50873159 0.4684755 ## Tot 1.1100956 2.5939561 1.6986391 0.28537814 1.8769314 0.44910436 1.0007598 ## Hot 0.1763428 0.1655378 0.2414133 0.71411246 0.2272873 0.07645783 0.5982682 ## Hen 0.2143964 0.6384085 0.5640990 0.04373245 0.4852059 0.79768327 0.3496319 ## Mal 0.2931029 0.3951573 0.9329951 0.64665047 0.5686548 0.39351721 1.0591778 ## Mik 0.5588886 1.2886155 0.9305812 0.23638510 0.8841411 0.55311373 0.7603883 ## Mei 0.1989694 0.5596737 0.2615050 1.49582258 0.4578994 0.65576702 0.4384906 ## Aka Ako Tam Tot Hot Hen Mal ## Kil 0.1765829 0.27931506 0.1415699 1.1100956 0.17634284 0.21439643 0.29310285 ## Kit 0.5510337 0.42666826 0.6511851 2.5939561 0.16553778 0.63840846 0.39515733 ## Koh 0.3528585 0.36689969 1.4155272 1.6986391 0.24141327 0.56409896 0.93299506 ## Kun 0.2312476 0.13418835 0.5405379 0.2853781 0.71411246 0.04373245 0.64665047 ## Kor 0.4808443 1.48175069 0.8794447 1.8769314 0.22728727 0.48520593 0.56865480 ## Ntr 1.2506766 0.97271675 0.5087316 0.4491044 0.07645783 0.79768327 0.39351721 ## Ten 2.5067746 1.19576030 0.4684755 1.0007598 0.59826817 0.34963190 1.05917776 ## Aka NA 1.90676455 0.9233661 0.2730055 0.88451956 1.45426091 0.30513215 ## Ako 1.9067645 NA 0.6435518 0.2655407 1.26192668 0.78528971 0.08992483 ## Tam 0.9233661 0.64355179 NA 1.6194770 4.55522245 0.19610059 0.61196482 ## Tot 0.2730055 0.26554075 1.6194770 NA 1.02074634 1.38464537 0.22974807 ## Hot 0.8845196 1.26192668 4.5552224 1.0207463 NA 1.36152269 0.94998635 ## Hen 1.4542609 0.78528971 0.1961006 1.3846454 1.36152269 NA 0.44218358 ## Mal 0.3051322 0.08992483 0.6119648 0.2297481 0.94998635 0.44218358 NA ## Mik 1.1495203 0.39025653 1.2560417 0.4927983 0.98113130 1.97349575 2.10555702 ## Mei 1.5086270 0.57030471 1.8553611 0.3281259 0.36802291 1.05940524 2.76861473 ## Mik Mei ## Kil 0.5588886 0.1989694 ## Kit 1.2886155 0.5596737 ## Koh 0.9305812 0.2615050 ## Kun 0.2363851 1.4958226 ## Kor 0.8841411 0.4578994 ## Ntr 0.5531137 0.6557670 ## Ten 0.7603883 0.4384906 ## Aka 1.1495203 1.5086270 ## Ako 0.3902565 0.5703047 ## Tam 1.2560417 1.8553611 ## Tot 0.4927983 0.3281259 ## Hot 0.9811313 0.3680229 ## Hen 1.9734957 1.0594052 ## Mal 2.1055570 2.7686147 ## Mik NA 0.6907648 ## Mei 0.6907648 NA References Silk, J. B., Altmann, J., &amp; Alberts, S. C. (2006). Social relationships among adult female baboons (papio cynocephalus) i. Variation in the strength of social bonds. Behav. Ecol. Sociobiol., 61(2), 183–195. "],["実行環境.html", "実行環境", " 実行環境 sessionInfo() ## R version 4.2.0 (2022-04-22 ucrt) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 10 x64 (build 19045) ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=Japanese_Japan.utf8 LC_CTYPE=Japanese_Japan.utf8 ## [3] LC_MONETARY=Japanese_Japan.utf8 LC_NUMERIC=C ## [5] LC_TIME=Japanese_Japan.utf8 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] data.table_1.14.2 hwig_0.0.2 assortnet_0.12 ## [4] clValid_0.7 cluster_2.1.3 ggsci_2.9 ## [7] concaveman_1.1.0 ggforce_0.3.3 ggdag_0.2.4 ## [10] dagitty_0.3-1 kableExtra_1.3.4 knitr_1.39 ## [13] DT_0.23 fontregisterer_0.3 systemfonts_1.0.4 ## [16] extrafont_0.18 patchwork_1.1.1 ggraph_2.0.5 ## [19] igraph_1.3.5 tidygraph_1.2.1 report_0.5.1 ## [22] see_0.7.2 correlation_0.8.2 modelbased_0.8.5 ## [25] effectsize_0.7.0.5 parameters_0.18.2 performance_0.9.2 ## [28] bayestestR_0.13.0 datawizard_0.5.1 insight_0.18.2 ## [31] easystats_0.5.2 aninet_0.0.0.9000 forcats_0.5.1 ## [34] stringr_1.4.0 dplyr_1.0.9 purrr_0.3.4 ## [37] readr_2.1.2 tidyr_1.2.0 tibble_3.1.7 ## [40] ggplot2_3.3.6 tidyverse_1.3.1 sna_2.6 ## [43] network_1.17.1 statnet.common_4.6.0 ANTs_0.0.1 ## [46] asnipe_1.1.16 ## ## loaded via a namespace (and not attached): ## [1] readxl_1.4.0 backports_1.4.1 splines_4.2.0 TH.data_1.1-1 ## [5] digest_0.6.29 htmltools_0.5.2 viridis_0.6.2 fansi_1.0.3 ## [9] magrittr_2.0.3 tzdb_0.3.0 graphlayouts_0.8.0 modelr_0.1.8 ## [13] Kendall_2.2.1 sandwich_3.0-1 extrafontdb_1.0 svglite_2.1.0 ## [17] colorspace_2.0-3 rvest_1.0.2 ggrepel_0.9.1 haven_2.5.0 ## [21] xfun_0.31 tcltk_4.2.0 crayon_1.5.1 jsonlite_1.8.0 ## [25] lme4_1.1-29 survival_3.3-1 zoo_1.8-10 glue_1.6.2 ## [29] polyclip_1.10-0 gtable_0.3.0 emmeans_1.7.4-1 webshot_0.5.3 ## [33] V8_4.2.0 Rttf2pt1_1.3.8 scales_1.2.0 mvtnorm_1.1-3 ## [37] DBI_1.1.2 Rcpp_1.0.8.3 viridisLite_0.4.0 xtable_1.8-4 ## [41] htmlwidgets_1.5.4 httr_1.4.3 ellipsis_0.3.2 pkgconfig_2.0.3 ## [45] farver_2.1.0 sass_0.4.1 dbplyr_2.1.1 utf8_1.2.2 ## [49] tidyselect_1.1.2 rlang_1.0.2 munsell_0.5.0 cellranger_1.1.0 ## [53] tools_4.2.0 visNetwork_2.1.0 cli_3.3.0 generics_0.1.2 ## [57] broom_0.8.0 evaluate_0.15 fastmap_1.1.0 yaml_2.3.5 ## [61] fs_1.5.2 nlme_3.1-157 xml2_1.3.3 compiler_4.2.0 ## [65] rstudioapi_0.13 curl_4.3.2 reprex_2.0.1 tweenr_1.0.2 ## [69] bslib_0.3.1 stringi_1.7.6 lattice_0.20-45 Matrix_1.4-1 ## [73] nloptr_2.0.1 vctrs_0.4.1 pillar_1.7.0 lifecycle_1.0.1 ## [77] jquerylib_0.1.4 estimability_1.3 R6_2.5.1 bookdown_0.29 ## [81] gridExtra_2.3 codetools_0.2-18 boot_1.3-28 MASS_7.3-56 ## [85] gtools_3.9.2 assertthat_0.2.1 withr_2.5.0 multcomp_1.4-19 ## [89] hms_1.1.1 grid_4.2.0 class_7.3-20 coda_0.19-4 ## [93] minqa_1.2.4 rmarkdown_2.14 lubridate_1.8.0 Balasubramaniam, K. N., Beisner, B. A., Berman, C. M., De Marco, A., Duboscq, J., Koirala, S., Majolo, B., Macintosh, A. J. J. J., McFarland, R., Molesti, S., Ogawa, H., Petit, O., Schino, G., Sosa, S., Sueur, C., Thierry, B., Waal, F. B. M. M. de, &amp; McCowan, B. (2018). The influence of phylogeny, social style, and sociodemographic factors on macaque social network structure. Am. J. Primatol., 80(1), e22727. Brock, G., Pihur, V., Datta, S., &amp; Datta, S. (2008). clValid: An R package for cluster validation. J. Stat. Softw., 25, 1–22. Butts, C. T. (2008). Social network analysis with sna. J. Stat. Softw., 24, 1–51. Campbell, L. A. D., Tkaczynski, P. J., Lehmann, J., Mouna, M., &amp; Majolo, B. (2018). Social thermoregulation as a potential mechanism linking sociality and fitness: Barbary macaques with more social partners form larger huddles. Sci. Rep., 8(1), 6074. Canteloup, C., Hoppitt, W., &amp; Waal, E. van de. (2020). Wild primates copy higher-ranked individuals in a social transmission experiment. Nat. Commun., 11(1), 459. Chang, W. (2018). R graphics cookbook: Practical recipes for visualizing data. “O’Reilly Media, Inc.” Cheney, D. L., Silk, J. B., &amp; Seyfarth, R. M. (2016). Network connections, dyadic bonds and fitness in wild female baboons. Royal Society Open Science, 3(7), 160255. Croft, D. P., Madden, J. R., Franks, D. W., &amp; James, R. (2011). Hypothesis testing in animal social networks. Trends in Ecology and Evolution, 26(10), 502–507. Croft, D., James, R., &amp; Krause, J. (2008). 動物の社会ネットワーク分析 (島田将喜., Trans.). 東海大学出版部. Csardi, G., Nepusz, T., &amp; Others. (2006). The igraph software package for complex network research. InterJournal, Complex Systems, 1695(5), 1–9. Dekker, D., Krackhardt, D., &amp; Snijders, T. A. B. (2007). Sensitivity of MRQAP tests to collinearity and autocorrelation conditions. Psychometrika, 72(4), 563–581. Duboscq, J., Romano, V., Sueur, C., &amp; Macintosh, A. J. J. (2016). Network centrality and seasonality interact to predict lice load in a social primate. Sci. Rep., 6(FEBRUARY), 22095. Farine, D. R. (2014). Measuring phenotypic assortment in animal social networks: Weighted associations are more robust than binary edges. Anim. Behav., 89, 141–153. Farine, D. R. (2013). Animal social network inference and permutations for ecologists inRusingasnipe. Methods Ecol. Evol., 4(12), 1187–1194. Farine, D. R. (2017). A guide to null models for animal social network analysis. Methods Ecol. Evol., 8(10), 1309–1320. Farine, D. R., &amp; Carter, G. G. (2022). Permutation tests for hypothesis testing with animal social network data: Problems and potential solutions. Methods Ecol. Evol., 13(1), 144–156. Farine, D. R., &amp; Whitehead, H. (2015). Constructing, conducting and interpreting animal social network analysis. J. Anim. Ecol., 84(5), 1144–1163. Franks, D. W., Weiss, M. N., Silk, M. J., Perryman, R. J. Y., &amp; Croft, D. P. (2021). Calculating effect sizes in animal social network analysis. Methods Ecol. Evol., 12(1), 33–41. Gilby, I. C., Brent, L. J. N., Wroblewski, E. E., Rudicell, R. S., Hahn, B. H., Goodall, J., &amp; Pusey, A. E. (2013). Fitness benefits of coalitionary aggression in male chimpanzees. Behav. Ecol. Sociobiol., 67(3), 373–381. Godde, S., Humbert, L., Côté, S. D., Réale, D., &amp; Whitehead, H. (2013). Correcting for the impact of gregariousness in social network analyses. Anim. Behav., 85(3), 553–558. Hobaiter, C., Poisot, T., Zuberbühler, K., Hoppitt, W., &amp; Gruber, T. (2014). Social network analysis shows direct evidence for social transmission of tool use in wild chimpanzees. PLoS Biol., 12(9), e1001960. Hoppitt, W. J. E., &amp; Farine, D. R. (2018). Association indices for quantifying social relationships: How to deal with missing observations of individuals or groups. Anim. Behav., 136, 227–238. Kawazoe, T., &amp; Sosa, S. (2019). Social networks predict immigration success in wild japanese macaques. Primates, 60(3), 213–222. Krause, J., James, R., Franks, D. W., &amp; Croft, D. P. (2015). Animal social networks. Oxford University Press. Lehmann, J., Majolo, B., &amp; McFarland, R. (2016). The effects of social network position on the survival of wild barbary macaques, macaca sylvanus. Behav. Ecol., 27(1), 20–28. MacIntosh, A. J. J., Jacobs, A., Garcia, C., Shimizu, K., Mouri, K., Huffman, M. A., &amp; Hernandez, A. D. (2012). Monkeys in the middle: Parasite transmission through the social network of a wild primate. PLoS One, 7(12), 15–21. Newman, M. E. J. (2004). Analysis of weighted networks. Phys. Rev. E Stat. Nonlin. Soft Matter Phys., 70(5 Pt 2), 056131. Page, L., Brin, S., Motwani, R., &amp; Winograd, T. (1999). The PageRank citation ranking: Bringing order to the web. Stanford InfoLab. Puga-Gonzalez, I., Sosa, S., &amp; Sueur, C. (2019). Editorial: Social networks analyses in primates, a multilevel perspective. Primates, 60, 163–165. Shimada, M., &amp; Sueur, C. (2018). Social play among juvenile wild japanese macaques (macaca fuscata) strengthens their social bonds. Am. J. Primatol., 80(1). Silk, J. B., Altmann, J., &amp; Alberts, S. C. (2006). Social relationships among adult female baboons (papio cynocephalus) i. Variation in the strength of social bonds. Behav. Ecol. Sociobiol., 61(2), 183–195. Sosa, S., Puga-Gonzalez, I., Hu, F., Pansanel, J., Xie, X., &amp; Sueur, C. (2020). A multilevel statistical toolkit to study animal social networks: The animal network toolkit software (ANTs) R package. Sci. Rep., 10(1), 12507. Sueur, C., Jacobs, A., Amblard, F., Petit, O., &amp; King, A. J. (2011). How can social network analysis improve the study of primate behavior? American Journal of Primatology, 73(8), 703–719. Sueur, C., Petit, O., De Marco, A., Jacobs, A. T., Watanabe, K., &amp; Thierry, B. (2011). A comparative network analysis of social style in macaques. Anim. Behav., 82(4), 845–852. Whitehead, H. (2008). Analyzing animal societies. The University of Chicago Press. Wickham, H., &amp; Grolemund, G. (2016). R for data science: Import, tidy, transform, visualize, and model data. “O’Reilly Media, Inc.” 松村優哉., 湯谷啓明., 紀ノ定保礼., &amp; 前田和. (2021). RユーザのためのRstudio[実践]入門 tidyverseによるモダンな分析フローの世界 改訂2版. 技術評論社. 鈴木努. (2017). R で学ぶデータサイエンス 8 ネットワーク分析 第2版 (金明哲., Ed.). 共立出版. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
