[["index.html", "Network Analysis Using R 本稿の目的", " Network Analysis Using R Tsubasa Yamaguchi 2023-10-23 本稿の目的 本稿は社会ネットワーク分析（SNA: Social Network Analysis）の概要をまとめたものである。また、Rでこうした分析を実行する方法についても解説している。新たに個人的に勉強した内容があれば、随時追加していく。 近年、動物行動学や霊長類ではSNAの手法を用いた研究が増加しており(Sueur, Jacobs, et al., 2011)、Primates誌でも2019年に特集号が組まれた(Puga-Gonzalez et al., 2019)。図0.1は、動物行動学や霊長類学の分野で著名な学術雑誌において、“social network analysis”という単語を含む論文の割合がどのように変化してきたかを、Google scholarを用いて調べた結果を示したものである(2023年1月22日時点)。私たちが普段読むことが多いこれらの雑誌においても、2000年代後半以降社会ネットワーク分析を用いた論文が増加していることが示唆される。 こうした論文を適切に理解するためにも、SNAについてある程度理解することは必要だろう。また、自身のデータを解析する手法を増やすことで、従来の分析方法だけでは言えなかったことを説得力のある形で示せるようになるかもしれない。 図0.1: socail network analysisという単語を含む論文の割合 本稿で扱うのは、以下の内容である。 社会ネットワーク分析の概要(第1章) rawデータからマトリックス(隣接行列)を作成する方法(第2章) 各ネットワーク指標の解説と算出法(第3章) ネットワークデータでの統計分析（第4章) 参考にしたのは主に以下の文献である。 なお、本稿の作成に使用したファイルとRのコードは筆者のGithubですべて閲覧できる。 鈴木努(2017) ネットワーク分析 第2版 (鈴木, 2017) Whitehead(2008) Analyzing Animal Societies (Whitehead, 2008) Croft et al. (2008) Exploring Animal Social Network (D. Croft et al., 2008) Borgatti et al.(2022) Analyzing Social Networks Using R. (Borgatti et al., 2022) Farine &amp; Whitehead (2015) Constructing, conducting and interpreting animal social network analysis (Farine &amp; Whitehead, 2015) Farine (2017) A guide to null models for animal social network analysis (Farine, 2017) Sosa et al. (2020) A multilevel statistical toolkit to study animal social networks: the Animal Network Toolkit Software (ANTs) R package. (Sosa et al., 2020) Network Analysis in R (Dai Shizukaのホームページ) References Borgatti, S. P., Everett, M. G., Johnson, J. C., &amp; Agneessens, F. (2022). Analyzing social networks using R. SAGE. Croft, D., James, R., &amp; Krause, J. (2008). 動物の社会ネットワーク分析 (島田将喜., Trans.). 東海大学出版部. Farine, D. R. (2017). A guide to null models for animal social network analysis. Methods Ecol. Evol., 8(10), 1309–1320. Farine, D. R., &amp; Whitehead, H. (2015). Constructing, conducting and interpreting animal social network analysis. J. Anim. Ecol., 84(5), 1144–1163. Puga-Gonzalez, I., Sosa, S., &amp; Sueur, C. (2019). Editorial: Social networks analyses in primates, a multilevel perspective. Primates, 60, 163–165. Sosa, S., Puga-Gonzalez, I., Hu, F., Pansanel, J., Xie, X., &amp; Sueur, C. (2020). A multilevel statistical toolkit to study animal social networks: The animal network toolkit software (ANTs) R package. Sci. Rep., 10(1), 12507. Sueur, C., Jacobs, A., Amblard, F., Petit, O., &amp; King, A. J. (2011). How can social network analysis improve the study of primate behavior? American Journal of Primatology, 73(8), 703–719. Whitehead, H. (2008). Analyzing animal societies. The University of Chicago Press. 鈴木努. (2017). R で学ぶデータサイエンス 8 ネットワーク分析 第2版 (金明哲., Ed.). 共立出版. "],["Chapter0.html", "0. パッケージの読み込み", " 0. パッケージの読み込み 本稿では、基本的にネットワークデータのハンドリングにはtidygraphパッケージを用いる。このパッケージを使うことで、データフレームとしてネットワークデータを扱うことができるので非常に便利である。ネットワークグラフの描画にはggraphパッケージを用いる。このパッケージでは、基本的にggplot2と同じ文法でネットワークグラフを描くことができる。 各指標の算出や統計分析には、主にasnipeパッケージ、ANTsパッケージ、igraphパッケージ、snaパッケージを用いる。 tidygraph ggraph asnipe(Farine, 2013) ANTS(Sosa et al., 2020) igraph(Csardi et al., 2006) sna(Butts, 2008) ## ネットワーク分析関連 library(tidygraph) library(ggraph) library(asnipe) library(sna) library(ANTs) library(igraph) library(clValid) library(assortnet) library(hwig) ## データハンドリング library(tidyverse) library(easystats) library(data.table) ## グラフや表関連 library(patchwork) library(DT) library(knitr) library(kableExtra) library(dagitty) library(ggdag) library(ggforce) library(concaveman) library(ggsci) library(lemon) ## フォント関連 library(extrafont) require(systemfonts) require(fontregisterer) なお、本稿はRの基本操作とtidyverseパッケージによるデータハンドリングができることを前提としている。tidyverseパッケージを用いたデータ処理については、以下の書籍などを参照。 R for Data Science (Wickham &amp; Grolemund, 2016) 電子書籍, 日本語 R Graphics Coocbook 2nd Edition (Chang, 2018) 電子書籍, 日本語 RユーザのためのRstudio[実践]入門~tidyverseによるモダンな分析フローの世界 改訂2版 (松村 et al., 2021) 出版社サイト References Butts, C. T. (2008). Social network analysis with sna. J. Stat. Softw., 24, 1–51. Chang, W. (2018). R graphics cookbook: Practical recipes for visualizing data. “O’Reilly Media, Inc.” Csardi, G., Nepusz, T., &amp; Others. (2006). The igraph software package for complex network research. InterJournal, Complex Systems, 1695(5), 1–9. Farine, D. R. (2013). Animal social network inference and permutations for ecologists inRusingasnipe. Methods Ecol. Evol., 4(12), 1187–1194. Sosa, S., Puga-Gonzalez, I., Hu, F., Pansanel, J., Xie, X., &amp; Sueur, C. (2020). A multilevel statistical toolkit to study animal social networks: The animal network toolkit software (ANTs) R package. Sci. Rep., 10(1), 12507. Wickham, H., &amp; Grolemund, G. (2016). R for data science: Import, tidy, transform, visualize, and model data. “O’Reilly Media, Inc.” 松村優哉., 湯谷啓明., 紀ノ定保礼., &amp; 前田和. (2021). RユーザのためのRstudio[実践]入門 tidyverseによるモダンな分析フローの世界 改訂2版. 技術評論社. "],["Chapter1-1.html", "1 社会ネットワーク分析の概説 1.1 社会ネットワーク分析(SNA)とは", " 1 社会ネットワーク分析の概説 1.1 社会ネットワーク分析(SNA)とは 社会ネットワークとは，相互に社会的なつながりをもつ個体の集まりのことを指す(Krause et al., 2015)。多くの生物において、集団を構成する個体たちはランダム・均一に他個体と関わりあっているわけではなく、その関係の強度やタイプ、ダイナミクスは非常に多様である。社会ネットワークは、このような多様な関係によって構成されている(D. Croft et al., 2008)。 霊長類のように多くの個体が集団生活を行う種においては、個体の行動は一対一の社会関係だけではなく、集団全体の関係構造(e.g., 誰と誰がどのような関係を持つか)に強く影響を受ける(D. Croft et al., 2008; Krause et al., 2015)。例えば、個体\\(A\\)が個体\\(B\\)に対してどのような行動をとるのかには、個体\\(A\\)と\\(B\\)がそれぞれ誰とどのようなな関係を持つかや、その関係の強度が大きく影響するだろう。また社会ネットワークの構造は、こうした個体の行動の集積を通じて、集団の土地利用パターンや疾病・情報の伝播、離合集散パターンなど集団レベルの現象に対しても影響を与える。以上のように、集団で生活する種を対象に研究を行う際には、その背後にある社会ネットワークについて理解することで、一対一の関係のみに着目するよりもはるかに多くのことを理解できる(Krause et al., 2015; Sueur, Jacobs, et al., 2011)。 社会ネットワーク分析（SNA: Social Network Analysis）とは、集団内の2個体間の社会関係に基づいて社会ネットワークを描写することで、その社会関係の構造や構成個体の特性を調べる分析手法のことである(D. Croft et al., 2008; Krause et al., 2015)。SNAの手法を用いることで、社会ネットワークの構造が個体の行動や集団レベルの現象に与える影響を検討することが可能になる。 近年、動物行動学や霊長類でもSNAの手法を用いた研究が増加している(Puga-Gonzalez et al., 2019; Sueur, Jacobs, et al., 2011)。 例えば、SNAを用いた霊長類の研究には以下のようなものがある。 オス間の親和的交渉のネットワークが移籍の成否や繁殖成功に与える影響を調べた研究(Gilby et al., 2013; Kawazoe &amp; Sosa, 2019) メス間の親和的交渉のネットワークがメスの適応度に与える影響を調べた研究(Cheney et al., 2016; Lehmann et al., 2016) 毛づくろいネットワークが寄生虫への感染に与える影響を調べた研究(Duboscq et al., 2016; MacIntosh et al., 2012) 社会ネットワークが行動の社会的伝達に与える影響を検討した研究(Canteloup et al., 2020; Hobaiter et al., 2014) 異なる行動指標のネットワーク間の関連を調べた研究(Campbell et al., 2018; Shimada &amp; Sueur, 2018) 種間のネットワークを比較した研究(Balasubramaniam et al., 2018; Sueur, Petit, et al., 2011) References Balasubramaniam, K. N., Beisner, B. A., Berman, C. M., De Marco, A., Duboscq, J., Koirala, S., Majolo, B., Macintosh, A. J. J. J., McFarland, R., Molesti, S., Ogawa, H., Petit, O., Schino, G., Sosa, S., Sueur, C., Thierry, B., Waal, F. B. M. M. de, &amp; McCowan, B. (2018). The influence of phylogeny, social style, and sociodemographic factors on macaque social network structure. Am. J. Primatol., 80(1), e22727. Campbell, L. A. D., Tkaczynski, P. J., Lehmann, J., Mouna, M., &amp; Majolo, B. (2018). Social thermoregulation as a potential mechanism linking sociality and fitness: Barbary macaques with more social partners form larger huddles. Sci. Rep., 8(1), 6074. Canteloup, C., Hoppitt, W., &amp; Waal, E. van de. (2020). Wild primates copy higher-ranked individuals in a social transmission experiment. Nat. Commun., 11(1), 459. Cheney, D. L., Silk, J. B., &amp; Seyfarth, R. M. (2016). Network connections, dyadic bonds and fitness in wild female baboons. Royal Society Open Science, 3(7), 160255. Croft, D., James, R., &amp; Krause, J. (2008). 動物の社会ネットワーク分析 (島田将喜., Trans.). 東海大学出版部. Duboscq, J., Romano, V., Sueur, C., &amp; Macintosh, A. J. J. (2016). Network centrality and seasonality interact to predict lice load in a social primate. Sci. Rep., 6(FEBRUARY), 22095. Gilby, I. C., Brent, L. J. N., Wroblewski, E. E., Rudicell, R. S., Hahn, B. H., Goodall, J., &amp; Pusey, A. E. (2013). Fitness benefits of coalitionary aggression in male chimpanzees. Behav. Ecol. Sociobiol., 67(3), 373–381. Hobaiter, C., Poisot, T., Zuberbühler, K., Hoppitt, W., &amp; Gruber, T. (2014). Social network analysis shows direct evidence for social transmission of tool use in wild chimpanzees. PLoS Biol., 12(9), e1001960. Kawazoe, T., &amp; Sosa, S. (2019). Social networks predict immigration success in wild japanese macaques. Primates, 60(3), 213–222. Krause, J., James, R., Franks, D. W., &amp; Croft, D. P. (2015). Animal social networks. Oxford University Press. Lehmann, J., Majolo, B., &amp; McFarland, R. (2016). The effects of social network position on the survival of wild barbary macaques, macaca sylvanus. Behav. Ecol., 27(1), 20–28. MacIntosh, A. J. J., Jacobs, A., Garcia, C., Shimizu, K., Mouri, K., Huffman, M. A., &amp; Hernandez, A. D. (2012). Monkeys in the middle: Parasite transmission through the social network of a wild primate. PLoS One, 7(12), 15–21. Puga-Gonzalez, I., Sosa, S., &amp; Sueur, C. (2019). Editorial: Social networks analyses in primates, a multilevel perspective. Primates, 60, 163–165. Shimada, M., &amp; Sueur, C. (2018). Social play among juvenile wild japanese macaques (macaca fuscata) strengthens their social bonds. Am. J. Primatol., 80(1). Sueur, C., Jacobs, A., Amblard, F., Petit, O., &amp; King, A. J. (2011). How can social network analysis improve the study of primate behavior? American Journal of Primatology, 73(8), 703–719. Sueur, C., Petit, O., De Marco, A., Jacobs, A. T., Watanabe, K., &amp; Thierry, B. (2011). A comparative network analysis of social style in macaques. Anim. Behav., 82(4), 845–852. "],["Chapter1-2.html", "1.2 社会ネットワークの基礎", " 1.2 社会ネットワークの基礎 1.2.1 グラフ SNAでは、ネットワークの構造を頂点(ノード)と辺(エッジ)の集合によって表す。これを、グラフと呼ぶ。頂点は個体などを、辺は何らかの個体間の社会関係を表す。 関係の有無(1か0か)だけを考慮するグラフと、関係の強さ(交渉頻度など)も考慮するグラフがある。後者は特に重み付きグラフといい、関係の強さを「重み(weight)」という。グラフでは、エッジの太さで関係の強さを表す(図1.1)。 関係の向きを考える(\\(A \\rightarrow B\\)と\\(A \\leftarrow B\\)を区別)グラフを有向グラフ、考えないグラフを無向グラフという。有向グラフの場合は、辺に矢印を用いることが多い(図1.1のB)。 図1.1: 例1. 無向グラフ(A)と有向グラフ(B)の例 1.2.2 隣接行列(マトリックス) ネットワーク分析では、データを隣接行列(adjacency matrix)の形で表現することが多い。隣接行列はグラフのノード間の関係が記された行列で、ノードの数が\\(n\\)個ならば、\\(n \\times n\\)の正方行列になる。Rの分析でも、基本的に隣接行列を用いることが多い。 Rでは、matrix()関数によって以下のように作成できる。 mat_example &lt;- matrix(## 数値のベクトル c(0,0,0,2, 1.5,0,2,0, 3,0,0,1, 0,1,3,0), ## 行数と列数 ncol = 4, nrow = 4, ## TRUEなら、1行目から順に数値を入れていく byrow = TRUE) ## 列名と行名を入れられる colnames(mat_example) &lt;- c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;) rownames(mat_example) &lt;- c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;) ## 完成したのがこちら mat_example %&gt;% kable(digits = 2, align = &quot;c&quot;,caption = &quot;作成した隣接行列&quot;) %&gt;% kable_styling(font_size = 10, full_width = FALSE) 表1.1: 作成した隣接行列 A B C D A 0.0 0 0 2 B 1.5 0 2 0 C 3.0 0 0 1 D 0.0 1 3 0 Excel等で作成したcsvファイルをデータフレームとして読み込み、それをマトリックスに変換する方法もある。 ## 1列目を行名に指定 mat_example2 &lt;- read.csv(&quot;data/example.csv&quot;, row.names = 1) ## マトリックスに変換 mat_example2 &lt;- as.matrix(mat_example2) mat_example2 %&gt;% kable(digits = 2, align = &quot;c&quot;) %&gt;% kable_styling(font_size = 10, full_width = FALSE) A B C D E F G H A 0.00 0.55 0.15 0.93 0.86 0.29 0.63 0.24 B 0.41 0.00 0.86 0.95 0.20 0.99 0.36 0.59 C 0.09 0.41 0.00 0.87 0.63 0.85 0.29 0.80 D 0.83 0.68 0.07 0.00 0.60 0.54 0.14 0.42 E 0.80 0.82 0.34 0.68 0.00 0.70 0.41 0.43 F 0.80 0.05 0.78 0.17 0.95 0.00 0.04 0.37 G 0.75 0.42 0.90 0.95 0.51 0.16 0.00 0.05 H 0.87 0.16 0.02 0.05 0.31 0.85 0.13 0.00 1.2.3 Rでのグラフの描画 本稿ではggraphパッケージを用いる。このパッケージを用いる利点は主に以下の2点である。 tidygraphと併用することで、データフレーム形式のデータをそのままグラフにできる。それによって、データの加工とグラフの描画をシームレスに行いやすい。 ggplotパッケージの拡張なので、ggplotと同じ文法で描ける。 1.2.3.1 tbl_graphクラスへの変換 ggraphでグラフを描くには、データをtbl_graphクラスに変換する必要がある。隣接行列をas_tbl_graph()で変換してあげればよい。すると、ノードの名前nameと辺リスト(辺の始点、終点、重みが書いてあるリスト)が入ったオブジェクトを返してくれる。 ## 有向グラフであれば directed = TRUE、無向グラフならFALSE graph_mat_example2 &lt;- as_tbl_graph(mat_example2, directed = TRUE) graph_mat_example2 ## # A tbl_graph: 8 nodes and 56 edges ## # ## # A directed simple graph with 1 component ## # ## # Node Data: 8 × 1 (active) ## name ## &lt;chr&gt; ## 1 A ## 2 B ## 3 C ## 4 D ## 5 E ## 6 F ## # … with 2 more rows ## # ## # Edge Data: 56 × 3 ## from to weight ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 2 0.552 ## 2 1 3 0.153 ## 3 1 4 0.930 ## # … with 53 more rows なお、各ノードの名前以外の情報もグラフに反映させたい場合は、以下のように情報を追加できる。ここでは、各個体の年齢の情報を追加した。 graph_mat_example2 %&gt;% mutate(age = c(12,10,15,6,20,13,8,7)) -&gt; graph_mat_example2 graph_mat_example2 ## # A tbl_graph: 8 nodes and 56 edges ## # ## # A directed simple graph with 1 component ## # ## # Node Data: 8 × 2 (active) ## name age ## &lt;chr&gt; &lt;dbl&gt; ## 1 A 12 ## 2 B 10 ## 3 C 15 ## 4 D 6 ## 5 E 20 ## 6 F 13 ## # … with 2 more rows ## # ## # Edge Data: 56 × 3 ## from to weight ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 2 0.552 ## 2 1 3 0.153 ## 3 1 4 0.930 ## # … with 53 more rows グラフに使用するデータを絞り込むなどの作業をする場合は、一度隣接行列を辺リストのデータフレームに変換してから(mat.to.edgl()で可能)データフレームを加工し、その後にas_tbl_graph()を用いるとよい。以下では、重みが0.7以上の辺のみを抽出している。 mat_example2 %&gt;% ## 辺リストのデータフレームに変換 mat.to.edgl() %&gt;% ## weightが0.5以上のものに限定する filter(weight &gt;= 0.5) %&gt;% ## tbl_graphクラスに変換 as_tbl_graph(directed = TRUE) %&gt;% mutate(age = c(12,10,15,6,20,13,8,7)) -&gt; graph_mat_example2_b graph_mat_example2 ## # A tbl_graph: 8 nodes and 56 edges ## # ## # A directed simple graph with 1 component ## # ## # Node Data: 8 × 2 (active) ## name age ## &lt;chr&gt; &lt;dbl&gt; ## 1 A 12 ## 2 B 10 ## 3 C 15 ## 4 D 6 ## 5 E 20 ## 6 F 13 ## # … with 2 more rows ## # ## # Edge Data: 56 × 3 ## from to weight ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 2 0.552 ## 2 1 3 0.153 ## 3 1 4 0.930 ## # … with 53 more rows 1.2.3.2 ggraphを用いた描画 ggraphでグラフを描画するときには、主に以下の3つを指定してあげればよい。 レイアウト: グラフでノードと辺をどのような規則に基づいて配置するかを決める。 例. line: 一直線、circle: 円上、nicely: いい感じに?、randomly: ランダムに、… 詳細はこちらやこちらを参照。 ノード: geom_node_*()(*には色々入る)という関数群でノードについて指定。関数の中でsize =で大きさ、color =で色、shape =で形などをggplotと同じように指定できる。 例. geom_node_point(): 普通のノード、geom_node_text(): ノードのラベル、… 辺(エッジ): geom_edge_*()(*には色々入る)という関数群でノードについて指定。関数の中でwidth =で太さ、color =で色などをggplotと同じように指定できる。 例: geom_edge_link(): 直線、geom_edge_fan(): 曲線、… 図1.2は実際に以下のコードで描いた例である。 layout = \"nicely\"とすると、グラフが見やすいように配置してくれる。関係のある(= 辺がある)個体同士はより近くに配置される傾向があるため、絶対とはいえないが、結果的に多くの個体と繋がっている個体が中心部に来る傾向がある。 何らかの指標を出さない限りグラフのみから何かを結論付けることはできないが、パッと見て関係構造の全体図を掴んだり、仮説を立てたりしようとする際にはグラフを見ることが非常に有用である。 graph_mat_example2_b %&gt;% # layoutの指定 ggraph(layout = &quot;nicely&quot;)+ # 曲線のエッジ、weightを太さに geom_edge_fan(aes(width = weight), ## 矢印について指定 arrow = arrow(angle = 15, type = &quot;closed&quot;,length = unit(0.18, &quot;inches&quot;)), ## 矢印の終点のノードからの距離 end_cap = circle(2.5,&quot;mm&quot;), ## 矢印の始点のノードからの距離 start_cap = circle(2.5,&quot;mm&quot;), ## 透明度(alpha)と色(color)指定 alpha =0.7, color = &quot;grey60&quot;)+ # エッジの太さの範囲を決める scale_edge_width(range = c(0,1.3))+ ## 四角のノード。大きさは年齢によって変化するとする。 geom_node_point(aes(size = age), shape = 18)+ ## ノードのラベルは個体名 scale_size(range = c(3,6))+ geom_node_text(aes(label = name), ## ノードと重ならないようにする repel=TRUE, size =6)+ theme_graph()+ ## 縦横比 theme(aspect.ratio = 0.7) 図1.2: ggraphで描いたグラフの例 "],["Chapter2-1.html", "2 データの読み込みとマトリックスの作成 2.1 2個体間の交渉を記録したデータフレーム", " 2 データの読み込みとマトリックスの作成 R上でSNAを行うためには、個体間の関係データを隣接行列にしなければならないことが多い。しかし多くの場合、個体間のassociationの生データは隣接行列の形では表されていない。例えば個体追跡のデータでは、以下(表2.1)のように1分ごとに毛づくろい相手のIDを記録したものをまずExcelファイルなどに記入する、というようなことが多いだろう。ここでは、R上でこのような生データから隣接行列を作成する方法を学ぶ。 表2.1: 生データの例 min groomer groomee 1 A B 2 A B 3 A C 4 B A 5 B A 2.1 2個体間の交渉を記録したデータフレーム ここでは、2個体間の交渉(例えば、毛づくろいなど)を記録したデータフレームから隣接行列を作る。 例えば、以下は金華山島\\(B_1\\)群で2018年時点で6歳以上のメスを個体追跡した際のデータであり、1分間の瞬間サンプリングで以下を記録したデータフレームである。 no_focal: 個体追跡セッション番号 subject: 追跡個体名 time: 個体追跡開始からの経過時間 activity: 個体の活動(G: 毛づくろい、R: 休息、F: 採食、M: 移動、O: その他) TG: 樹上(T)にいたか地上(G)にいたか groomer: activityが毛づくろいだったときのgroomer geoomee: activityが毛づくろいだったときのgroomer groom &lt;- read_csv(&quot;data/focal_demo.csv&quot;) groom %&gt;% head(50) %&gt;% datatable(rownames = FALSE) 追跡したメスのIDは以下のとおりである。 adult &lt;- c(&quot;Kil&quot;,&quot;Kit&quot;,&quot;Koh&quot;,&quot;Kur&quot;,&quot;Kun&quot;,&quot;Kor&quot;,&quot;Ntr&quot;, &quot;Ten&quot;,&quot;Aka&quot;,&quot;Ako&quot;,&quot;Tam&quot;,&quot;Tot&quot;,&quot;Hen&quot;,&quot;Hot&quot;, &quot;Mal&quot;,&quot;Mik&quot;,&quot;Mei&quot;) このデータをもとに、個体追跡中にメス間が毛づくろいをした頻度を示したマトリックスを作成する。 ここで、頻度は以下の式で表すものとする。 \\(G_{AB}\\): \\(A\\)から\\(B\\)への毛づくろい頻度 \\(x_{AB}\\): \\(A\\)から\\(B\\)への毛づくろいが確認された瞬間サンプリングポイント数 \\(y_A\\): \\(A\\)の個体追跡時間(瞬間サンプリングポイント総数) \\(y_B\\): \\(B\\)の個体追跡時間(瞬間サンプリングポイント総数) \\[ G_{AB} = \\frac{x_{AB}}{y_{A} + y_{B}} \\] 分母となる各個体の個体追跡時間(\\(y_A, y_B, ...\\))を算出する。 groom %&gt;% group_by(subject) %&gt;% summarise(duration = n()) -&gt; duration duration %&gt;% datatable(rownames = FALSE) 追跡個体がのactivityが毛づくろいで、かつ地上にいたポイントのみを抽出する。 また、毛づくろい相手が大人だったのみを抽出。 groom_G &lt;- groom %&gt;% ## 地上かつ毛づくろいのみ抽出 filter(activity == &quot;G&quot;) %&gt;% filter(Groomer %in% adult &amp; Groomee %in% adult) 毛づくろい頻度はANTsパッケージのdf.to.mat()関数で以下のように求められる。 groom_mat &lt;- df.to.mat(groom_G, ## 行動の行い手を表す列 actor = &quot;Groomer&quot;, ## 行動の受け手を表す列 receiver = &quot;Groomee&quot;, ## 追跡時間 tobs = duration$duration, ## 交渉の方向を考慮するか。FALSEでする。 sym = FALSE) 隣接行列は以下のようになる(表2.2)。 表2.2: 方向性を考慮した毛づくろい頻度の隣接行列 Aka Ako Hen Hot Kil Kit Koh Kor Kun Kur Mal Mei Mik Ntr Tam Ten Tot Aka 0.00 0.04 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 Ako 0.07 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.01 0.00 Hen 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.01 0.00 0.00 0.00 0.00 0.00 Hot 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 Kil 0.00 0.00 0.00 0.00 0.00 0.01 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 Kit 0.00 0.00 0.00 0.00 0.02 0.00 0.01 0.00 0.00 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 Koh 0.00 0.00 0.00 0.00 0.01 0.01 0.00 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 Kor 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.01 0.02 0.00 0.00 0.00 0.01 0.00 0.00 0.00 Kun 0.00 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.00 Kur 0.00 0.00 0.00 0.00 0.01 0.01 0.00 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 Mal 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.02 0.00 0.00 0.00 0.01 Mei 0.01 0.01 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 Mik 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.03 0.00 0.00 0.00 0.00 0.00 0.00 Ntr 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.01 0.00 0.00 0.01 0.00 0.00 0.01 0.00 Tam 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 Ten 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.01 0.00 0.00 0.00 Tot 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.01 0.00 0.00 0.01 0.00 0.00 0.00 0.01 0.00 0.00 もし交渉の方向性を考慮しない場合は、sym = TRUEとすればよい。 groom_mat_b &lt;- df.to.mat(groom_G, ## 行動の行い手を表す列 actor = &quot;Groomer&quot;, ## 行動の受け手を表す列 receiver = &quot;Groomee&quot;, ## 追跡時間 tobs = duration$duration, sym = TRUE) その場合の隣接行列は以下の通り(表2.3)。 表2.3: 方向性を考慮しない毛づくろい頻度の隣接行列 Aka Ako Hen Hot Kil Kit Koh Kor Kun Kur Mal Mei Mik Ntr Tam Ten Tot Aka 0.00 0.11 0.00 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.00 0.00 Ako 0.11 0.00 0.01 0.00 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.02 0.00 0.01 0.00 0.01 0.00 Hen 0.00 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.01 0.00 0.00 0.01 0.01 0.00 Hot 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 Kil 0.00 0.00 0.00 0.00 0.00 0.04 0.02 0.00 0.01 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 Kit 0.00 0.00 0.00 0.00 0.04 0.00 0.03 0.01 0.00 0.02 0.00 0.00 0.00 0.00 0.00 0.00 0.00 Koh 0.00 0.00 0.00 0.00 0.02 0.03 0.00 0.02 0.01 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.00 Kor 0.00 0.01 0.00 0.00 0.00 0.01 0.02 0.00 0.01 0.02 0.00 0.00 0.01 0.01 0.00 0.01 0.01 Kun 0.00 0.00 0.00 0.00 0.01 0.00 0.01 0.01 0.00 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.00 Kur 0.00 0.00 0.00 0.00 0.01 0.02 0.00 0.02 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.01 0.00 Mal 0.00 0.00 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.04 0.00 0.00 0.00 0.01 Mei 0.01 0.02 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.01 0.01 0.00 0.00 0.00 Mik 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.01 0.00 0.04 0.01 0.00 0.01 0.01 0.00 0.00 Ntr 0.00 0.01 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.01 0.00 0.01 0.01 0.00 0.00 0.01 0.01 Tam 0.00 0.00 0.01 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.02 Ten 0.00 0.01 0.01 0.00 0.00 0.00 0.00 0.01 0.00 0.01 0.00 0.00 0.00 0.01 0.00 0.00 0.00 Tot 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.01 0.00 0.00 0.01 0.00 0.00 0.01 0.02 0.00 0.00 グラフを描画すると図2.1のようになる。ノードの大きさは順位を、辺の太さは毛づくろい頻度を表す。血縁個体同士(同じアルファベットで始まる個体)は交渉頻度が高く、近くに配置されていることが分かる。順位の低い個体がネットワークの周辺にいることが多いことも分かるだろう。 ## 順位 rank &lt;- c(9,10,13,14,1,2,3,6,5,4,15,17,16,7,11,8,12) groom_mat_b %&gt;% as_tbl_graph(directed = FALSE) %&gt;% ## 順位の情報を入れる mutate(rank = rank) %&gt;% ggraph(layout = &quot;nicely&quot;)+ # 曲線のエッジ、weightを太さに geom_edge_fan(aes(width = weight), ## 透明度(alpha)と色(color)指定 alpha =0.7, color = &quot;grey60&quot;)+ # エッジの太さの範囲を決める scale_edge_width(range = c(0.3,3))+ ## 四角のノード。大きさは年齢によって変化するとする。 geom_node_point(aes(size = -rank), shape = 18)+ ## ノードのラベルは個体名 scale_size(range = c(1,5))+ geom_node_text(aes(label = name), ## ノードと重ならないようにする repel=TRUE, size =6)+ theme_graph()+ ## 縦横比 theme(aspect.ratio = 0.7)+ labs(width = &quot;毛づくろい頻度&quot;) 図2.1: 毛づくろい頻度ネットワークのグラフ "],["Chapter2-2.html", "2.2 Group by individual", " 2.2 Group by individual 個体間のassociationを表したデータとしては、以下のようにある時点・場所において確認された個体を各行に0/1で記録した”group by individual”と呼ばれる形式のものがよく用いられる。 例えば、以下は金華山島\\(B_1\\)群で2021年交尾期の各観察日(date)に9歳以上のメスが観察されたか否かを示したものである。 presence &lt;- read_csv(&quot;data/presence_demo.csv&quot;) presence %&gt;% datatable(rownames = FALSE) このようなデータでは、同じグループで観察された個体をassociateしていたとみなすことが多い(=gambit of the group)(Farine &amp; Whitehead, 2015)。Group by individualの形式のデータでは、以下のような指標で個体間の強さを表すことが多い。なお、各指標の詳細については Hoppitt &amp; Farine (2018) を参照。 \\(x\\): 個体\\(a\\)と\\(b\\)が一緒に観察された回数 \\(y_a\\): \\(a\\)だけが確認された回数 \\(y_b\\): \\(b\\)だけが確認された回数 \\(y_{ab}\\): \\(a\\)と\\(b\\)が共に観察されたが、associateはしてない回数(今回の例では存在しない) SRI: simple ratio index \\(= x/(y_a + y_b + y_{ab} + x)\\) ▶ 単純に一緒に観察された割合。観察ミス(個体がいたにもかかわらずいなかったと記録してしまうこと)が少ない場合にはこちらで問題ない。 HWI: half-weight index \\(= x/(\\frac{1}{2}(y_a + y_b) + y_{ab} + x)\\) ▶ 観察ミスが多いと考えられる場合、補正を行う。 HWIG (Godde et al., 2013) \\(= HWI_{ab} \\times \\frac{\\sum_i \\sum_j HWI_{ij}}{\\sum_i HWI_{ai} \\times \\sum_i HWI_{bi}}\\) ▶ それぞれの個体のgregariousnessを考慮したHWI。互いのgregariousnessを考慮したとき、ランダムにassociateしているのであれば1になり、１よりおおきければランダムの場合よりもよくassociateしていることになる。 asnipeパッケージのget_network()関数では、“group by individual”形式のデータからSRIとHWIを算出し、マトリックスを作成することが可能である。 presence_mat &lt;- get_network(presence %&gt;% ## 日付の列は除く dplyr::select(-date), ## gambit of the group data_format = &quot;GBI&quot;, ## &quot;HWI&quot;の場合は、&quot;HWI&quot; association_index = &quot;SRI&quot;) ## Generating 15 x 15 matrix 得られた隣接行列は以下の通り(表2.4)。 表2.4: SRIの隣接行列 Mik Kil Koh Aka Ntr Ten Tot Hen Hot Mei Ako Kor Mal Kit Kun Mik 0.00 0.43 0.45 0.63 0.41 0.46 0.41 0.39 0.32 0.43 0.45 0.43 0.32 0.42 0.42 Kil 0.43 0.00 0.98 0.45 0.93 0.95 0.95 0.94 0.80 0.98 0.80 0.98 0.88 0.95 0.95 Koh 0.45 0.98 0.00 0.45 0.95 0.95 0.95 0.94 0.78 0.98 0.80 0.98 0.86 0.95 0.95 Aka 0.63 0.45 0.45 0.00 0.44 0.46 0.42 0.42 0.39 0.43 0.53 0.43 0.35 0.43 0.41 Ntr 0.41 0.93 0.95 0.44 0.00 0.90 0.90 0.89 0.76 0.93 0.77 0.93 0.86 0.93 0.93 Ten 0.46 0.95 0.95 0.46 0.90 0.00 0.93 0.89 0.76 0.95 0.77 0.95 0.83 0.93 0.93 Tot 0.41 0.95 0.95 0.42 0.90 0.93 0.00 0.89 0.78 0.95 0.77 0.95 0.86 0.95 0.95 Hen 0.39 0.94 0.94 0.42 0.89 0.89 0.89 0.00 0.81 0.92 0.76 0.92 0.91 0.92 0.92 Hot 0.32 0.80 0.78 0.39 0.76 0.76 0.78 0.81 0.00 0.78 0.65 0.78 0.79 0.78 0.78 Mei 0.43 0.98 0.98 0.43 0.93 0.95 0.95 0.92 0.78 0.00 0.78 0.98 0.86 0.95 0.95 Ako 0.45 0.80 0.80 0.53 0.77 0.77 0.77 0.76 0.65 0.78 0.00 0.78 0.70 0.78 0.78 Kor 0.43 0.98 0.98 0.43 0.93 0.95 0.95 0.92 0.78 0.98 0.78 0.00 0.88 0.95 0.95 Mal 0.32 0.88 0.86 0.35 0.86 0.83 0.86 0.91 0.79 0.86 0.70 0.88 0.00 0.88 0.88 Kit 0.42 0.95 0.95 0.43 0.93 0.93 0.95 0.92 0.78 0.95 0.78 0.95 0.88 0.00 0.98 Kun 0.42 0.95 0.95 0.41 0.93 0.93 0.95 0.92 0.78 0.95 0.78 0.95 0.88 0.98 0.00 HWIGはhwigパッケージのcalc_hwig()関数で算出することができる。 ## まずHWIを算出 presence_mat_HWI &lt;- get_network(presence %&gt;% dplyr::select(-date), data_format = &quot;GBI&quot;, association_index = &quot;HWI&quot;) ## Generating 15 x 15 matrix ## HWIGの算出 presence_mat_HWIG &lt;- presence_mat_HWI %&gt;% ## data.table形式に直す必要 as.data.table() %&gt;% calc_hwig() %&gt;% as.matrix() rownames(presence_mat_HWIG) &lt;- rownames(presence_mat_HWI) 得られた隣接行列は以下の通り(表2.5)。 表2.5: HWIGの隣接行列 Mik Kil Koh Aka Ntr Ten Tot Hen Hot Mei Ako Kor Mal Kit Kun Mik 0.00 0.51 0.52 0.96 0.50 0.54 0.49 0.48 0.45 0.51 0.57 0.51 0.43 0.50 0.50 Kil 0.51 0.00 0.54 0.50 0.54 0.54 0.54 0.54 0.54 0.55 0.53 0.55 0.55 0.54 0.54 Koh 0.52 0.54 0.00 0.50 0.55 0.54 0.54 0.54 0.53 0.55 0.53 0.55 0.54 0.54 0.54 Aka 0.96 0.50 0.50 0.00 0.51 0.52 0.49 0.49 0.50 0.49 0.62 0.49 0.45 0.49 0.48 Ntr 0.50 0.54 0.55 0.51 0.00 0.54 0.54 0.54 0.54 0.54 0.53 0.54 0.55 0.54 0.55 Ten 0.54 0.54 0.54 0.52 0.54 0.00 0.54 0.54 0.53 0.55 0.53 0.54 0.54 0.54 0.54 Tot 0.49 0.54 0.54 0.49 0.54 0.54 0.00 0.54 0.54 0.55 0.53 0.55 0.54 0.55 0.55 Hen 0.48 0.54 0.54 0.49 0.54 0.54 0.54 0.00 0.56 0.54 0.53 0.54 0.57 0.54 0.54 Hot 0.45 0.54 0.53 0.50 0.54 0.53 0.54 0.56 0.00 0.54 0.52 0.54 0.57 0.54 0.54 Mei 0.51 0.55 0.55 0.49 0.54 0.55 0.55 0.54 0.54 0.00 0.53 0.55 0.54 0.54 0.54 Ako 0.57 0.53 0.53 0.62 0.53 0.53 0.53 0.53 0.52 0.53 0.00 0.53 0.52 0.53 0.53 Kor 0.51 0.55 0.55 0.49 0.54 0.54 0.55 0.54 0.54 0.55 0.53 0.00 0.55 0.54 0.54 Mal 0.43 0.55 0.54 0.45 0.55 0.54 0.54 0.57 0.57 0.54 0.52 0.55 0.00 0.55 0.55 Kit 0.50 0.54 0.54 0.49 0.54 0.54 0.55 0.54 0.54 0.54 0.53 0.54 0.55 0.00 0.55 Kun 0.50 0.54 0.54 0.48 0.55 0.54 0.55 0.54 0.54 0.54 0.53 0.54 0.55 0.55 0.00 得られたSRIの隣接行列についてグラフを描画すると図2.2のようになる。ノードの大きさは年齢、色は順位を、辺の太さはHWIGを表す。MikとAkaは他の個体と一緒にいることが少ないことが分かるだろう(年齢も影響しそう？)。順位の高い個体はネットワークの中心にいることが多そう? age &lt;- c(18,17,15,15,13,13,13,13,13,13,12,11,11,10,9) rank2 &lt;- c(16,1,3,9,7,8,12,13,14,17,10,6,15,2,5) set.seed(129) presence_mat %&gt;% as_tbl_graph(directed = FALSE) %&gt;% ggraph(layout = &quot;nicely&quot;)+ # 曲線のエッジ、weightを太さに geom_edge_link(aes(width = weight), ## 透明度(alpha)と色(color)指定 alpha =0.7, color = &quot;grey67&quot;)+ # エッジの太さの範囲を決める scale_edge_width(range = c(0,1.5))+ ## 四角のノード。大きさは年齢によって変化するとする。 geom_node_point(aes(size = age, color = rank2),shape = 16)+ ## ノードのラベルは個体名 scale_size(range = c(2,5))+ geom_node_text(aes(label = name), ## ノードと重ならないようにする repel=TRUE, size =6)+ theme_graph()+ ## 縦横比 theme(aspect.ratio = 0.7) 図2.2: SRIネットワークのグラフ References Farine, D. R., &amp; Whitehead, H. (2015). Constructing, conducting and interpreting animal social network analysis. J. Anim. Ecol., 84(5), 1144–1163. Godde, S., Humbert, L., Côté, S. D., Réale, D., &amp; Whitehead, H. (2013). Correcting for the impact of gregariousness in social network analyses. Anim. Behav., 85(3), 553–558. Hoppitt, W. J. E., &amp; Farine, D. R. (2018). Association indices for quantifying social relationships: How to deal with missing observations of individuals or groups. Anim. Behav., 136, 227–238. "],["Chapter3-0.html", "3 ネットワーク指標の算出", " 3 ネットワーク指標の算出 本章では、ネットワークの構造や構成個体の特徴を表すための指標について概説し、それらをRで算出する方法を学ぶ。指標を算出することで定量的な分析が可能になり、グラフを見るだけでは定性的にしか言えなかったことを示すことができるようになる。 本稿では主にANTsパッケージ、またはsnaパッケージで指標の算出を行う。各指標についての説明は 鈴木 (2017) や Sosa et al. (2020) 、 Farine &amp; Whitehead (2015) 、 Sosa et al. (2021) なども参照。 References Farine, D. R., &amp; Whitehead, H. (2015). Constructing, conducting and interpreting animal social network analysis. J. Anim. Ecol., 84(5), 1144–1163. Sosa, S., Puga-Gonzalez, I., Hu, F., Pansanel, J., Xie, X., &amp; Sueur, C. (2020). A multilevel statistical toolkit to study animal social networks: The animal network toolkit software (ANTs) R package. Sci. Rep., 10(1), 12507. Sosa, S., Sueur, C., &amp; Puga-Gonzalez, I. (2021). Network measures in animal social network analysis: Their strengths, limits, interpretations and uses. Methods Ecol. Evol., 12(1), 10–21. 鈴木努. (2017). R で学ぶデータサイエンス 8 ネットワーク分析 第2版 (金明哲., Ed.). 共立出版. "],["Chapter3-1.html", "3.1 ノードについての諸指標(中心性指標)", " 3.1 ノードについての諸指標(中心性指標) ここでは、各ノードのネットワーク内での特性を表す指標についてまとめる。中心性指標は、いずれもあるノードがそのグラフでどのくらい「中心的」であるかを表す指標である。以下で見るように、中心性を評価する方法は数多く提案されている。 基本的には、いずれもANTsパッケージのmet.*()関数で出力できる(*には中心性指標の名前)。これらの関数は、各ノードについて算出した中心性を各ノードの属性データ(例えば年齢や順位など)を記したデータフレームに追加していってくれるので、分析を行う際に非常に便利である。 属性データの例(年齢と順位) attr &lt;- data.frame(name = c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;), age = c(12,13,12,11,14,15,18,9), rank = c(2,3,4,1,8,1,7,6)) attr %&gt;% datatable(rownames = FALSE, width = &quot;55%&quot;) 3.1.1 近接中心性(closeness centrality) グラフの「中心」のイメージとしてよく思い浮かぶのは、「他のノードとの距離が小さいノードほどより中心的である」というものである。近接中心性は他のノードとの最短距離の合計が小さいほど大きくなる中心性指標で、以下のように定式化され、0から1の値をとる。 \\[ C_c(i) = \\frac{n-1}{\\sum_{j=1}^n d_{ij}} \\] なお\\(n\\)はノード数で、\\(d_{ij}\\)はノード\\(i\\)から\\(j\\)に最短で到達するために通る辺の数(= 最短距離)である。例えば、以下のグラフ(図3.1)において、AからHへの最短距離は2、GからHへの最短距離は4である。分子に\\(n-1\\)があるのは、最大値が1になるようにするためである。 図3.1: 近接中心性算出のための無向グラフの例 例として図3.1のグラフの各ノードの近接中心性を求める。Rでは基本的に隣接行列の形でデータを扱うことが多い。今回も中心性指標の算出のため、図3.1の隣接行列を以下のように作成する。 mat_undir &lt;- matrix(c(0,1,1,1,1,1,0,0, 1,0,1,0,0,0,1,0, 1,1,0,0,0,0,0,0, 1,0,0,0,1,0,0,1, 1,0,0,1,0,1,0,0, 1,0,0,0,1,0,0,0, 0,1,0,0,0,0,0,0, 0,0,0,1,0,0,0,0), nrow = 8, ncol = 8) colnames(mat_undir) &lt;- c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;) rownames(mat_undir) &lt;- c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;) 近接中心性はsnaパッケージのcloseness()関数で求められる。ノードAの中心性の値が最も高いことが分かる。 sna::closeness(mat_undir, ## 有向グラフなら &quot;digraph&quot; gmode = &quot;graph&quot;, ## 重み付きグラフなら FALSE ignore.eval = TRUE) ## [1] 0.7777778 0.5833333 0.5384615 0.5833333 0.5833333 0.5000000 0.3888889 ## [8] 0.3888889 3.1.2 次数中心性(Degree centrality) 最も簡便で適用範囲の広い中心性が次数中心性である(鈴木, 2017)。重みなしグラフについて算出でき、各ノードに辺で接続しているノードの数を、そのノードの次数中心性とする。例えば、図3.1では、Aの次数中心性は5、Dの次数中心性は3である。 例として、図3.1の次数中心性を求める。ANTsパッケージでは、met.degree()関数で求められる。以下のようにdf =に属性が入ったデータフレームを指定することで、算出した次数中心性をそのデータフレームに追加してくれる。 met.degree(mat_undir, ## 属性データフレーム df = attr, ## 個体IDの列番号 dfid = 1) %&gt;% kable(align = &quot;c&quot;) %&gt;% kable_styling(font_size = 12, full_width = FALSE) name age rank degree A 12 2 5 B 13 3 3 C 12 4 2 D 11 1 3 E 14 8 3 F 15 1 2 G 18 7 1 H 9 6 1 有向グラフでは、他のノードから入ってくる辺の数である入次数(indegree)と他のノードへ入っていく辺の数である出次数(outdegree)が区別される。図3.2では、Aの入次数は2、出次数は3である。 図3.2: 次数中心性算出のための有向グラフの例 ANTsパッケージでは、それぞれmet.indegree()とmet.outdegree()で求められる。 ## このようにすれば、2つの中心性指標を共に属性データに結合できる。 met.indegree( ## 隣接行列 mat_dir, ## 属性データフレーム df = attr, ## 個体IDの列番号 dfid = 1) -&gt; attr_b met.outdegree(mat_dir, ## 属性データフレーム(入次数の情報も含む) df = attr_b, ## 個体IDの列番号 dfid = 1) %&gt;% kable(align = &quot;c&quot;) %&gt;% kable_styling(font_size = 12, full_width = FALSE) name age rank indegree outdegree A 12 2 2 3 B 13 3 3 1 C 12 4 1 2 D 11 1 1 2 E 14 8 1 0 F 15 1 2 1 G 18 7 1 3 H 9 6 1 0 3.1.3 重み付き中心性(Strength centrality) 重み付き中心性は、各ノードに接続している辺の重みの合計で表される中心性である。図3.3は表3.1の隣接行列(mat_undir_b)のグラフである。グラフの辺上の数字は重みを表す。このとき、Aの重み付き中心性は\\(3 + 2+ 2+ 1 +1=9\\)、Cの重み付き中心性は\\(3 + 2 = 5\\)である。 表3.1: 隣接行列(mat_undir_b) A B C D E F G H A 0 2 3 1 2 1 0 0 B 2 0 2 0 0 0 1 0 C 3 2 0 0 0 0 0 0 D 1 0 0 0 3 0 0 1 E 2 0 0 3 0 2 0 0 F 1 0 0 0 2 0 0 0 G 0 1 0 0 0 0 0 0 H 0 0 0 1 0 0 0 0 図3.3: 重み付き中心性算出のための無向グラフの例 ANTsパッケージでは、met.strength()で求められる。まお、ANTsパッケージでは常に有向グラフとして計算されてしまうようなので、1/2してあげる必要がある。 met.strength(mat_undir_b/2, ## 属性データフレーム df = attr, ## 個体IDの列番号 dfid = 1) %&gt;% kable(align = &quot;c&quot;) %&gt;% kable_styling(font_size = 12, full_width = FALSE) name age rank strength A 12 2 9 B 13 3 5 C 12 4 5 D 11 1 5 E 14 8 7 F 15 1 3 G 18 7 1 H 9 6 1 なお、有向データについては次数中心性と同じようにinstrengthとoutstrengthで区別することもできる。その場合は、それぞれANTsパッケージのmet.indegree()とmet.outstrength()で算出できる。 おまけ snaパッケージでは、次数中心性と重み付き中心性を全てdegree()関数で求められる。 sna::degree(mat_undir_b, ## 重みなしの場合 TRUE ignore.eval = FALSE, ## 有向グラフの場合は &quot;digraph&quot;, gmode = &quot;graph&quot;, ## indegreeの場合は &quot;indegree&quot;、outdegreeの場合は&quot;outdegree&quot;, cmode = &quot;freeman&quot;) ## [1] 9 5 5 5 7 3 1 1 3.1.4 固有ベクトル中心性(Eigenvector centrality) 次数中心性や重み付け中心性は、あるノードに接続する辺の数や重みの合計に基づく中心性指標であった。つまり、例えば毛づくろい頻度ネットワークでは、多くの個体と毛づくろいしている個体や、毛づくろい頻度の合計が多い個体の中心性が高く評価される。しかし、この方法は中心性を評価する指標として適切ではない場合がある。例えば、毛づくろいを通してある行動がネットワーク内をどのように伝播するかを考えるとき、毛づくろい相手の多い個体と毛づくろいすることは、毛づくろい相手の少ない個体と毛づくろいするよりも高く評価するべきかもしれない。 このことを考慮するためは、あるノードの中心性を評価するときに、そのノードと繋がっているノードの中心性の大きさを反映させる必要がある。例えば、あるノードの中心性がそれとつながるノードの中心性の和に比例する方法が考えられる。このとき、ある無向グラフの隣接行列を\\(A = (a_{ij})\\)とし、そこに含まれるノードの中心性を成分とする列ベクトルを\\(c=c_i\\)とすると、ノード\\(i\\)の中心性\\(c_i\\)は次のように表現できる。ただし、\\(\\lambda\\)は正の比例定数である。 \\[ \\begin{aligned} c_i &amp;= \\frac{1}{\\lambda} \\sum_{j=1}^{n} a_{ij}c_j \\end{aligned} \\] 行列とベクトルで表すと、以下のように書ける。 \\[ \\begin{aligned} c &amp;= \\frac{1}{\\lambda} Ac\\\\ \\therefore \\lambda c &amp;= Ac \\end{aligned} \\] 例えば、4個体について以下の隣接行列\\(A\\)と中心性を成分とするベクトル\\(c\\)を考える。 \\[ \\begin{aligned} &amp;A = (a_{ij}) = \\begin{pmatrix} 0 &amp; 1 &amp; 0 &amp; 0\\\\ 1 &amp; 0 &amp; 1 &amp; 1\\\\ 0 &amp; 1 &amp; 0 &amp; 1\\\\ 0 &amp; 1 &amp; 1 &amp; 0\\\\ \\end{pmatrix}\\\\ \\\\ &amp;c = \\begin{pmatrix} c_1\\\\ c_2\\\\ c_3\\\\ c_4 \\end{pmatrix} \\end{aligned} \\] このとき、以下のような式を満たす\\(c\\)と\\(\\lambda\\)を求めることになる。 \\[ \\begin{aligned} \\lambda \\begin{pmatrix}c_1\\\\ c_2\\\\ c_3\\\\ c_4 \\end{pmatrix} &amp;= \\begin{pmatrix} 0 &amp; 1 &amp; 0 &amp; 0\\\\ 1 &amp; 0 &amp; 1 &amp; 1\\\\ 0 &amp; 1 &amp; 0 &amp; 1\\\\ 0 &amp; 1 &amp; 1 &amp; 0 \\end{pmatrix} \\begin{pmatrix} c_1\\\\ c_2\\\\ c_3\\\\ c_4\\\\ \\end{pmatrix}\\\\ \\\\ \\therefore \\lambda \\begin{pmatrix} c_1\\\\ c_2\\\\ c_3\\\\ c_4\\\\ \\end{pmatrix} &amp;= \\begin{pmatrix} c_2\\\\ c_1 +c_3+ c_4\\\\ c_2+c_4\\\\ c_2+c_3\\\\ \\end{pmatrix} \\end{aligned} \\] ここで、これを満たす\\(\\lambda\\)は正方行列\\(A\\)の固有値、\\(c\\)は固有ベクトルになる1。つまり、隣接行列の固有ベクトルを求めれば、隣接するノードの中心性を反映した中心性を求めることができる(なお、固有値と固有ベクトルの組み合わせは\\(A\\)の列数と同じだけある)。特に絶対値が最大となる固有値に対応する第1固有ベクトルを中心性指標としたものを、固有ベクトル中心性(eigenvector centrality)という。 あるノードの固有ベクトル中心性は、そのノードにつながるノードの中心性を反映しているが、それらのノードは更にそれらにつながるノードの中心性を反映している。このように、固有ベクトル中心性は、そのノードから辺をたどって到達できるすべてのノードの中心性を反映している。 先ほどの例の\\(A\\)の第1固有ベクトルは以下のように求められる。固有ベクトルは負の値をとることもあるため、絶対値をとることが多い。また、最大値を1とした比で表すことも多い。 A = matrix(c(0,1,0,0, 1,0,1,1, 0,1,0,1, 0,1,1,0), nrow = 4, byrow = TRUE) ## 第1固有ベクトル。絶対値をとる。 evc &lt;- abs(eigen(A)$vectors[,1]) ## 最大値を1とするようにする evc/max(evc) ## [1] 0.4608111 1.0000000 0.8546377 0.8546377 ANTsパッケージではmet.eigen()関数で、snaパッケージではevcent()関数で固有ベクトル中心性を求められる。前者は最大が1になるように変形しているのに対し、後者はそのような変形はしていない(定数倍しただけなので、分析上はどちらでも構わない)。 ## ANTs met.eigen(A) ## [1] 0.4608111 1.0000000 0.8546377 0.8546377 ## sna sna::evcent(A) ## [1] 0.2818452 0.6116285 0.5227207 0.5227207 以上は重みなしグラフについて算出を行ったが、重み付きグラフについても同様に算出できる。 隣接行列mat_undir_b(表3.1)ついて、それぞれ重み付き中心性(左)と固有ベクトル中心性(右)の値をノードの大きさに反映させたグラフが図3.4である。 set.seed(123) ## 重み付き中心性の算出 met.strength(mat_undir_b/2, df = attr, dfid = 1) -&gt; attr_st ## 固有ベクトル中心性の算出 met.eigen(mat_undir_b, df = attr_st, dfid = 1) -&gt; attr_st_evc ## 重み付き中心性のグラフ mat_undir_b %&gt;% as_tbl_graph(directed = FALSE) %&gt;% ## `tbl_graph`に重み付き中心性の情報を追加 mutate(strength = attr_st_evc$strength) %&gt;% ggraph(layout = &quot;nicely&quot;)+ geom_node_point(aes(size = strength), shape = 16, color = &quot;black&quot;)+ scale_size(range = c(6,13))+ geom_edge_link(aes(width = weight),color = &quot;grey65&quot;, end_cap = circle(0.5,&quot;cm&quot;), start_cap = circle(0.5,&quot;cm&quot;))+ geom_node_text(aes(label = name), color = &quot;white&quot;)+ scale_edge_width(range = c(1,3))+ labs(title = &quot;重み付き中心性&quot;)+ theme_graph() -&gt; p_strength ## 固有ベクトル中心性のグラフ mat_undir_b %&gt;% as_tbl_graph(directed = FALSE) %&gt;% ## `tbl_graph`に固有ベクトル中心性の情報を追加 mutate(eigen = attr_st_evc$eigen) %&gt;% ggraph(layout = &quot;nicely&quot;)+ geom_node_point(aes(size = eigen), shape = 16, color = &quot;black&quot;)+ scale_size(range = c(6,13))+ geom_edge_link(aes(width = weight),color = &quot;grey65&quot;, end_cap = circle(0.5,&quot;cm&quot;), start_cap = circle(0.5,&quot;cm&quot;))+ geom_node_text(aes(label = name), color = &quot;white&quot;)+ scale_edge_width(range = c(1,3))+ labs(title = &quot;固有ベクトル中心性&quot;)+ theme_graph() -&gt; p_eigen p_strength + p_eigen 図3.4: 重み付き中心性(左)と固有ベクトル中心性(右)の値をノードの大きさに反映させたグラフ 固有ベクトル中心性は、有向グラフにも適用できるよう。各個体のinstrengthとoutstrengthに着目することで、それぞれineigenとouteigenが算出できる。それぞれの説明についてはこちらのサイトを参照。 一般的に、以下のようになるよう。 ineigen: 他の個体からよく毛づくろいされる個体からよく毛づくろいされるとき、ineigenが大きくなる。 outeigen: 他の個体をよく毛づくろいする個体にたくさん毛づくろいするとき、outeigenが大きくなる。 例えば、第2章で算出した表2.2の隣接行列(groom_mat)のineigenとouteigenは、ANTsパッケージを用いて以下のように求められる。 ## 属性テーブル df &lt;- data.frame(femaleID = colnames(groom_mat)) ## ineigen met.eigen(groom_mat, df = df, dfid = 1, ## 重みなしの場合はFALSE binary = FALSE, ## 無効グラフの場合はTRUE sym = FALSE, ## outeigenの場合はTRUE out = FALSE ) -&gt; df ## outeigen met.eigen(groom_mat, df = df, dfid = 1, ## 重みなしの場合はFALSE binary = FALSE, ## 無効グラフの場合はTRUE sym = FALSE, ## ineigenの場合はFALSE out = TRUE ) -&gt; df それぞれineigen(左)とouteigen(右)の値をノードの大きさに反映させたグラフが図3.5である。 図3.5: ineigen(左)とouteigen(右)の値をノードの大きさに反映させたグラフ 3.1.5 PageRank 固有ベクトル中心性は、分離したグラフや有向グラフの中心性分析には使いにくい。PageRankは固有ベクトルに基づきながら、これらのグラフにも適用できる中心性指標である。もともとはウェブページの評価法として、Google創業者であるラリー・ペイジとセルゲイ・ブリンらによって開発され(Page et al., 1999)、他ページからのリンクが多いページほどランキングが高く、ランキングの高いページからのリンクや、他のページへのリンクが少ないページからのリンクを高く評価するというアルゴリズムに従う。詳細な算出方法は複雑なので、ここでは説明しない。詳しくは 鈴木 (2017) を参照。 PageRankはigraphパッケージを用いて算出できる。表3.2の隣接行列(mat_dir_b)のPageRankを算出する。 表3.2: 隣接行列(mat_dir_b) A B C D E F G H A 0 2 0 1 0 1 0 0 B 0 0 2 0 0 0 1 0 C 3 2 0 0 0 0 0 0 D 1 0 0 0 0 0 0 0 E 2 0 0 3 0 0 0 0 F 0 0 0 0 2 0 0 2 G 0 1 0 0 0 1 0 0 H 0 0 0 1 0 0 0 0 igraphパッケージでデータを扱う際には、まず隣接行列をigraphクラスにしなくてはならない。graph_from_adjacency_matrix()関数でigraphクラスに変換した後、page.rank()関数でPageRankを算出する。 mat_dir %&gt;% ## 隣接行列をgraphに変換 graph_from_adjacency_matrix(weighted = NULL, mode = &quot;directed&quot;) %&gt;% ## PageRankの算出 page.rank(directed = TRUE) -&gt; page_rank page_rank$vector ## A B C D E F G ## 0.12584798 0.18619542 0.14217932 0.07093242 0.06542177 0.12576921 0.19354160 ## H ## 0.09011228 PageRankの値をノードの大きさに反映したグラフが図3.6である。 set.seed(123) mat_dir_b %&gt;% as_tbl_graph(directed = TRUE) %&gt;% ## `tbl_graph`にPageRankの情報を追加 mutate(PageRank = page_rank$vector) %&gt;% ggraph(layout = &quot;nicely&quot;)+ geom_node_point(aes(size = PageRank),shape = 16, color = &quot;black&quot;)+ scale_size(range = c(6,13))+ geom_edge_fan(aes(width = weight), color = &quot;grey65&quot;, arrow = arrow(angle = 30, length = unit(4,units = &quot;mm&quot;), type = &quot;closed&quot;), end_cap = circle(0.5,&quot;cm&quot;), start_cap = circle(0.5,&quot;cm&quot;))+ geom_node_text(aes(label = name), color = &quot;white&quot;)+ scale_edge_width(range = c(0,2))+ labs(title = &quot;PageRank&quot;)+ theme_graph()+ scale_x_continuous(expand = c(0.05,0.05))+ scale_y_continuous(expand = c(0.05,0.05))-&gt; p_pr p_pr 図3.6: PageRankの値をノードの大きさに反映させたグラフ 3.1.6 媒介中心性(Betweeness centrality) ネットワークにおける媒介や伝達に着目した中心性に媒介中心性がある。媒介中心性は、他のノード同士をつなぐ最短経路上に位置するノードは、ノード間の仲介や情報の伝達に与える影響が大きいという点で有力であり、より多くのノード間の最短経路上にあるノードほどその影響力が大きいとする指標である。 ノード\\(i\\)の媒介中心性は以下の式で定式化される。なお、\\(g_{jk}\\)はノード\\(j\\)と\\(k\\)の間の最短経路数であり、\\(g_{ij}(i)\\)はノード\\(j\\)と\\(k\\)の間の最短経路のうちノード\\(i\\)を通るものの数である。無向グラフの場合、\\(j &lt; k\\)である。 \\[ C_b(i) = \\sum_{i \\neq j \\neq k} \\frac {g_{jk}(i)}{g_{jk}} \\] ANTsパッケージではmet.betweeness()関数で、snaパッケージではsna::betweeness()関数で媒介中心性を求められる。表3.2の隣接行列(mat_dir_b)について算出すると、以下のようになる。 ## ANTs met.betweenness(mat_dir_b, ## 重みなしならTRUE binary = FALSE, ## 無向グラフならTRUE sym = FALSE, ## 最も重みの合計が高い経路を最短とする shortest.weight = TRUE, df = attr, dfid = 1) %&gt;% kable(align = &quot;c&quot;) %&gt;% kable_styling(font_size = 12, full_width = FALSE) name age rank norm.short.outbetweenness A 12 2 22.0 B 13 3 13.5 C 12 4 1.0 D 11 1 8.5 E 14 8 2.5 F 15 1 15.0 G 18 7 5.5 H 9 6 5.5 ## sna sna::betweenness(mat_dir_b, ## 無向グラフなら&quot;undirected&quot; cmode = &quot;directed&quot;, ## 重みなしならTRUE ignore.eval = FALSE) ## [1] 22.0 13.5 1.0 8.5 2.5 15.0 5.5 5.5 媒介中心性の値をノードの大きさに反映したグラフが図3.7である。 図3.7: 媒介中心性の値をノードの大きさに反映させたグラフ 3.1.7 情報中心性(Information centrality) 媒介中心性は最短経路以外の経路や、経路の長さを考慮していなかった。しかし、実際の情報の伝達は最短経路のみでなされるとは限らないし、情報伝達に関わる人が多いほど情報の精度が下がるような可能性もある。そこで、ノード間の最短経路以外の経路や経路の長さを考慮した指標として、情報中心性が考案された。 情報中心性の算出では、経路が短いほど高く評価されるように経路の長さの逆数で重みづけされる。例えば、図3.8のノード\\(2\\)と\\(4\\)について考える。これらのノードの間の経路には\\(2-1-4\\)と\\(2-3-1-4\\)の2通りがあり、それぞれの長さは2と3である。ただし、2つの経路には\\(1-4\\)という共通の経路が存在する。 図3.8: 情報中心性算出のための無向グラフの例 このとき、ノード\\(2\\)と\\(4\\)について以下の行列\\(D_{24}\\)を考える。なお、行列の対角成分にはそれぞれの経路の長さが、それ以外の成分には2つの経路で共通する辺の数が入る。 \\(D_{24} = \\begin{pmatrix} 2 &amp; 1 \\\\1 &amp; 3\\end{pmatrix}\\) そして、この行列の逆行列2\\(D_{24}^{-1}\\)の各行の成分の合計を、各経路の情報量とする。この場合、\\(0.6-0.2 = 0.4\\)が経路\\(2-1-4\\)の、\\(-0.2 + 0.4 = 0.2\\)が経路\\(2-3-1-4\\)の情報量である。また、その和(\\(0.4+0.2=0.6\\))をノード\\(2\\)と\\(4\\)のペアについての情報量(\\(I_{24}\\))とする。このように全てのノードペアについての情報量を算出する(自身との情報量は\\(I_{ii} = \\infty\\)である)。 \\(D_{24}^{-1} = \\begin{pmatrix} 0.6 &amp; -0.2 \\\\ -0.2 &amp; 0.4 \\end{pmatrix}\\) このとき、各ノード\\(i\\)の情報中心性(\\(C_{inf}(i)\\))は、ノード\\(i\\)が含まれるノードペアの情報量の調和平均3になる。数式では以下のように書ける。ただし、\\(n\\)は全ノードの数である。 \\(C_{inf}(i) = \\frac{n}{\\sum_{j=1}^n 1/I_{ij}}\\) 情報中心性はsnaパッケージのinfocent()関数で求められる。表3.2の隣接行列(mat_dir_b)について算出すると、以下のようになる。 infocent(mat_dir_b, ##無向グラフなら &quot;graph&quot; gmode = &quot;digraph&quot;) ## [1] 1.881874 1.408537 1.157895 1.439252 1.483146 1.714286 1.200000 1.168142 情報中心性の値をノードの大きさに反映したグラフを、それぞれPageRankと媒介中心性の値をノードの大きさに反映した2つのグラフと並べたものがが図3.9である。 図3.9: PageRank・媒介中心性・情報中心性の値をノードの大きさに反映させたグラフ References Page, L., Brin, S., Motwani, R., &amp; Winograd, T. (1999). The PageRank citation ranking: Bringing order to the web. Stanford InfoLab. 鈴木努. (2017). R で学ぶデータサイエンス 8 ネットワーク分析 第2版 (金明哲., Ed.). 共立出版. 分からない場合はこちら↩︎ 分からない場合はこちら↩︎ 調和平均とは、逆数の平均の逆数である。例えば、1, 2, 4の調和平均は次のようになる。 \\[ \\frac{3}{\\frac{1}{1} + \\frac{1}{2} + \\frac{1}{4}} = \\frac{1}{\\frac{7}{12}} = \\frac{12}{7} \\]↩︎ "],["Chapter3-2.html", "3.2 ネットワーク構造の諸指標", " 3.2 ネットワーク構造の諸指標 ここでは、ネットワーク全体の構造の特徴を表す指標についてまとめる。 3.2.1 集中度(Centralization) 前節では、各ノードがグラフ内でどの程度中心的かを表す指標として中心性指標を扱ってきた。それらを用いてグラフにおいて特定のノードに高い中心性がどの程度集中しているのかを示す指標が集中度である。グラフの集中度(\\(C_x\\))は以下の式によって定式化され、0から1の値をとる。ただし、各ノードの中心性指標を\\(C_x(i)\\)、グラフにおけるその中心性指標の最大値を\\(C_x(i^*)\\)とする。また、そのグラフと同数のノード(n個)を持つグラフにおける\\(\\sum_{i=1}^n [C_x(i^*)-C_x(i)]\\)の最大値を\\(max\\sum_{i=1}^n [C_x(i^*)-C_x(i)]\\)とする。 \\(C_x = \\frac {\\sum_{i=1}^n [C_x(i^*)-C_x(i)]}{max\\sum_{i=1}^n [C_x(i^*)-C_x(i)]}\\) 例として、第2章で算出した毛づくろい頻度ネットワークgroom_mat_b(表2.3)の集中度を求める。igraphパッケージでは、様々な中心性指標についての中心度を求められる。graph_from_adjacency_matrix()でigraphクラスに変換した後に算出する。 ## igraphクラスに変換 graph_groom &lt;- graph_from_adjacency_matrix(groom_mat_b, ## 有向グラフなら &quot;directed&quot; mode= &quot;undirected&quot;, ## 重みなしなら NULL weighted = TRUE) ## 次数中心性 centr_degree(graph_groom, ## 入次数、出次数ならそれぞれ &quot;in&quot;と&quot;out mode = &quot;all&quot;)$centralization -&gt; cent_deg cent_deg ## [1] 0.2904412 ## 固有ベクトル中心性 centr_eigen(graph_groom, ## 有向グラフならTRUE directed = FALSE)$centralization -&gt; cent_eig cent_eig ## [1] 0.3104138 ## 媒介中心性 centr_betw(graph_groom, directed = TRUE)$centralization -&gt; cent_bet cent_bet ## [1] 0.04678902 各指標の大きさをノードサイズに反映したグラフを以下に示した(図3.10)。集中度はそこまで高くないといえそう(特に媒介中心性は)? 図3.10: 次数中心性・固有ベクトル中心性・媒介中心性の値をノードの大きさに反映したグラフと各指標における集中度。 ノードが赤い個体が各指標の最も大きい個体を示す 3.2.2 密度(Density) 密度は、社会ネットワークにおける関係の緊密さの指標になりうる。密度が低いとき、社会ネットワーク内の個体間の直接的な関係は少なく、両者の関係は媒介者を通じた間接的なものが多いということができる(D. Croft et al., 2008)。 重み無しグラフの場合: 実際の辺の数をグラフに張ることが可能な辺の最大数で割ったもの ノードの数を\\(n\\)、実際の辺の数を\\(m\\)としたとき、\\(2m/n(n-1)\\)(無向グラフ)または\\(m/n(n-1)\\)(有向グラフ) 重み付きグラフの場合: 全辺の重みの合計をグラフに張ることが可能な辺の最大数で割ったもの ノードの数を\\(n\\)、重みの合計を\\(w\\)としたとき、\\(2w/n(n-1)\\)(無向グラフ)または\\(2m/n(n-1)\\)(有向グラフ) ここでは、表3.1の隣接行列を用いて密度を算出する。 ANTsパッケージでは、met.density()で計算可能。ただし、重みなしグラフとして算出されるよう。また、list()関数で複数の隣接行列をリスト化することで、同時に2つ以上の隣接行列について密度を算出できる。 met.density(mat_undir_b) ## Density ## 0.3571429 ## リスト化 list_mat &lt;- list(mat_undir_b, mat_dir_b) met.density(list_mat) ## [[1]] ## [1] 0.3571429 ## ## [[2]] ## [1] 0.2678571 snaパッケージでは、gden()で計算可能。ignore.value = FALSEとすると重み付きグラフとして扱われる。ANTsパッケージと同様、リスト化した複数の隣接行列の密度を同時に算出できる。 ## 重み付き gden(mat_undir_b, ## 重み無グラフならば、TRUE ignore.eval = FALSE, ## 有向グラフならば &quot;digraph&quot; mode = &quot;graph&quot;) ## [1] 0.6428571 ## リスト化 gden(list_mat) ## [1] 0.6428571 0.4464286 3.2.3 同類性(Assortativity) ネットワーク内において、似ているノード同士が結びつきやすい/結びつきにくいかを表したのが同類性である。ネットワーク内の辺の両端にあるノードの中心性指標や属性の相関係数を算出したものであり、-1から1の値をとる(重み付きグラフの場合は、それで重み付けされているよう)。各ノードの離散的な属性(性別、順位カテゴリなど)と連続的な属性(中心性指標、年齢など)のいずれにも適用できる。計算方法の詳細は Farine (2014) を参照。 ここでは例として、再び毛づくろい頻度ネットワークgroom_mat_b(表2.3)を使用する。同類性はassortnetパッケージ(Farine, 2014)の関数群を用いて算出できる。 3.2.3.1 連続的な属性の場合 年齢が近い個体同士が結びつきやすいかを調べる。連続的な属性の同類性はassortment.continuous()関数で算出できる。係数は-0.397…となり、年齢の近い個体同士は結びつきにくいという結果になった。 ## 年齢(2019年時点) age &lt;- c(13,10,11,11,15,8,13,9,7,18,9,11,16,11,14,11,11) ## 同類性 assortment.continuous(groom_mat_b, ## 各ノードの属性 vertex_values = age, ## 重みなしなら FALSE weighted = TRUE) ## $r ## [1] -0.397096 3.2.3.2 離散的な属性の場合 同じ年齢カテゴリ(低順位: m、中順位: m、高順位: h)の個体同士が結びつきやすいかを調べる。離散的な属性の同類性はassortment.discrete()関数で算出できる。係数はかなり高く(0.484…)、同順位カテゴリ―の個体同士がよく結びつく傾向がある。 ## 順位カテゴリ rank &lt;- c(&quot;m&quot;,&quot;m&quot;,&quot;l&quot;,&quot;l&quot;,&quot;h&quot;,&quot;h&quot;,&quot;h&quot;,&quot;h&quot;,&quot;h&quot;,&quot;h&quot;,&quot;l&quot;,&quot;l&quot;,&quot;l&quot;,&quot;m&quot;,&quot;m&quot;,&quot;m&quot;,&quot;m&quot;) ## 同類性 assortment.discrete(groom_mat_b, ## 各ノードの属性 types = rank, ## 重みなしなら FALSE weighted = TRUE) -&gt; assort_rank assort_rank$r ## [1] 0.4840036 各カテゴリ間のノードのweightの合計を計算した隣接行列も出力してくれる(表3.3)。この表からも、同順位カテゴリ間での交渉が多いことが分かる。 assort_rank$mixing_matrix %&gt;% kable(digits = 2, align = &quot;c&quot;,caption = &quot;各カテゴリ間のweightの合計&quot;) %&gt;% kable_styling(font_size = 12, full_width = FALSE) 表3.3: 各カテゴリ間のweightの合計 m l h ai m 0.25 0.08 0.06 0.40 l 0.08 0.13 0.02 0.23 h 0.06 0.02 0.28 0.36 bi 0.40 0.23 0.36 1.00 なお離散的な属性については、ANTsパッケージのmet.assortativity()関数を用いると、node permutation(詳細は4.2)で生成したランダムなネットワークにおける同類性を指定した数だけ生成してくれる。それらの何%より実際の同類性の数値が大きい/小さいかを検討することで、統計的な検定が行える。今回の例では、実測値はランダムな値の全てより小さいので、ランダムな場合より有意に小さいと言える(図3.11)。 ## node label permutationで生成したランダムなネットワーク100個についてassortativityを算出 met.assortativity(groom_mat_b, ## 各ノードの固有ベクトル中心性 attr = rank, ## 重みなしの場合 FALSE weighted = TRUE, ## node label permutationをするか perm.nl = TRUE, ## permutationの数 nperm = 10000) -&gt; nlperm_rank ### ランダムなassortativityの何%より小さい？ sum(nlperm_rank &gt; assort_rank$r)/10000 ## [1] 1e-04 図3.11: ランダムなネットワークの同類性の分布(灰色)と実測値(赤) 3.2.4 推移性(Transitivity) ネットワークにおいて、頂点\\(i\\)と\\(j\\)の間、および頂点\\(j\\)と\\(k\\)の間に関係があり、頂点\\(i\\)と\\(k\\)の間にも関係があるとき、関係が推移的であるという。例えば、図3.12で頂点A, B, Cの関係は推移的だが、頂点A, B, Gは推移的ではない。 図3.12: 推移性の説明のための無向グラフの例 有向グラフの場合は、頂点\\(i\\)から\\(j\\)、頂点\\(j\\)から\\(k\\)に有向辺があり、かつ頂点\\(i\\)から\\(k\\)に有向辺があるとき推移的であるという(図3.13)。 図3.13: 推移性の説明のための有向グラフの例 推移性はネットワーク内で推移的な関係が成り立っている比率を指す。例えば無向グラフの場合には、頂点\\(i\\)と\\(j\\)、\\(j\\)と\\(k\\)の間に辺があるとき、頂点\\(i\\)と\\(k\\)にも辺がある割合である。推移性はネットワークがどの程度クラスター化されているかの指標になる(Farine &amp; Whitehead, 2015)。そのため、クラスター係数と呼ばれることもある。 例として、毛づくろい頻度ネットワークgroom_mat_b(表2.3)の推移性を算出する。推移性はigraphパッケージのtransitivity()関数で求められる。推移性は高い？ transitivity(graph_groom, ## 有向グラフなら &quot;directed&quot; type = &quot;undirected&quot;) ## [1] 0.6909722 3.2.5 Modularity 霊長類のネットワークの種間比較でよく用いられる指標にNewmanのmodularity(Newman, 2004; Whitehead, 2008)がある。この指標は、ネットワーク内を複数のクラスターに分けたとき、クラスター内の個体間での交渉がクラスター間の個体間の交渉よりどの程度多いかを示したもので、クラスターの数をcとするとき、-0.5~1-1/cの値をとる(Borgatti et al., 2022)。値が高いほどその差が大きいことを示し、クラスターの分け方が妥当であることを示す。Newman (2004) は、modularityが0.3以上のとき、クラスター間がよく分断されているとしている。例えばマカクの種間比較研究では、血縁ごとにクラスター分けしたとき、寛容性が低い種は高い種よりもmodularityが高い(0.33±0.08 vs 0.21 ±0.03)、つまり交渉がより血縁に偏っていることが分かっている(Sueur, Petit, et al., 2011)。 Modularityは以下のように定式化される(Csardi et al., 2006)。 \\(Q = \\frac{1}{2m} \\sum_{i,j} (A_{ij} - \\gamma \\frac{k_i k_j}{2m}) \\delta(c_i,c_j)\\) なお、\\(m\\)は辺の数、\\(A_{ij}\\)は隣接行列の\\(i\\)行目\\(j\\)列目の成分、\\(k_i\\)と\\(k_j\\)はノード\\(i\\)と\\(j\\)の重み付き中心性を表す(\\(k_i\\)と\\(k_j\\)に固有ベクトル中心性を使っている論文もある(Balasubramaniam et al., 2018))。また、\\(\\delta(c_i,c_j)\\)はノード\\(i\\)と\\(j\\)が同じクラスターに属しているときは1、そうでないときは0になる。なお、\\(\\gamma \\frac{k_i k_j}{2m}\\)の部分は、ランダムに交渉が行割れていると仮定したときの\\(A_{ij}\\)の値である。\\(\\gamma\\)はデフォルトでは1だが変化させることができ、大きい値をとるほどクラスター数が多くなる。 ここでは例として、毛づくろい頻度ネットワークgroom_mat_b(表2.3)を用いて、各順位カテゴリ内(低順位・中順位・高順位)の交渉がカテゴリ間の交渉よりどの程度多いかを、\\(Q\\)を算出することで求める。 Rでは、igraphパッケージのmodularity()関数で求めることができる。graph_from_adjacency_matrix()でigraphクラスに変換した後に算出する。また、weight =で明示的に各エッジのweightを与えてあげる必要があるよう。modularityは0.315…とそこそこ大きい値であるので、順位カテゴリ内に毛づくろいが偏っていることを示している。 ## 順位カテゴリごとに番号を振る rank &lt;- c(2,2,1,1,3,3,3,3,3,3,1,1,1,2,2,2,2) ## igraphに変換 graph_groom &lt;- graph_from_adjacency_matrix(groom_mat_b, ## 有向グラフなら &quot;directed&quot; mode= &quot;undirected&quot;, ## 重みなしなら NULL weighted = TRUE) modularity(graph_groom, ## クラスターの分け方 membership = rank, ## deltaの値 resolution = 1, ## 有向グラフなら TRUE directed = FALSE, ## グラフのweightを与える weights = E(graph_groom, directed = FALSE)$weight) ## [1] 0.3152957 3.2.6 応用例(下位集団の検出) ネットワーク内に下位集団(クラスター)が存在するかを調べる方法はたくさんあるが(詳細は 鈴木, 2017)、ここでは主に2つの方法に焦点を当てて紹介する。 3.2.6.1 Modularityを用いる方法 一つの方法としてmodularityが最大になるような分け方がある。igraphパッケージでは、cluster_optimal()でそのようなクラスタの分け方を算出してくれる。なお、ノード数が多い場合には時間がかかるため、様々な近似計算法が考案されている(cluster_fast_greedy()、cluster_walktrap()など)。 例として、毛づくろい頻度ネットワークgroom_mat_b(表2.3)について算出する。その結果、4つのクラスターに分類され、そのときのmodularityは0.40だった。概ね順位ごとに分かれていることが分かる(同じアルファベットから始まる個体が同一家系である)。高順位、中順位(2つに分かれている)、低順位にほぼ綺麗に分かれた。 ## 算出 cluster_optimal(graph_groom, weights = E(graph_groom)$weight) -&gt; cluster_groom ## 結果 cluster_groom ## IGRAPH clustering optimal, groups: 4, mod: 0.4 ## + groups: ## $`1` ## [1] &quot;Aka&quot; &quot;Ako&quot; &quot;Mei&quot; ## ## $`2` ## [1] &quot;Hen&quot; &quot;Hot&quot; &quot;Mal&quot; &quot;Mik&quot; &quot;Tam&quot; &quot;Tot&quot; ## ## $`3` ## [1] &quot;Kil&quot; &quot;Kit&quot; &quot;Koh&quot; &quot;Kor&quot; &quot;Kun&quot; &quot;Kur&quot; ## ## $`4` ## + ... omitted several groups/vertices ## modularity modularity(cluster_groom,directed = FALSE, weights = NULL) ## [1] 0.4020546 ## 確認 modularity(graph_groom, ## クラスターの分け方 membership = membership(cluster_groom), ## deltaの値 resolution = 1, ## 有向グラフなら TRUE directed = FALSE, weights = E(graph_groom)$weight) ## [1] 0.4020546 クラスターごとに色分けして図示すると図3.14のようになる。 set.seed(125) graph_groom %&gt;% as_tbl_graph(directed = FALSE) %&gt;% ## 各個体がどのクラスターに属するかを指定 mutate(member = as.factor(cluster_groom$membership)) %&gt;% ggraph(layout = &quot;nicely&quot;)+ ## クラスターごとに囲う #geom_mark_hull(aes(x=x,y=y,fill = member), # concavity = 10)+ geom_node_point(aes(color = member),shape = 16, size = 12)+ geom_edge_link(start_cap = circle(0.5,&quot;cm&quot;), end_cap = circle(0.5,&quot;cm&quot;), color = &quot;grey55&quot;, aes(width = weight))+ scale_edge_width(range = c(0,3))+ geom_node_text(aes(label = name), color = &quot;white&quot;)+ theme_graph()+ scale_color_nejm()+ scale_fill_nejm()+ theme(aspect.ratio = 0.9)+ scale_x_continuous(expand = c(0.12,0.12))+ scale_y_continuous(expand = c(0.1,0.1)) 図3.14: Modularityに基づいてクラスターごとに色分けした毛づくろい頻度のグラフ 3.2.6.2 構造類似性を用いる方法 他の方法として、ノード間でネットワーク内での構造的な位置が類似している程度(= 構造類似性)を用いる方法がある。構造類似性の指標として良く用いられるのがユークリッド距離や相関係数である。このような構造類似性の指標を用い、ネットワーク上における位置の似た頂点をひとまとめにし、ネットワークをより少ないいくつかのブロック同士の関係に分けることをブロックモデリングという。 ユークリッド距離 ノード\\(i\\)と\\(j\\)のユークリッド距離(\\(d_{ij}\\))は隣接行列\\(A = (a_{ij})\\)について以下のように定式化される。\\(d_{ij}\\)が大きいほど類似性は低い。 \\[ d_{ij} = \\sqrt {\\sum_{k =1}^{n}(a_{ij}-a_{jk})^2 + (a_{ki}-a_{kj})^2 } \\] 相関係数 ノード\\(i\\)とノード\\(j\\)の相関係数(\\(r_{ij}\\)は隣接行列\\(A = (a_{ij})\\)について以下のように定式化される。\\(r_{ij}\\)が大きいほど類似性は高い。 \\[ r_{ij} = \\frac{(i列とj列の共分散) + (i行とj行の共分散)}{(i列とi行の標準偏差) \\times (j列とj行の標準偏差)} \\] snaパッケージのequiv.clust()関数を用いることで、構造同値性に基づいたクラスター分析ができる。ここでは、毛づくろい頻度ネットワークgroom_mat_b(表2.3)のユークリッド距離を用いて分析を行う。method =で使用する構造類似性の指標を、clust.method =で階層クラスター分析の方法を指定する(方法の詳細はこちら) 。 ## ユークリッド距離 cluster_groom_euc &lt;- equiv.clust(groom_mat_b, ## 相関係数なら &quot;correlation&quot; method = &quot;euclidean&quot;, ## 階層クラスター分析の方法 cluster.method = &quot;complete&quot;) クラスター分析に基づくデンドログラムは図3.15のようになる。縦軸が互いのユークリッド距離を表す。 図3.15: クラスター分析結果に基づくデンドログラム この結果からblockmodel()関数でブロックモデルを作る。引数h =でクラスター(= ブロック)を作る基準となる高さを、もしくは引数k =でブロック数を指定できる。ここでは、ブロック数を3つに指定したときの結果を調べる。各個体がどのブロックに振り分けられたかは、表3.4の通りである。 blockmodel_groom_3 &lt;- blockmodel(## 隣接行列 groom_mat_b, ## クラスター分析結果 cluster_groom_euc, ## `k =`でクラスター数の指定。`h = `でクラスターの基準の高さも指定できる。 k = 3) ## メンバーシップ data.frame(femaleID = blockmodel_groom_3$plabels, block = blockmodel_groom_3$block.membership) %&gt;% arrange(femaleID) -&gt; membership_3 membership_3 %&gt;% pivot_wider(names_from = femaleID, values_from = block) %&gt;% kable(align = &quot;c&quot;, caption = &quot;ブロック数が3のときに各個体が属するブロック&quot;) %&gt;% kable_styling(font_size = 8, full_width = FALSE) 表3.4: ブロック数が3のときに各個体が属するブロック Aka Ako Hen Hot Kil Kit Koh Kor Kun Kur Mal Mei Mik Ntr Tam Ten Tot 1 1 2 2 3 3 3 3 2 3 2 2 2 2 2 2 2 ブロック数を2から5に変化させたときにmodularityがどうなるかを調べたところ、k = 3のときに最大になるよう(表3.5)。 k = 2:5 ## kを2~5にしたときに各個体が属するブロックを計算 map(k, ~blockmodel(## 隣接行列 groom_mat_b, ## クラスター分析結果 cluster_groom_euc, ## `k =`でクラスター数の指定。`h = `でクラスターの基準の高さも指定できる。 k = .)$block.membership) -&gt; member_list ## modularityを算出 data.frame(k = rep(k,each = 17),femaleID = blockmodel_groom_3$plabels, member = c(member_list[[1]],member_list[[2]],member_list[[3]],member_list[[4]])) %&gt;% group_by(k) %&gt;% nest() %&gt;% mutate(member2 = map(data,~arrange(., femaleID)$member)) %&gt;% select(k, member2) %&gt;% group_by(k) %&gt;% mutate(modularity = map(member2, ~modularity(graph_groom, membership = as.factor(.), weights = E(graph_groom, directed = FALSE)$weight))) %&gt;% select(k, modularity) %&gt;% unnest(cols = c(modularity)) %&gt;% kable(align = &quot;c&quot;, caption = &quot;ブロック数を2~5にしたときのmodularity&quot;) %&gt;% kable_styling(font_size = 13, full_width = FALSE) 表3.5: ブロック数を2~5にしたときのmodularity k modularity 2 0.2279996 3 0.3592285 4 0.3317726 5 0.2642927 clValidパッケージのclValid()関数では、様々な指標を用いてクラスター分けが妥当か算出してくれるよう。詳しくは、 Brock et al. (2008) もしくはこちらを参照。よく使用される指標であるDunn indexと silhouette widthの結果を見ると、3つのクラスターに分けるのが妥当だと示唆される。 clValid(obj = groom_mat_b, nClust = 2:5, clMethods = &quot;hierarchical&quot;, validation = &quot;internal&quot;, Metric = &quot;euclidean&quot;) -&gt; result summary(result) ## ## Clustering Methods: ## hierarchical ## ## Cluster sizes: ## 2 3 4 5 ## ## Validation Measures: ## 2 3 4 5 ## ## hierarchical Connectivity 2.9290 5.8579 8.8869 11.9270 ## Dunn 0.8946 1.3325 0.6119 0.6219 ## Silhouette 0.5547 0.5632 0.2284 0.1967 ## ## Optimal Scores: ## ## Score Method Clusters ## Connectivity 2.9290 hierarchical 2 ## Dunn 1.3325 hierarchical 3 ## Silhouette 0.5632 hierarchical 3 ３つのクラスターごとに色分けして図示すると図3.16のようになる。 set.seed(125) graph_groom %&gt;% as_tbl_graph(directed = FALSE) %&gt;% ## 各個体がどのブロックに属するかを指定 mutate(member = as.factor(membership_3$block)) %&gt;% ggraph(layout = &quot;nicely&quot;)+ ## ブロックごとに囲む #geom_mark_hull(aes(x=x,y=y,fill = member), # concavity = 10)+ geom_node_point(aes(color = member),shape = 16, size = 12)+ geom_edge_link(start_cap = circle(0.5,&quot;cm&quot;), end_cap = circle(0.5,&quot;cm&quot;), color = &quot;grey55&quot;, aes(width = weight))+ scale_edge_width(range = c(0,3))+ geom_node_text(aes(label = name), color = &quot;white&quot;)+ theme_graph()+ scale_color_nejm()+ scale_fill_nejm()+ theme(aspect.ratio = 0.9)+ scale_x_continuous(expand = c(0.1,0.1))+ scale_y_continuous(expand = c(0.1,0.1)) 図3.16: 構造類似性に基づいてクラスターごとに色分けした毛づくろい頻度のグラフ 3.2.7 その他 個体間の敵対的交渉の隣接行列を用いた順位序列についての各指標の算出については、筆者の別稿を参照。ここで紹介しきれなかった他の指標やクラスター分析の手法については、Whitehead (2008) , D. Croft et al. (2008) , 鈴木 (2017) などを参照。 References Balasubramaniam, K. N., Beisner, B. A., Berman, C. M., De Marco, A., Duboscq, J., Koirala, S., Majolo, B., Macintosh, A. J. J. J., McFarland, R., Molesti, S., Ogawa, H., Petit, O., Schino, G., Sosa, S., Sueur, C., Thierry, B., Waal, F. B. M. M. de, &amp; McCowan, B. (2018). The influence of phylogeny, social style, and sociodemographic factors on macaque social network structure. Am. J. Primatol., 80(1), e22727. Borgatti, S. P., Everett, M. G., Johnson, J. C., &amp; Agneessens, F. (2022). Analyzing social networks using R. SAGE. Brock, G., Pihur, V., Datta, S., &amp; Datta, S. (2008). clValid: An R package for cluster validation. J. Stat. Softw., 25, 1–22. Croft, D., James, R., &amp; Krause, J. (2008). 動物の社会ネットワーク分析 (島田将喜., Trans.). 東海大学出版部. Csardi, G., Nepusz, T., &amp; Others. (2006). The igraph software package for complex network research. InterJournal, Complex Systems, 1695(5), 1–9. Farine, D. R. (2014). Measuring phenotypic assortment in animal social networks: Weighted associations are more robust than binary edges. Anim. Behav., 89, 141–153. Farine, D. R., &amp; Whitehead, H. (2015). Constructing, conducting and interpreting animal social network analysis. J. Anim. Ecol., 84(5), 1144–1163. Newman, M. E. J. (2004). Analysis of weighted networks. Phys. Rev. E Stat. Nonlin. Soft Matter Phys., 70(5 Pt 2), 056131. Sueur, C., Petit, O., De Marco, A., Jacobs, A. T., Watanabe, K., &amp; Thierry, B. (2011). A comparative network analysis of social style in macaques. Anim. Behav., 82(4), 845–852. Whitehead, H. (2008). Analyzing animal societies. The University of Chicago Press. 鈴木努. (2017). R で学ぶデータサイエンス 8 ネットワーク分析 第2版 (金明哲., Ed.). 共立出版. "],["Chapter4-1.html", "4 統計的検定 4.1 なぜランダム化検定が必要か？", " 4 統計的検定 4.1 なぜランダム化検定が必要か？ 隣接行列(ネットワーク)内の数値(= 交渉頻度やSRIなどのassociation index)は互いに独立ではない(D. P. Croft et al., 2011; Farine, 2017; Farine &amp; Whitehead, 2015)。これは、同じ個体が関連する交渉/association同士は、その個体に由来する何らかの傾向を含んでいるからである。例えば、図4.1のグラフにおいて、ノードAが(相手に依らず)そもそも他個体とよく交渉を行う個体だったとしよう。そうすると、ノードAに関連する交渉の頻度(= AとB, AとC, AとD, AとEの間の辺の重み)は全体的に高い傾向になると考えられる。このように、ノードAが関連するの辺の重みは独立ではない。これは、他のノードが関連する交渉についても同様に当てはまる。 このような非独立性はネットワークの中心性指標についてもいえる。例えば、図4.1のグラフの重みづけ中心性について考える。ノードAとCの重みづけ中心性をそれぞれ計算するとき、どちらの計算にもAとCをつなぐ辺の重み(3)が入ってくる(A:1+1+2+3; C: 2+2+3)。つまり、これらのノードの重みづけ中心性は互いに関連しあっている(= 独立ではない)。これは、辺で繋がっている全てのノード同士の重み付き中心性について言える。 図4.1: ネットワークデータの非独立性の説明のためのグラフ これは、統計的な分析を行おうとするときに大きな問題になる。なぜなら、ほとんどの統計分析(t検定、相関分析、GLMなどの回帰分析、…)ではデータが互いに独立していることが仮定されているからである(D. P. Croft et al., 2011)。そのため、ネットワークデータにそのままこのような分析を適用すると、誤った結果が得られる確率(= 第一種の過誤や第二種の過誤が生じる確率)が高くなってしまうのである。 この問題に対処するために最もよく用いられる方法がランダム化検定(randomization test)である(D. P. Croft et al., 2011; Farine, 2017; Farine &amp; Whitehead, 2015)。ランダム化検定とは、「ランダムな」ネットワークを大量(少なくとも1000回以上)に生成した後、それらから得られた統計検定量(e.g., t検定量や回帰係数など)の分布を帰無分布4として、実際の統計検定量の有意性を判定する方法である。ここでの「ランダム」なネットワークは、帰無仮説が正しいときの個体間の交渉やassociationを表すものでなくてはならない。例えば、「毛づくろいネットワークにおける中心性と年齢に関連がある」という仮説を検証するのであれば、年齢にかかわらずランダムに毛づくろいが行われているネットワークをランダムネットワークとして生成する必要がある。 加えて、適切にランダム化検定を行うためには、検定の対象となる側面(e.g., 中心性指標と順位の関係、個体間の交渉頻度と性別・年齢の関係など)についてはランダム化する一方で、それ以外の側面(e.g., 各個体の観察回数、ノードと辺の数、ネットワークの構造など)については可能な限り一定になるようにランダムネットワークを生成することが重要である。この点を考慮するため、ネットワーク分析では実データをシャッフルすることでランダムなネットワークを生成するパーミュテーション検定(permutation test)がよく用いられる。 ネットワークデータへのパーミュテーション検定は、通常以下の5つのステップで行われる(Farine, 2017 を改変)。 観察データから社会ネットワークを生成する。 1で作成した社会ネットワークに対して統計分析を行い、統計検定量(e.g., t検定ならt統計量、GLMなどの回帰分析なら回帰係数)を算出する。 観察データをシャッフルし、ランダムなネットワークをたくさん作る(少なくとも1000個)。 それぞれのランダムネットワークに対して、2と同じ統計分析を行い、統計検定量を算出する。 2の統計検定量を4の統計検定量の分布と比較する。両者に大きな乖離があれば、仮説が正しいと結論付ける。例えば有意水準が5%のときには、2の統計検定量が4の統計検定量の95%より大き/小さければ、帰無仮説を棄却することになる。 パーミュテーション検定は、どの段階のデータをシャッフルするかによって大きく2つに分けられる。以下では、それぞれについて詳しくみていく。より詳しい解説は D. P. Croft et al. (2011)、 Farine &amp; Whitehead (2015)、 Farine (2017) を参照。 Network permutation: 既に作られたネットワーク上のノードや辺をシャッフルする。 Pre-network permutation (またはData stream permutation): ネットワークを作る前に、交渉やassociationの生データをシャッフルする。 References Croft, D. P., Madden, J. R., Franks, D. W., &amp; James, R. (2011). Hypothesis testing in animal social networks. Trends in Ecology and Evolution, 26(10), 502–507. Farine, D. R. (2017). A guide to null models for animal social network analysis. Methods Ecol. Evol., 8(10), 1309–1320. Farine, D. R., &amp; Whitehead, H. (2015). Constructing, conducting and interpreting animal social network analysis. J. Anim. Ecol., 84(5), 1144–1163. 帰無仮説が正しいとしたときの統計検定量の分布。帰無仮説とは何かわからない場合は、こちらを参照。 ↩︎ "],["Chapter4-2.html", "4.2 Network permutation", " 4.2 Network permutation 4.2.1 Node permutationの手法 Network permutationには大きく分けて辺をシャッフルするedge permutationと、ノードをシャッフルするnode permutationに分けられるが、本節ではより一般的に用いられている後者についてのみ解説を行う。前者は生物のネットワークではあまり用いられないため(D. P. Croft et al., 2011; Farine, 2017)、ここでは解説しない。 Node permutationでは、ノードの属性(性別、順位など)をランダムにシャッフルして生成したランダムなネットワークにおける統計検定量の分布を帰無分布とし、実際のデータの統計検定量をそれと比較することで有意性を判定する方法である。これにより、ネットワークの構造(e.g., ノード数、辺の数、密度など)や属性ごとのノード数(e.g., 性別の場合、オスとメスの数)を一定にしたまま検定を行うことができる。 例えば、5個体からなる集団において、個体の社会的順位と固有ベクトル中心性の相関の有意性を検定するとしよう。Node permutationでは、以下のような手順で検定を行う(4.1も参照)。 観察データからネットワークを生成する。 ここでは、図4.2のORIGINALが得られたとする 1で作成した社会ネットワークに対して統計分析を行い、統計検定量を算出する。 ここでは相関係数を算出し、-0.83だったとする(図4.2)。 ノードの属性(ここでは個体名とその順位)をランダムにシャッフルし、ランダムネットワークを多数作成する(図4.2のPERMUTATION1 ~ PERMUTATION1000)。通常は少なくとも1000回は行う。 すべてのランダムなネットワークにおける相関係数を算出する(図4.2)。 図4.2: Node permutationの例 ランダムなネットワークから算出された相関係数の分布を帰無分布とし、実際の相関係数がこれらの何%より大きい(または小さい)かを算出する(図4.3)。これが\\(P\\)値になる。このように、片側検定が用いられることが多い。ここでは、ランダムネットワークの相関係数の5/1000しか実測値より小さくないので、\\(P = 0.005\\)となり有意な負の相関があるという結論が得られる。 図4.3: Node permutationでの検定の例 4.2.2 分析例 Node permutationは様々な分析に適用可能である。以下では、実際の分析例をいくつか見ていく。 4.2.2.1 線形モデル(GLM、GLMMなど) 一般化線形モデル(GLM)や一般化線形混合モデル(GLMM)をはじめとした線形モデルは、2つ以上の変数間の関連を調べるうえで非常に有用な分析である(Dunn &amp; Smyth, 2018; 大東, 2010)。これらの手法は、社会ネットワーク分析でノードレベルの検定(e.g., 各個体の属性と中心性指標の関連など)を行う際にも非常に有用である(Farine, 2017)。 GLMやGLMMでは、何かの原因となっていると想定される変数を説明変数(以下、\\(x\\)とする)、それを受けて変化すると想定される変数を応答変数(以下、\\(y\\)とする)という。 4.2.2.1.1 分析例1. 正規線形モデル 以下では、シンプルな例として応答変数が正規分布から得られていると仮定するモデルを用いた分析を行う。金華山島\\(B_1\\)群において、個体追跡中の6歳以上のメス間の近接時間割合を算出したところ、以下の隣接行列(prox_mat, 4.1)が得られたとする。 ## マトリックスの読み込み prox_mat &lt;- read.csv(&quot;data/prox_f.csv&quot;,row.names=1) %&gt;% as.matrix() ## マトリックスをアルファベット順で並び替え prox_mat &lt;- prox_mat[sort(rownames(prox_mat)), sort(colnames(prox_mat))] ## 体格成分を0に diag(prox_mat) &lt;- 0 表4.1: 近接時間割合の隣接行列 Aka Ako Hen Hot Kil Kit Koh Kor Kun Mal Mei Mik Ntr Ten Tot Aka 0.00 0.07 0.01 0.02 0.01 0.00 0.02 0.02 0.01 0.01 0.03 0.03 0.05 0.06 0.02 Ako 0.07 0.00 0.05 0.02 0.02 0.02 0.01 0.03 0.01 0.01 0.04 0.02 0.04 0.03 0.02 Hen 0.01 0.05 0.00 0.04 0.01 0.01 0.02 0.03 0.00 0.03 0.03 0.04 0.03 0.02 0.06 Hot 0.02 0.02 0.04 0.00 0.01 0.01 0.00 0.02 0.05 0.03 0.02 0.04 0.01 0.04 0.03 Kil 0.01 0.02 0.01 0.01 0.00 0.15 0.11 0.05 0.03 0.02 0.01 0.04 0.04 0.03 0.02 Kit 0.00 0.02 0.01 0.01 0.15 0.00 0.10 0.06 0.06 0.01 0.02 0.03 0.04 0.03 0.04 Koh 0.02 0.01 0.02 0.00 0.11 0.10 0.00 0.09 0.06 0.01 0.01 0.03 0.02 0.02 0.04 Kor 0.02 0.03 0.03 0.02 0.05 0.06 0.09 0.00 0.04 0.02 0.03 0.05 0.06 0.07 0.13 Kun 0.01 0.01 0.00 0.05 0.03 0.06 0.06 0.04 0.00 0.04 0.00 0.02 0.02 0.04 0.01 Mal 0.01 0.01 0.03 0.03 0.02 0.01 0.01 0.02 0.04 0.00 0.05 0.15 0.03 0.04 0.02 Mei 0.03 0.04 0.03 0.02 0.01 0.02 0.01 0.03 0.00 0.05 0.00 0.03 0.05 0.03 0.02 Mik 0.03 0.02 0.04 0.04 0.04 0.03 0.03 0.05 0.02 0.15 0.03 0.00 0.03 0.05 0.02 Ntr 0.05 0.04 0.03 0.01 0.04 0.04 0.02 0.06 0.02 0.03 0.05 0.03 0.00 0.07 0.03 Ten 0.06 0.03 0.02 0.04 0.03 0.03 0.02 0.07 0.04 0.04 0.03 0.05 0.07 0.00 0.07 Tot 0.02 0.02 0.06 0.03 0.02 0.04 0.04 0.13 0.01 0.02 0.02 0.02 0.03 0.07 0.00 このネットワークにおいて、各メスの固有ベクトル中心性(eigen)と順位(rank)・年齢(age)との関連を調べるため、以下のモデルを考える。ただし、添え字の\\(i\\)はそれが\\(i\\)番目の個体のデータであることを表す(\\(i = 1,2,3,...,16\\))。 \\(\\beta_0\\)はモデルの切片を、\\(\\beta_1\\)と\\(\\beta_2\\)はそれぞれ順位と年齢が1増えたときに、固有ベクトル中心性がどのくらい上昇すると期待されるかを表す(= 回帰係数)。また、2行目の数式は、\\(i\\)番目の個体の固有ベクトル中心性(\\(eigen_i\\))が、平均\\(\\mu_i\\)、分散\\(\\sigma\\)の正規分布から得られることを表す。GLMやGLMMでは、実際のデータが得られる確率が最も高くなるようにモデルのパラメータ(ここでは、\\(\\beta_0, \\beta_1, \\beta_2. \\sigma\\))を推定していく。 $$ \\[\\begin{aligned} \\mu_i &amp;= \\beta_0 + \\beta_1 \\times rank_i + \\beta_2 \\times age_i \\\\ eigen_i &amp;\\sim Normal(\\mu_i, \\sigma) \\end{aligned}\\] $$ それでは、分析に移ろう。すでに隣接行列を算出してネットワークを作成しているので、個体ごとの固有ベクトル中心性を算出する(Step2)。個体ごとの属性をatt_femalesとしてデータフレームにまとめる(第2.2参照)。 ## 属性データの作成 att_females &lt;- data.frame(femaleID = colnames(prox_mat), rank = c(8,9,11,12,1,2,3,5,4,13,15,14,6,7,10), age = c(12,9,10,10,14,7,12,8,6,8,10,15, 10, 10, 10)) ## 算出 att_females &lt;- met.eigen(prox_mat, df = att_females, dfid = 1, sym = TRUE) 算出結果は以下のようになった。 att_females %&gt;% datatable(rownames = FALSE) 算出結果からプロットを作成したところ、順位と固有ベクトル中心性の間には負の関連がありそうなことがわかる(図4.4)。 図4.4: 固有ベクトル中心性(eigen)と順位(rank)・年齢(age)との関連 続いて、先ほどの数式に基づいたモデリングを行う。Rでは以下のコードで実行することができる。 r_glm &lt;- lm(data = att_females, formula = eigen ~ rank + age) モデリングの結果推定された\\(\\beta_0\\)、\\(\\beta_1\\)、\\(\\beta_2\\)の推定値は以下のようになる。なお、Interceptは切片を表す。 r_glm ## ## Call: ## lm(formula = eigen ~ rank + age, data = att_females) ## ## Coefficients: ## (Intercept) rank age ## 0.76715 -0.02341 0.01126 パーミュテーション検定では、\\(\\beta_1\\)や\\(\\beta_2\\)などの回帰係数を統計検定量として検定を行うことで、説明変数と応答変数の関連が有意であるかをしらべることが推奨されている(Farine, 2017)。そこで、それぞれの推定値を持つオブジェクトを作成する(b_rankとb_age)。 b_rank &lt;- coef(r_lm)[[2]] b_age &lt;- coef(r_lm)[[3]] 4.2.2.1.1.1 snaパッケージを用いる方法 続いて、node permutationを行ってランダムなネットワーク(隣接行列)を1000個生成し、それぞれのネットワークにおいて同じ回帰分析を行い、先ほど同様に\\(\\beta_1\\)と\\(\\beta_2\\)の推定値を算出する(Step3~4)。 Rでは、snaパッケージのrmperm関数でnode permutationを行うことができる。b_rank_randとb_rank_ageという空のベクトルを作成し、そこにランダムネットワークから算出された\\(\\beta_1\\)と\\(\\beta_2\\)を入れている。 ## 空の行列を作成 b_rank_rand &lt;- rep(0,1000) b_age_rand &lt;- rep(0,1000) set.seed(123) for(i in 1:1000){ random_net &lt;- rmperm(prox_mat) att_females_rand &lt;- met.eigen(random_net, df = att_females) r_lm_rand &lt;- lm(data = att_females_rand, formula = eigen ~ rank + age) b_rank_rand[i] &lt;- coef(r_lm_rand)[[2]] b_age_rand[i] &lt;- coef(r_lm_rand)[[3]] } それでは、最後に実データの回帰係数をランダムネットワークの回帰係数の分布と比較する(図4.5)。灰色のヒストグラムがランダムネットワークの回帰係数の分布を、赤い線が実データの回帰係数を表している。\\(\\beta_1\\)については、有意な値だといえそうだ。 図4.5: 実データの回帰係数とランダムネットワークの回帰係数の分布の比較 そこで、実データの回帰係数がランダムネットワークの回帰係数の何%より大きいか/小さいかを計算することで、\\(P\\)値を算出する。 算出は以下のように行える。 順位の係数(\\(\\beta_1\\))については、P = 0.017なので、有意な関連があると結論付けられる。 p_rank &lt;- sum(b_rank &gt; b_rank_rand)/1000 p_rank ## [1] 0.017 一方で、年齢の係数(\\(\\beta_2\\))については、P = 0.726なので、帰無仮説は棄却されない。 p_age &lt;- sum(b_age &gt; b_age_rand)/1000 p_age ## [1] 0.726 4.2.2.1.1.2 ANTsパッケージを用いる方法 ここまで行ったnode permutation検定のstep3以降は、ANTsパッケージを用いるとより簡単に行うことができる。 ANTsパッケージでは、個体の属性や中心性指標が入ったデータフレームを用いて、node permutationを行うことができる。 perm.net.nl関数では、指定されたラベル(今回の場合は、応答変数である固有ベクトル中心性)について、指定した数だけパーミュテーションを行ってくれる(やっていることはsnaパッケージを用いた場合と同じ)。 set.seed(123) perm_lm &lt;- perm.net.nl(## 算出した固有ベクトル中心性と属性を含むデータフレーム att_females, ## パーミュテーションするラベル。ここでは固有ベクトル中心性 labels = c(&quot;eigen&quot;), ## 回数 nperm = 1000, progress = FALSE) 続いてstat.glm関数を用い、実データとランダムネットワークにおけるデータに対してモデリングを行い、パラメータの推定値を算出する。 このとき、相関係数の検定についてはstat.cor、t検定についてはstat.t、GLMMについてはstat.glmmなど、分析ごとに様々な関数が用意されている。詳細はこちらのサイトを参照。 r_lm_b &lt;- stat.glm(perm_lm, ## 式 formula = eigen ~ age + rank, ## 応答変数が従う分布を指定。二項分布なら&quot;binomial&quot;、ポワソン分布なら&quot;poisson&quot; family = gaussian(link = &quot;identity&quot;), progress = FALSE) ## Original model : ## ## ## Call: ## c(&quot;eigen ~ age + rank , family = gaussian&quot;, &quot;eigen ~ age + rank , family = identity&quot;, ## &quot;eigen ~ age + rank , family = function (mu) \\nmu&quot;, &quot;eigen ~ age + rank , family = function (eta) \\neta&quot;, ## &quot;eigen ~ age + rank , family = function (mu) \\nrep.int(1, length(mu))&quot;, ## &quot;eigen ~ age + rank , family = function (y, mu, wt) \\nwt * ((y - mu)^2)&quot;, ## &quot;eigen ~ age + rank , family = function (y, n, mu, wt, dev) \\n{\\n nobs &lt;- length(y)\\n nobs * (log(dev/nobs * 2 * pi) + 1) + 2 - sum(log(wt))\\n}&quot;, ## &quot;eigen ~ age + rank , family = function (eta) \\nrep.int(1, length(eta))&quot;, ## &quot;eigen ~ age + rank , family = expression({\\n n &lt;- rep.int(1, nobs)\\n if (is.null(etastart) &amp;&amp; is.null(start) &amp;&amp; is.null(mustart) &amp;&amp; ((family$link == \\&quot;inverse\\&quot; &amp;&amp; any(y == 0)) || (family$link == \\&quot;log\\&quot; &amp;&amp; any(y &lt;= 0)))) \\n stop(\\&quot;cannot find valid starting values: please specify some\\&quot;)\\n mustart &lt;- y\\n})&quot;, ## &quot;eigen ~ age + rank , family = function (mu) \\nTRUE&quot;, &quot;eigen ~ age + rank , family = function (eta) \\nTRUE&quot; ## ) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -0.213864 -0.122024 -0.003596 0.103370 0.259816 ## ## Coefficients: ## Estimate Std. Error t value ## (Intercept) 0.767149 0.177280 4.327 ## age 0.011258 0.016630 0.677 ## rank -0.023405 0.009051 -2.586 ## ## (Dispersion parameter for gaussian family taken to be 0.02250086) ## ## Null deviance: 0.42284 on 14 degrees of freedom ## Residual deviance: 0.27001 on 12 degrees of freedom ## AIC: -9.692 ## ## Number of Fisher Scoring iterations: 2 分析結果は、ant関数を用いることで確認できる。 実データの回帰係数とランダムネットワークの回帰係数の分布の比較は以下のように可視化できる(図4.6)。 r_lm_ants &lt;- ant(r_lm_b) 図4.6: 実データの回帰係数とランダムネットワークの回帰係数の分布の比較 検定結果は以下の通り。p.leftとp_rightはランダムネットワークの係数が実際の係数よりも小さい/大きい確率を表す。snaパッケージを用いた場合と概ね同じ結果が得られている。 r_lm_ants$model ## ## Call: ## c(&quot;eigen ~ age + rank , family = gaussian&quot;, &quot;eigen ~ age + rank , family = identity&quot;, ## &quot;eigen ~ age + rank , family = function (mu) \\nmu&quot;, &quot;eigen ~ age + rank , family = function (eta) \\neta&quot;, ## &quot;eigen ~ age + rank , family = function (mu) \\nrep.int(1, length(mu))&quot;, ## &quot;eigen ~ age + rank , family = function (y, mu, wt) \\nwt * ((y - mu)^2)&quot;, ## &quot;eigen ~ age + rank , family = function (y, n, mu, wt, dev) \\n{\\n nobs &lt;- length(y)\\n nobs * (log(dev/nobs * 2 * pi) + 1) + 2 - sum(log(wt))\\n}&quot;, ## &quot;eigen ~ age + rank , family = function (eta) \\nrep.int(1, length(eta))&quot;, ## &quot;eigen ~ age + rank , family = expression({\\n n &lt;- rep.int(1, nobs)\\n if (is.null(etastart) &amp;&amp; is.null(start) &amp;&amp; is.null(mustart) &amp;&amp; ((family$link == \\&quot;inverse\\&quot; &amp;&amp; any(y == 0)) || (family$link == \\&quot;log\\&quot; &amp;&amp; any(y &lt;= 0)))) \\n stop(\\&quot;cannot find valid starting values: please specify some\\&quot;)\\n mustart &lt;- y\\n})&quot;, ## &quot;eigen ~ age + rank , family = function (mu) \\nTRUE&quot;, &quot;eigen ~ age + rank , family = function (eta) \\nTRUE&quot; ## ) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -0.213864 -0.122024 -0.003596 0.103370 0.259816 ## ## Coefficients: ## Estimate Std. Error t value p.left p.rigth p.one.side ## (Intercept) 0.767149 0.177280 4.327325 0.639000 0.361000 0.722000 ## age 0.011258 0.016630 0.676938 0.707000 0.293000 0.586000 ## rank -0.023405 0.009051 -2.586006 0.012000 0.988000 0.024000 ## lower.ci uper.ci mean ## (Intercept) 0.371610 1.016983 0.692 ## age -0.032318 0.033198 0.000 ## rank -0.016749 0.017132 0.000 ## ## (Dispersion parameter for gaussian family taken to be 0.02250086) ## ## Null deviance: 0.42284 on 14 degrees of freedom ## Residual deviance: 0.27001 on 12 degrees of freedom ## AIC: -9.692 ## ## Number of Fisher Scoring iterations: 2 モデルの診断結果をr_lm_ants$model.diagnosticで調べることもできる。 4.2.2.1.2 分析例2. 線形混合モデル 同様の分析は、モデルにランダム効果を入れたGLMMなどの混合モデルについても適用できる。GLMMについては、こちら などを参照。複数の調査期間に/複数の集団でデータを収集した場合などにすべてのデータをまとめて分析する際には、GLMMが適用される(Sosa et al., 2020)。 例えば、ニホンザルの7つの集団(A~F)である年におけるメスの毛づくろいのデータを収集し、ダイアッドごとの毛づくろい頻度を算出したとしよう。以下のlist_matには、list形式で7つの隣接行列が収納されている(架空のデータである)。 list_mat &lt;- readRDS(&quot;data/list_mat.obj&quot;) 例えば、3つ目の集団(C)の隣接行列は以下のようになっている(表4.2。 list_mat[[3]] %&gt;% kable(digits = 2, align = &quot;c&quot;, caption = &quot;3つめの隣接行列&quot;) %&gt;% kable_styling(font_size = 5, full_width = FALSE) 表4.2: 3つめの隣接行列 0.00 0.81 1.43 1.83 1.22 2.24 2.24 0.20 0.00 2.04 1.63 0.00 1.43 0.00 0.20 0.61 0.81 0.00 0.00 0.41 0.00 1.43 0.61 0.00 0.00 0.00 0.61 0.20 0.20 0.00 0.00 0.00 1.43 0.00 0.00 0.20 0.00 0.41 0.20 0.00 0.00 1.22 0.20 0.00 0.00 4.28 0.20 0.00 1.83 0.41 0.20 0.00 1.22 1.22 0.20 0.00 0.00 0.00 0.20 0.20 0.00 0.20 0.00 0.00 1.22 0.00 0.00 1.22 0.00 1.63 1.02 0.81 0.00 0.41 0.61 1.22 0.20 0.00 0.41 0.41 2.24 1.43 0.41 1.22 1.63 0.00 0.61 1.22 0.00 0.20 0.20 1.02 0.00 0.81 1.22 0.61 2.24 0.61 0.20 0.20 1.02 0.61 0.00 1.22 0.00 0.41 0.00 0.20 0.00 0.41 0.20 0.00 0.20 0.00 0.00 0.00 0.81 1.22 1.22 0.00 4.07 0.81 2.65 1.02 2.44 0.20 0.81 0.41 0.00 0.00 0.00 0.00 0.00 0.00 0.00 4.07 0.00 0.81 0.81 0.20 3.05 1.22 1.02 2.24 2.04 0.00 1.22 0.00 0.41 0.20 0.41 0.81 0.81 0.00 0.61 0.81 2.85 0.20 0.61 0.81 1.63 0.61 0.20 0.20 0.61 0.20 0.00 2.65 0.81 0.61 0.00 2.04 0.20 0.41 2.85 2.85 0.00 0.20 0.00 0.20 1.22 1.02 0.20 1.02 0.20 0.81 2.04 0.00 0.61 0.20 1.22 1.43 1.43 0.20 0.00 0.00 0.20 0.00 0.00 2.44 3.05 2.85 0.20 0.61 0.00 0.20 0.81 0.61 0.00 0.00 4.28 0.20 0.00 0.81 0.41 0.20 1.22 0.20 0.41 0.20 0.20 0.00 0.41 0.41 0.20 0.00 0.20 0.00 0.41 1.22 0.20 0.81 1.02 0.61 2.85 1.22 0.81 0.41 0.00 2.65 0.61 0.00 0.00 0.00 0.41 0.61 0.00 0.41 2.24 0.81 2.85 1.43 0.61 0.41 2.65 0.00 これらの集団において、各個体の固有ベクトル中心性が、その後10年間の産子数に影響しているか調べたいとする。各集団における各メスの順位・年齢・産子数・集団名が以下のlist_attにlist形式で入っている(もちろん架空のデータである)。 list_att &lt;- readRDS(&quot;data/list_att.obj&quot;) 例えば、C集団の属性データは以下のようになる。 list_att[[3]] %&gt;% datatable(rownames = FALSE) さて、これらのデータに対して仮説(固有ベクトル中心性が、産子数に影響するか)を検証するために以下のモデルを考える。ただし、添え字の\\(ji\\)はそれが\\(j\\)番目の集団の\\(i\\)番目の個体のデータであることを表す。なお、eigen、rank、age、no_birthはそれぞれ固有ベクトル中心性、順位、年齢、産子数を表す。 \\(r_j\\)はランダム切片を表し、集団による産子数(no_birth)のばらつきがあることを示している。3行目の数式は、\\(j\\)番目の集団の\\(i\\)番目の個体の産子数(\\(no\\_birth_{ji}\\))が、平均\\(\\lambda_{ji}\\)のポワソン分布から得られることを表す。 $$ \\[\\begin{aligned} r_j &amp;\\sim Normal(0, \\sigma)\\\\ \\lambda_{ji} &amp;= exp(\\beta_0 + \\beta_1 \\times eigen_{ji} + \\beta_2 \\times rank_{ji} + \\beta_3 \\times age_{ji} + r_j) \\\\ no\\_birth_{ji} &amp;\\sim Poisson(\\lambda_{ji}) \\end{aligned}\\] $$ それでは、分析に移ろう。各集団ごとに固有ベクトル中心性を算出する(Step2)。ANTsパッケージでは、複数の隣接行列と属性データをそれぞれlist形式でまとめることで、以下のように複数のネットワークについて同時に中心性を算出できる。 list_att &lt;- met.eigen(list_mat, df = list_att) C集団ついての算出結果は以下のようになった。 list_att[[3]] %&gt;% datatable(rownames = FALSE) 続いて、perm.net.nl関数を用いてnode permutationを行う(Step3)。今回のように複数のグループが含まれる集団では、各グループ内でnode permutationを行う。rf = \"group\"と指定してあげる。 perm_glmm &lt;- perm.net.nl(list_att, ## 応答変数をシャッフルすることが多い labels = &quot;no_birth&quot;, nperm = 1000, rf = &quot;group&quot;, progress = FALSE) 続いて、stat.glmm関数を用い、実データとランダムネットワークにおけるデータに対してモデリングを行い、パラメータの推定値を算出する(Step4)。ランダム切片は、(1|group)のように書いてformulaに加える。 r_glmm &lt;- stat.glmm(perm_glmm, ## 式 formula = no_birth ~ eigen + rank + age + (1|group), ## 応答変数が従う分布を指定。二項分布なら&quot;binomial&quot;、ポワソン分布なら&quot;poisson&quot; family = poisson(link = &quot;log&quot;), progress = FALSE) ## Original model : ## ## Generalized linear mixed model fit by maximum likelihood (Laplace ## Approximation) [glmerMod] ## Family: poisson log function (mu) ## log(mu) ## function (eta) ## pmax(exp(eta), .Machine$double.eps) function (mu) ## mu ## function (y, mu, wt) ## { ## r &lt;- mu * wt ## p &lt;- which(y &gt; 0) ## r[p] &lt;- (wt * (y * log(y/mu) - (y - mu)))[p] ## 2 * r ## } ## function (y, n, mu, wt, dev) ## -2 * sum(dpois(y, mu, log = TRUE) * wt) ## function (eta) ## pmax(exp(eta), .Machine$double.eps) ## expression({ ## if (any(y &lt; 0)) ## stop(&quot;negative values not allowed for the &#39;Poisson&#39; family&quot;) ## n &lt;- rep.int(1, nobs) ## mustart &lt;- y + 0.1 ## }) ## function (mu) ## all(is.finite(mu)) &amp;&amp; all(mu &gt; 0) function (eta) ## TRUE ## function (object, nsim) ## { ## wts &lt;- object$prior.weights ## if (any(wts != 1)) ## warning(&quot;ignoring prior weights&quot;) ## ftd &lt;- fitted(object) ## rpois(nsim * length(ftd), ftd) ## } ## ( log ) ## Formula: no_birth ~ eigen + rank + age + (1 | group) ## Data: odf ## ## AIC BIC logLik deviance df.resid ## 444.3 458.7 -217.2 434.3 125 ## ## Scaled residuals: ## Min 1Q Median 3Q Max ## -1.47385 -0.62718 -0.05524 0.57925 2.49088 ## ## Random effects: ## Groups Name Variance Std.Dev. ## group (Intercept) 0.1195 0.3457 ## Number of obs: 130, groups: group, 7 ## ## Fixed effects: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 0.985451 0.266388 3.699 0.000216 *** ## eigen -0.021821 0.202649 -0.108 0.914251 ## rank 0.067990 0.009907 6.863 6.74e-12 *** ## age -0.106731 0.020844 -5.120 3.05e-07 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Correlation of Fixed Effects: ## (Intr) eigen rank ## eigen -0.405 ## rank -0.515 0.239 ## age -0.616 0.042 0.011 分析結果は、antパッケージを用いることで確認できる(Step5)。 実データの回帰係数とランダムネットワークの回帰係数の分布の比較は以下のようになる(図4.7)。 r_glmm_ants &lt;- ant(r_glmm) 図4.7: 実データの回帰係数とランダムネットワークの回帰係数の分布の比較 検定結果は以下の通り。順位と年齢の有意な影響は確認されたが、固有ベクトル中心性の影響は有意でないという結果が得られた。 r_glmm_ants$model ## Generalized linear mixed model fit by maximum likelihood (Laplace ## Approximation) [glmerMod] ## Family: poisson log function (mu) ## log(mu) ## function (eta) ## pmax(exp(eta), .Machine$double.eps) function (mu) ## mu ## function (y, mu, wt) ## { ## r &lt;- mu * wt ## p &lt;- which(y &gt; 0) ## r[p] &lt;- (wt * (y * log(y/mu) - (y - mu)))[p] ## 2 * r ## } ## function (y, n, mu, wt, dev) ## -2 * sum(dpois(y, mu, log = TRUE) * wt) ## function (eta) ## pmax(exp(eta), .Machine$double.eps) ## expression({ ## if (any(y &lt; 0)) ## stop(&quot;negative values not allowed for the &#39;Poisson&#39; family&quot;) ## n &lt;- rep.int(1, nobs) ## mustart &lt;- y + 0.1 ## }) ## function (mu) ## all(is.finite(mu)) &amp;&amp; all(mu &gt; 0) function (eta) ## TRUE ## function (object, nsim) ## { ## wts &lt;- object$prior.weights ## if (any(wts != 1)) ## warning(&quot;ignoring prior weights&quot;) ## ftd &lt;- fitted(object) ## rpois(nsim * length(ftd), ftd) ## } ## ( log ) ## Formula: no_birth ~ eigen + rank + age + (1 | group) ## Data: odf ## ## AIC BIC logLik deviance df.resid ## 444.3 458.7 -217.2 434.3 125 ## ## Scaled residuals: ## Min 1Q Median 3Q Max ## -1.47385 -0.62718 -0.05524 0.57925 2.49088 ## ## Random effects: ## Groups Name Variance Std.Dev. ## group (Intercept) 0.1195 0.3457 ## Number of obs: 130, groups: group, 7 ## ## Fixed effects: ## Estimate Std. Error z value Pr(&gt;|z|) p.left p.rigth ## (Intercept) 9.855e-01 2.664e-01 3.699e+00 2.162e-04 6.700e-01 3.300e-01 ## eigen -2.182e-02 2.026e-01 -1.077e-01 9.143e-01 5.280e-01 4.720e-01 ## rank 6.799e-02 9.907e-03 6.863e+00 6.743e-12 1.000e+00 0.000e+00 ## age -1.067e-01 2.084e-02 -5.120e+00 3.049e-07 0.000e+00 1.000e+00 ## p.one.side lower.ci uper.ci mean ## (Intercept) 6.600e-01 4.941e-01 1.279e+00 0.880 ## eigen 9.440e-01 -4.044e-01 3.376e-01 -0.039 ## rank 0.000e+00 -1.812e-02 2.008e-02 0.001 ## age 0.000e+00 -4.153e-02 3.513e-02 -0.003 ## ## Correlation of Fixed Effects: ## (Intr) eigen rank ## eigen -0.405 ## rank -0.515 0.239 ## age -0.616 0.042 0.011 4.2.2.2 ネットワーク同士の関連の検討 Node permutationはネットワーク同士の関連を調べる際にも用いられることが多い。 4.2.2.2.1 ネットワーク間の相関の検定 4.2.2.2.1.1 Mantel検定 ネットワーク間の相関の検定方法として、よく知られているのがMantel検定(Mantel, 1967)である。Mantel検定は一般的に以下の手順に沿って行う(2つの隣接行列の相関を調べる場合)。 2つの隣接行列の対応する行列成分同士の相関係数を算出する。このとき、Pearsonの積率相関係数、Spearmanの順位相関係数、Kendallの順位相関係数のどれでもよい。 一方の隣接行列に対してnode permutationを行い、もう一方の隣接行列との相関係数を1と同様に算出する。 2を少なくとも1000回行う。 実際の相関係数がnode permutationによって算出された相関係数の何％より大きい/小さいかをP値とし、相関係数の有意性を判断する。 Rでは、veganパッケージのmantel関数などでMantel検定を行うことができる。ただし、今のところmantel関数は方向性のない隣接行列にしか適用できない点に注意。 ここでは、第2章で算出した方向性のない毛づくろい頻度ネットワークgroom_mat_b(表2.3)と出席データを基にしたSRIマトリックスpresence_mat(表2.4)の相関を求めてみる。 まず、groom_mat_bにいるKuriとTamという個体はpresence_matにはいないので、それらの個体を除く。また、両方の隣接行列の名前順をアルファベット順に合わせる。 ## KuriとTamを除く groom_mat_b2 &lt;- groom_mat_b[-c(10,15),-c(10,15)] ## アルファベット順に並び替える presence_mat &lt;- presence_mat[sort(colnames(presence_mat)), sort(rownames(presence_mat))] それでは、Mantel検定を行う。ここでは、いずれの隣接行列の値も正規分布からは外れているので、Spearmanの相関係数で検定を行う。結果は、P値(Significance)が0.05以上ということで有意ではない。 library(vegan) mantel(groom_mat_b2, presence_mat, ## 相関係数の種類。&quot;pearson&quot;または&quot;kendall&quot;でもよい method = &quot;spearman&quot;, ## node permutationの回数 permutations = 1000) ## ## Mantel statistic based on Spearman&#39;s rank correlation rho ## ## Call: ## mantel(xdis = groom_mat_b2, ydis = presence_mat, method = &quot;spearman&quot;, permutations = 1000) ## ## Mantel statistic r: 0.08256 ## Significance: 0.22577 ## ## Upper quantiles of permutations (null model): ## 90% 95% 97.5% 99% ## 0.137 0.184 0.210 0.253 ## Permutation: free ## Number of permutations: 1000 Mantel検定では、第3の要因(これも隣接行列の形で表す)の影響を取り除いたうえでの相関係数(= 偏相関係数)も算出することができる。ただし、マニュアルによるとPearsonの相関係数以外の値は信頼できないよう。 ここでは、順位差(rank_mat)の影響を統制したうえで、先ほどの2つの隣接行列の相関を調べる。まず、順位差を入れた隣接行列を作成する。 data.frame(ID = colnames(presence_mat), rank = c(8,9,11,12,1,2,3,5,4,14,15,13,6,7,10)) -&gt; rank crossing(ID1 = colnames(presence_mat), ID2 = colnames(presence_mat)) %&gt;% left_join(rank, by = c(&quot;ID1&quot; = &quot;ID&quot;)) %&gt;% left_join(rank, by = c(&quot;ID2&quot; = &quot;ID&quot;)) %&gt;% mutate(rank_diff = abs(rank.x - rank.y)) %&gt;% select(ID1,ID2,rank_diff) %&gt;% mutate(rank_diff = as.numeric(rank_diff)) %&gt;% pivot_wider(names_from = ID2, values_from = rank_diff) %&gt;% column_to_rownames(var = &quot;ID1&quot;) %&gt;% as.matrix() -&gt; rank_mat 偏相関係数の検定は、veganパッケージのmantel.partial関数で行うことができる。結果は、順位を統制しても毛づくろいネットワークとSRIネットワークに有意な相関はない。 mantel.partial(groom_mat_b2, presence_mat, ## 統制する隣接行列 zdis = rank_mat, ## パーミュテーション回数 permutations = 1000) ## ## Partial Mantel statistic based on Pearson&#39;s product-moment correlation ## ## Call: ## mantel.partial(xdis = groom_mat_b2, ydis = presence_mat, zdis = rank_mat, permutations = 1000) ## ## Mantel statistic r: -0.03687 ## Significance: 0.71229 ## ## Upper quantiles of permutations (null model): ## 90% 95% 97.5% 99% ## 0.0863 0.0998 0.1174 0.1387 ## Permutation: free ## Number of permutations: 1000 4.2.2.2.1.2 Hemelrijkの行列相関検定 ヘメリック(Hemelrijk, 1990a; Hemelrijk, 1990b)は、霊長類において互恵性が存在するかを検討するために、Kendallの順位相関係数を発展させたKr検定を考案している。この方法もnode permutationを用いたもので、方向性のある隣接行列も扱うことができる。詳細はヘメリックの論文を参照されたし(Hemelrijk, 1990a; Hemelrijk, 1990b)。ANTsパッケージのstat.tauKr関数はこの方法に基づく行列相関検定を行ってくれる。 例えば、群れ内において毛づくろいの互恵性が成立しているか、つまり各ダイアッドが毛づくろいを交換しているかを調べたいとしよう。そのためには、方向性のある毛づくろい頻度隣接行列groom_mat(表2.2)とその転置行列(行と列を入れ替えた行列)の相関があるかを調べればよい。そうすれば、ある個体にたくさん毛づくろいをしているほど、その相手からも毛づくろいされているか、を調べることができる。転置行列はt()関数で求められる。 分析の結果は以下のようになる。pRとpLはランダムなネットワークの相関係数が実際の相関係数より大きい/小さい確率を表す。この結果から、両者の間には有意な相関があり、毛づくろいの互恵性が成り立っていることが示唆される。つまり、毛づくろいをたくさん行うほど、その個体から毛づくろいをされている。 stat.tauKr(X = groom_mat, ## 転置行列 Y = t(groom_mat), ## 対角成分は含まない omitDiag = TRUE, ## node permutationの回数 nperm = 1000) ## $tau ## [1] 0.7155429 ## ## $pR ## [1] 0.000999001 ## ## $pL ## [1] 1 Kr検定では、第3の要因を統制した偏相関係数を検定することもできる。例えば、毛づくろいの互恵性が血縁度の影響を統制したうえでも成立するかを調べたいとする。 まず、各ダイアッドの血縁度をまとめた隣接行列を読み込み、行名と列名の順番をgroom_matに合わせる。 kin_mat &lt;- read.csv(&quot;data/kin_demo.csv&quot;, row.names = 1) %&gt;% mutate(across(1:17, ~{as.double(.x)})) %&gt;% as.matrix() kin_mat &lt;- kin_mat[sort(colnames(groom_mat)),sort(rownames(groom_mat))] diag(kin_mat) &lt;- 0 Kr検定の偏相関係数バージョンは以下のように行うことができる。Tauxyzが偏相関係数の値を表す。血縁度を統制したうえでも、毛づくろいの互恵性は成立していることがわかる。 stat.tauKr(X = groom_mat, Y = t(groom_mat), ## 統制する要因の隣接行列 Z = kin_mat, ## 対角成分は含まない omitDiag = TRUE, ## node permutationの回数 nperm = 1000) ## WARNING: Error exit, tauk2. IFAULT = 12 ## WARNING: Error exit, tauk2. IFAULT = 12 ## $Tauxy ## [1] 0.7155429 ## ## $Tauxz ## [1] 0.6010751 ## ## $Tauyz ## [1] 0.5194072 ## ## $Tauxyz ## [1] 0.5906012 ## ## $pR ## [1] 0.000999001 ## ## $pL ## [1] 1 同様の分析は、異なる行動から算出した2つの隣接行列に対しても適用できる。他の例については、 Hemelrijk (1990b) , Hemelrijk (1990a) , D. Croft et al. (2008) などを参照。 4.2.2.2.2 ネットワークデータを用いた回帰分析 ネットワーク相関は有用な方法だが、2つ以上の変数を統制したい場合には用いることができない。また、相関分析では様々な形式のデータ(0/1データ、割合データ)などを扱う際に問題が生じることもある。これらの問題点を解決してくれるのが、MRQAP検定(Dekker et al., 2007)と呼ばれる手法である。MRQAP検定は、簡単に言ってしまえばネットワークデータを用いた回帰分析である。Mantel検定などと同様に、2つ以上の隣接行列の対応する行列成分に対して回帰分析を施す。 例えば、第2章で算出したSRI隣接行列(表2.4)が、親密度(CSI)、血縁度、順位差と関連しているかを調べたいとする。MRQAPでは、通常のGLMやGLMMと同様に、こうした複数の隣接行列を用いた回帰分析を行うことができる(図4.8)。また、aninetパッケージのglmqap関数を用いれば、応答変数となる隣接行列の分布として様々なもの(e.g., 正規分布、ポワソン分布、二項分布など)を仮定することができるので、データ形式に合った適切な分析を行うこともできる。 図4.8: MRQAP検定のイメージ図 MRQAP検定では、通常のnode permutationを発展させたdouble semi-partialing (DSP)法を用いて係数の有意性を判定する。この方法では、回帰分析をした際の残差に対してnode permutationを行うことでP値を算出する。少し複雑なので、詳しい説明は Dekker et al. (2007) や、 Borgatti et al. (2022) を参照。DSP法を用いれば、強い多重共線性がある場合でも、正確にP値を算出することができる。 それでは、実際に第2章で算出したSRIが、メス間の親密度(CSI)、血縁度、順位差の影響を受けるかを検討してみよう。ここでは、先ほども用いたメス同士の毛づくろい頻度groom_mat_b2と近接時間割合を用いてCSIを算出するとする。CSIは以下の式で算出される(Silk et al., 2006)。ただし、\\(N\\)はメス個体数である。 \\(G_{ij}\\): メス\\(i\\)とメス\\(j\\)の毛づくろい時間割合 \\(P_{ij}\\): メス\\(i\\)とメス\\(j\\)の近接時間割合 \\(\\overline{G}: \\frac{1}{N} \\sum^{N}_{i=1}G_{ij}\\) \\(\\overline{P}: \\frac{1}{N} \\sum^{N}_{i=1}P_{ij}\\) \\[ CSI_{ij} = \\frac{\\left(\\frac{G_{i}}{\\overline{G}} +\\frac{P_{i}}{\\overline{P}}\\right)}{2} \\] まず、メス間の近接時間割合を記した隣接行列を読み込み、行と列をアルファベット順に並べ替える。 ## 読み込み prox_mat &lt;- read.csv(&quot;data/prox_f.csv&quot;, row.names = 1) %&gt;% as.matrix() ## 並べ替え prox_mat &lt;- prox_mat[sort(rownames(groom_mat_b2)), sort(colnames(groom_mat_b2))] diag(prox_mat) &lt;- 0 CSIは、aninetパッケージのdyadic_csi関数で以下のように簡単に求めることができる。 library(aninet) list &lt;- list(groom_mat_b2, prox_mat) CSI_mat &lt;- dyadic_csi(list) ## 列名と行名を追加 colnames(CSI_mat) &lt;- colnames(prox_mat) rownames(CSI_mat) &lt;- rownames(prox_mat) CSIの隣接行列は以下のようになる(表4.3)。 表4.3: CSIの隣接行列 Aka Ako Hen Hot Kil Kit Koh Kor Kun Mal Mei Mik Ntr Ten Tot Aka 0.00 11.46 0.13 0.77 0.18 0.05 0.66 0.24 0.21 0.12 1.12 0.48 0.73 0.89 0.27 Ako 11.46 0.00 1.14 0.31 0.31 0.49 0.26 0.93 0.31 0.14 2.48 0.34 1.08 1.23 0.51 Hen 0.13 1.14 0.00 0.99 0.19 0.42 0.30 0.51 0.20 1.41 1.49 0.71 0.74 0.83 0.85 Hot 0.77 0.31 0.99 0.00 0.18 0.16 0.07 0.25 0.69 0.70 0.43 0.56 0.08 0.54 1.72 Kil 0.18 0.31 0.19 0.18 0.00 5.69 3.10 0.89 1.39 0.24 0.20 0.56 0.60 0.62 0.34 Kit 0.05 0.49 0.42 0.16 5.69 0.00 3.88 1.39 1.30 0.16 0.30 0.45 0.82 0.61 0.58 Koh 0.66 0.26 0.30 0.07 3.10 3.88 0.00 2.77 1.58 0.18 0.21 0.43 0.35 0.31 0.57 Kor 0.24 0.93 0.51 0.25 0.89 1.39 2.77 0.00 1.31 0.35 0.46 1.27 2.16 1.67 2.94 Kun 0.21 0.31 0.20 0.69 1.39 1.30 1.58 1.31 0.00 0.88 0.06 1.14 0.42 0.59 0.11 Mal 0.12 0.14 1.41 0.70 0.24 0.16 0.18 0.35 0.88 0.00 1.30 6.32 0.40 0.92 1.63 Mei 1.12 2.48 1.49 0.43 0.20 0.30 0.21 0.46 0.06 1.30 0.00 1.06 1.22 0.68 0.33 Mik 0.48 0.34 0.71 0.56 0.56 0.45 0.43 1.27 1.14 6.32 1.06 0.00 1.11 1.19 0.34 Ntr 0.73 1.08 0.74 0.08 0.60 0.82 0.35 2.16 0.42 0.40 1.22 1.11 0.00 2.43 1.06 Ten 0.89 1.23 0.83 0.54 0.62 0.61 0.31 1.67 0.59 0.92 0.68 1.19 2.43 0.00 1.25 Tot 0.27 0.51 0.85 1.72 0.34 0.58 0.57 2.94 0.11 1.63 0.33 0.34 1.06 1.25 0.00 順位差の隣接行列も読み込み、同様に列名と行名をアルファベット順にする。 ## 読み込み rank_mat &lt;- read.csv(&quot;data/rank_demo.csv&quot;, row.names = 1) %&gt;% as.matrix() ## 並び替え rank_mat &lt;- rank_mat[sort(colnames(CSI_mat)), sort(rownames(CSI_mat))] diag(rank_mat) &lt;- 0 先ほど読み込んだ血縁度の隣接行列から、SRI隣接行列に存在しない個体KurとTamを除く。 kin_mat_b &lt;- kin_mat[-c(10,15),-c(10,15)] それでは、MRQAP検定に移ろう。SRIは0~1の間をとる割合データであるため、応答変数の分布は二項分布とする。分析には、aninetパッケージを用いる(Franks et al., 2021)。 二項分布を仮定した分析では、SRIを算出した際の分母が必要になる。get_denominator関数で算出できる。 denom &lt;- get_denominator(## 第2章で使用したgroup by individual形式のデータ presence %&gt;% dplyr::select(-date), ## HWIを算出したなら&quot;HWI&quot; index = &quot;SRI&quot;, ## 隣接行列の形式で出力.ベクトル形式なら&quot;vector&quot;。 return = &quot;matrix&quot;) ## アルファベット順に並び替え denom &lt;- denom[sort(rownames(CSI_mat)),sort(colnames(CSI_mat))] 分析は以下の通り。 ## 出力があまりに長くなってしまうので、すでに出した結果を読み込む #r_qap &lt;- glmqap(presence_mat ~ CSI_mat + rank_mat + kin_mat_b, # ## 分母の隣接行列 # weights = denom, # ## 分布は二項分布、ポワソン分布なら&quot;poisson&quot;、正規分布なら&quot;gaussian&quot;。 # family = &quot;binomial&quot;, # ## パーミュテーションの回数 # nperm = 1000, # ## パーミュテーションの方法。通常はDSP法 # permutation = &quot;DSP&quot;) r_qap &lt;- readRDS(&quot;output/r_qap.rds&quot;) 結果は以下の通り。P値は、P(two-tailed)というところに書いてある。CSI、血縁度、順位差のいずれもSRIとは有意に関連していないという結果になった。 r_qap ## GLMQAP with Doube-Semi-Partialling ## ## Formula: presence_mat ~ CSI_mat + rank_mat + kin_mat_b ## Family: binomial ## Weights: denom ## Offset: NULL ## Permutations: 1000 ## ## Coefficients: ## Estimate Std. Error Z P(two-tailed) ## Intercept 1.3216348913 0.0614308474 ## CSI_mat -0.0291975665 0.0257974756 -1.1317993673 0.8011988012 ## rank_mat -0.0172087483 0.0080241535 -2.1446185470 0.7732267732 ## kin_mat_b 0.0001895603 0.4175293743 0.0004540047 0.9790209790 ## ## log-likelihood: -1277.55 AIC: 2563.1 BIC: 2573.716 4.2.3 Node permutationの欠点 以上でみたように、node permutationは2つ以上の変数の関連を調べるうえで強力な方法である。一方で、この方法は観察にバイアスがあるときや、観察場所/時間の影響があるとき5には、誤った結論を導いてしまう可能性が高くなる(Farine, 2017; Farine &amp; Carter, 2022; Weiss et al., 2021)。 分析するモデルにこれらの要因(観察回数や行動圏の重複度合いなど)を限り取り入れることで、誤った結論を導いてしまう可能性を低減することはできるがWeiss et al. (2021)、すべての場合に対処できるわけではないようだ(Farine &amp; Carter, 2022)。この問題を解決するうえでは、次節で説明する pre-network permutation が有効な手段だと考えられている(Farine, 2017; Farine &amp; Carter, 2022; Farine &amp; Whitehead, 2015)。一方で、pre-network permutation も相関分析や回帰分析を行う上で問題点を抱えていることがわかってきている(Farine &amp; Carter, 2022; Puga‐Gonzalez et al., 2021; Weiss et al., 2021)。これについては、次節で詳述する。 References Borgatti, S. P., Everett, M. G., Johnson, J. C., &amp; Agneessens, F. (2022). Analyzing social networks using R. SAGE. Croft, D. P., Madden, J. R., Franks, D. W., &amp; James, R. (2011). Hypothesis testing in animal social networks. Trends in Ecology and Evolution, 26(10), 502–507. Croft, D., James, R., &amp; Krause, J. (2008). 動物の社会ネットワーク分析 (島田将喜., Trans.). 東海大学出版部. Dekker, D., Krackhardt, D., &amp; Snijders, T. A. B. (2007). Sensitivity of MRQAP tests to collinearity and autocorrelation conditions. Psychometrika, 72(4), 563–581. Dunn, P. K., &amp; Smyth, G. K. (2018). Generalized linear models with examples in R. Springer New York. Farine, D. R. (2017). A guide to null models for animal social network analysis. Methods Ecol. Evol., 8(10), 1309–1320. Farine, D. R., &amp; Carter, G. G. (2022). Permutation tests for hypothesis testing with animal social network data: Problems and potential solutions. Methods Ecol. Evol., 13(1), 144–156. Farine, D. R., &amp; Whitehead, H. (2015). Constructing, conducting and interpreting animal social network analysis. J. Anim. Ecol., 84(5), 1144–1163. Franks, D. W., Weiss, M. N., Silk, M. J., Perryman, R. J. Y., &amp; Croft, D. P. (2021). Calculating effect sizes in animal social network analysis. Methods Ecol. Evol., 12(1), 33–41. Hemelrijk, C. K. (1990a). A matrix partial correlation test used in investigations of reciprocity and other social interaction patterns at group level. J. Theor. Biol., 143(3), 405–420. Hemelrijk, C. K. (1990b). Models of, and tests for, reciprocity, unidirectionality and other social interaction patterns at a group level. Anim. Behav., 39(6), 1013–1029. Mantel, N. (1967). The detection of disease clustering and a generalized regression approach. Cancer Res., 27(2), 209–220. Puga‐Gonzalez, I., Sueur, C., &amp; Sosa, S. (2021). Null models for animal social network analysis and data collected via focal sampling: Pre‐network or node network permutation? Methods Ecol. Evol., 12(1), 22–32. Silk, J. B., Altmann, J., &amp; Alberts, S. C. (2006). Social relationships among adult female baboons (papio cynocephalus) i. Variation in the strength of social bonds. Behav. Ecol. Sociobiol., 61(2), 183–195. Sosa, S., Puga-Gonzalez, I., Hu, F., Pansanel, J., Xie, X., &amp; Sueur, C. (2020). A multilevel statistical toolkit to study animal social networks: The animal network toolkit software (ANTs) R package. Sci. Rep., 10(1), 12507. Weiss, M. N., Franks, D. W., Brent, L. J. N., Ellis, S., Silk, M. J., &amp; Croft, D. P. (2021). Common datastream permutations of animal social network data are not appropriate for hypothesis testing using regression models. Methods Ecol. Evol., 12(2), 255–265. 大東健太郎. (2010). 線形モデルから一般化線形モデル（GLM）へ. 雑草研究, 55(4), 268–274. 例えば、順位の高い個体ほど、あるいはオスの個体ほど発見しやすい/行動が観察しやすい時には、そうした特徴による観察バイアスが生じることになる。また、個体Aと個体Bが一緒に観察される割合が高いとき、それはその2個体が互いに選好しているからではなく、単に観察場所や期間の影響(その場所から移動するのが難しい、たまたま同じ期間に出没することが多かった)があるからという場合がある。↩︎ "],["Chapter4-3.html", "4.3 Pre-network permutation", " 4.3 Pre-network permutation 4.3.1 Pre-network permutationの手法 Node permutationとともによく用いられるパーミュテーションの方法が、pre-network (またはdata stream) permutationである。この方法では、隣接行列(ネットワーク)を作成する前の生データに対してパーミュテーションを行う(Farine, 2017)。 Pre-network permutationは、もともと“group by individual”(第2.2節参照)形式のデータに適用するために考案された手法である(Bejder et al., 1998; Whitehead et al., 1999)。このような形式のデータとしては、下のようなものがあげられる。これは、金華山島\\(B_1\\)群で2021年交尾期の各観察日(date)にそれぞれのメスが群れ内で観察されたか否かを示したものである。1が観察されたこと、0が観察されなかったことを表す。 Pre-network permutationのプロセスを模式的に表したのが図4.9である(Bejder et al., 1998; Whitehead et al., 1999)。以下のプロセスで行う。 “group by individual”形式のデータからランダムに2つのグループ(行)と2個体を選ぶ。ただし、各個体はいずれか一方のグループ(行)のみで確認され、かつ各グループ(行)ではいずれか一方の個体のみしか確認されていないものの中から選ぶ。例えば、図4.9の左の行列の下線の組み合わせがこのような条件を満たす。 2つのグループ(行)における各個体の数値を入れ替える(図4.9の右の行列)。 入れ替えた後のデータをもとにassociation index(e.g., SRIなど)を算出し、隣接行列(ネットワーク)を作成する。 2~3の過程を少なくとも1000回繰り返す。ただし、各ステップで入れ替えを行うデータは、前のステップで入れ替えを行った後のデータである。例えば図4.9では、次のステップにおいては右の行列(= 前のステップで入れ替えた後のデータ)に対してランダムな入れ替えを同様に行う。 図4.9: Pre-network permutationのプロセス。Whitehead et al. (1999)から引用。 この方法を用いることで、各グループ(行)で確認された個体数と、各個体が確認された回数を保ったままランダムなネットワークを無数に生成することができる(Farine, 2017)。また、ランダムに選ぶ2個体を同じ属性(e.g., 性別)の個体に限定したり、観察が複数の調査期間/場所で行われた際にそれぞれの調査期間/場所内で入れ替えを行ったりすることで、node permutationで問題となっていた観察バイアスや観察場所・期間の影響を排除することができる(Whitehead et al., 2005)。 検定を行う際には、node permutationのときと同様に、実データをもとに算出した統計検定量と、各ステップでランダムな入れ替えによって生成されたデータから算出された統計検定量の分布を比較することでP値を算出する。 なお、pre-network permutationは近年適用範囲が広がり、“group by individual”形式のデータだけでなく、GPSデータや個体追跡データに対しても適用できるようになってきている。詳しい方法については、Farine (2017) を参照。 4.3.2 分析例 Pre-network permutationを用いた分析は、node permutationで行ったすべての分析(線形モデル、相関分析、MRQAP検定など)に対して適用することができる。 ここでは、簡単な例としてGLMによる分析を行う。 下のデータは、金華山島\\(B_1\\)群で2019～2021年において、各観察日(date)に各メスが観察されたか否かを”group by individual”形式で示したものである(presence_multi)。 このデータを用いてSRI(第2.2節参照)を算出し、SRIネットワークにおける各個体の固有ベクトル中心性(eigen)が順位(rank)と年齢(age)と関連するかを調べたいとする。 なお、pre-network permutationは、各観察年(period)内で行うものとする。 ここでは、以下のような一般化線形モデルを考える。 分布: ガンマ分布 リンク関数: log関数 応答変数: 固有ベクトル中心性(eigen) 説明変数: 順位(rank)、年齢(age) 4.3.2.1 snaパッケージを用いる方法 まずは実データからSRIを算出して隣接行列を作成する(第2.2参照)。 ## presence_mat_multi &lt;- get_network(presence_multi ## 日付と調査期間は除く %&gt;% select(-date, -period), data_format = &quot;GBI&quot;, association_index = &quot;SRI&quot;) ## Generating 15 x 15 matrix そこからANTsパッケージで固有ベクトル中心性を算出し(第3.1節参照)、メスの属性データに追加する。 ## 属性データ att_females &lt;- data.frame(femaleID = colnames(prox_mat), rank = c(8,9,11,12,1,2,3,5,4,13,15,14,6,7,10), age = c(12,9,10,10,14,7,12,8,6,8,10,15, 10, 10, 10)) att_eigen &lt;- met.eigen(presence_mat_multi, df = att_females, dfid = 1) 算出したものがこちら。 その後、node permutationの時と同様に実データに対してモデリングを行い、統計検定量(= 係数の推定値)を求める。 r_glm_org &lt;- glm(data = att_eigen, formula = eigen ~ rank + age, family = Gamma(&quot;log&quot;)) 推定結果は以下のようになる。 r_glm_org ## ## Call: glm(formula = eigen ~ rank + age, family = Gamma(&quot;log&quot;), data = att_eigen) ## ## Coefficients: ## (Intercept) rank age ## 0.237425 -0.006943 -0.027929 ## ## Degrees of Freedom: 14 Total (i.e. Null); 12 Residual ## Null Deviance: 0.3288 ## Residual Deviance: 0.247 AIC: -14.21 係数の推定値を抽出する。 b_rank &lt;- coef(r_glm_org)[[2]] b_age &lt;- coef(r_glm_org)[[3]] それでは、pre-network permutationを行い、それによって生成されたランダムなネットワークに対しても同様の分析を行って係数の推定値を抽出していく。パーミュテーションは10000回行うものとする。 snaパッケージでは、random_permutation関数を用いてpre-network permutationを行うことができる。関数では、locations =、days =にデータの各行の観察場所/時間を、classes =に各個体の属性を指定できる。そのうえで、within_location = TRUE、within_day = TRUE、within_class = TRUEとすることで、各観察場所/期間内、あるいは同じ属性の個体同士でしかデータの入れ替えが行われないようにすることができる。今回は各観察年内で入れ替えを行うので、days = periodとし、within_period = TRUEとする。 period &lt;- presence_multi$period set.seed(123) presence_mat_rand &lt;- network_permutation(presence_multi %&gt;% select(-date,-period), data_format = &quot;GBI&quot;, association_index = &quot;SRI&quot;, #パーミュテーション回数 permutations = 10000, days = period, within_day = TRUE) ## No association matrix provided, generating 15 x 15 matrix ## Generating 15 x 15 matrix ## Starting permutations, generating 10000 x 15 x 15 matrix これで、ランダムなネットワークが10000個生成された。例えば、120個目のネットワークの隣接行列は以下のようになる(表4.4)。 presence_mat_rand[120, , ] %&gt;% kable(digits = 2, align = &quot;c&quot;, caption = &quot;120個目の隣接行列&quot;) %&gt;% kable_styling(font_size = 6, full_width = FALSE) 表4.4: 120個目の隣接行列 0.00 0.63 0.46 0.44 0.47 0.47 0.53 0.45 0.45 0.47 0.45 0.54 0.45 0.46 0.46 0.63 0.00 0.65 0.61 0.65 0.67 0.74 0.66 0.65 0.65 0.65 0.52 0.63 0.66 0.68 0.46 0.65 0.00 0.89 0.90 0.92 0.82 0.93 0.95 0.84 0.95 0.57 0.86 0.91 0.85 0.44 0.61 0.89 0.00 0.83 0.85 0.75 0.87 0.88 0.80 0.88 0.54 0.79 0.84 0.81 0.47 0.65 0.90 0.83 0.00 0.94 0.86 0.90 0.90 0.88 0.92 0.63 0.81 0.90 0.81 0.47 0.67 0.92 0.85 0.94 0.00 0.86 0.92 0.94 0.86 0.94 0.60 0.84 0.90 0.84 0.53 0.74 0.82 0.75 0.86 0.86 0.00 0.85 0.83 0.85 0.83 0.57 0.75 0.84 0.80 0.45 0.66 0.93 0.87 0.90 0.92 0.85 0.00 0.97 0.82 0.96 0.58 0.85 0.93 0.87 0.45 0.65 0.95 0.88 0.90 0.94 0.83 0.97 0.00 0.83 0.96 0.57 0.87 0.94 0.87 0.47 0.65 0.84 0.80 0.88 0.86 0.85 0.82 0.83 0.00 0.83 0.54 0.75 0.81 0.80 0.45 0.65 0.95 0.88 0.92 0.94 0.83 0.96 0.96 0.83 0.00 0.58 0.88 0.94 0.87 0.54 0.52 0.57 0.54 0.63 0.60 0.57 0.58 0.57 0.54 0.58 0.00 0.57 0.60 0.56 0.45 0.63 0.86 0.79 0.81 0.84 0.75 0.85 0.87 0.75 0.88 0.57 0.00 0.84 0.86 0.46 0.66 0.91 0.84 0.90 0.90 0.84 0.93 0.94 0.81 0.94 0.60 0.84 0.00 0.84 0.46 0.68 0.85 0.81 0.81 0.84 0.80 0.87 0.87 0.80 0.87 0.56 0.86 0.84 0.00 それでは、各ランダムネットワークに対してモデリングを行い、係数の推定値を抽出していく。b_rank_randとb_rank_ageという空のベクトルを作成し、そこにランダムネットワークから算出された係数の推定値を入れている。 ## 空の行列を作成 b_rank_rand &lt;- rep(0,10000) b_age_rand &lt;- rep(0,10000) for(i in 1:10000){ att_eigen_rand &lt;- met.eigen(presence_mat_rand[i,,], df = att_females) r_glm_rand &lt;- glm(data = att_eigen_rand, formula = eigen ~ rank + age, family = Gamma(&quot;log&quot;)) b_rank_rand[i] &lt;- coef(r_glm_rand)[[2]] b_age_rand[i] &lt;- coef(r_glm_rand)[[3]] } それでは、最後に実データの回帰係数をランダムネットワークの回帰係数の分布と比較する(図4.10)。灰色のヒストグラムがランダムネットワークの回帰係数の分布を、赤い線が実データの回帰係数を表している。 図4.10: 実データの回帰係数とランダムネットワークの回帰係数の分布の比較 そこで、実データの回帰係数がランダムネットワークの回帰係数の何%より大きいか/小さいかを計算することで、\\(P\\)値を算出する。 算出は以下のように行える。 順位の係数については、P = 0.067なので、有意な関連はないよう(有意傾向)。 p_rank &lt;- sum(b_rank &gt; b_rank_rand)/10000 p_rank ## [1] 0.0674 一方で、年齢の係数(\\(\\beta_2\\))については、P = 0.000なので、有意である。 p_age &lt;- sum(b_age &gt; b_age_rand)/10000 p_age ## [1] 0 4.3.2.2 ANTsパッケージを用いる方法 ANTsパッケージでも同じ同様の分析を行うことができる。ANTsパッケージではpre-network permutationを行う前に”group by individual”形式のデータをgbi.to.df関数で以下のように縦長のデータフレーム(presence_df)に直す必要がある。 ## まずはマトリックスに直す。 presence_multi %&gt;% column_to_rownames(var = &quot;date&quot;) %&gt;% select(-period) %&gt;% as.matrix()-&gt; presence_multi_b ## gbi.to.df関数でデータフレーム形式に presence_df &lt;- gbi.to.df(presence_multi_b) ## periodを追加 presence_df %&gt;% mutate(period = ifelse(year(scan) == &quot;2019&quot;,1, ifelse(year(scan) == &quot;2020&quot;,2,3))) -&gt; presence_df このように、データフレームには観察した日付(scan)と観察された個体の名前(ID)が記されている。 presence_df %&gt;% datatable(rownames = FALSE) このデータフレームをもとに、perm.ds.grp関数でパーミュテーションを行うことができる。この際、ctrlf = periodと指定することで、各観察年内で入れ替えを行うことができる。 set.seed(123) perm_ds &lt;- perm.ds.grp(presence_df_b, ## 観察日 scan = &quot;scan&quot;, ## パーミュテーション回数 nperm = 10000, ctrlf = &quot;period&quot;, index = &quot;sri&quot;, progress = FALSE) これで、実データにもとづくネットワーク(隣接行列)1つと、ランダムネットワークが10000個生成された。各ネットワークにおける固有ベクトル中心性を算出し、それぞれをメスの属性データに追加していく。 ## メスの属性データ att_females &lt;- data.frame(femaleID = colnames(prox_mat), rank = c(8,9,11,12,1,2,3,5,4,13,15,14,6,7,10), age = c(12,9,10,10,14,7,12,8,6,8,10,15, 10, 10, 10)) att_eigen_list &lt;- met.eigen(perm_ds, df = att_females, dfid = 1) 続いてstat.glm関数を用い、実データとランダムネットワークにおけるデータに対してモデリングを行い、パラメータの推定値を算出する。 glm_ants &lt;- stat.glm(ant = att_list, formula = eigen ~ age + rank, family = Gamma(link = &quot;log&quot;), ## 実データのデータフレーム oda = presence_df, progress = FALSE) ## Original model : ## ## ## Call: ## c(&quot;eigen ~ age + rank , family = Gamma&quot;, &quot;eigen ~ age + rank , family = log&quot;, ## &quot;eigen ~ age + rank , family = function (mu) \\nlog(mu)&quot;, &quot;eigen ~ age + rank , family = function (eta) \\npmax(exp(eta), .Machine$double.eps)&quot;, ## &quot;eigen ~ age + rank , family = function (mu) \\nmu^2&quot;, &quot;eigen ~ age + rank , family = function (y, mu, wt) \\n-2 * wt * (log(ifelse(y == 0, 1, y/mu)) - (y - mu)/mu)&quot;, ## &quot;eigen ~ age + rank , family = function (y, n, mu, wt, dev) \\n{\\n n &lt;- sum(wt)\\n disp &lt;- dev/n\\n -2 * sum(dgamma(y, 1/disp, scale = mu * disp, log = TRUE) * wt) + 2\\n}&quot;, ## &quot;eigen ~ age + rank , family = function (eta) \\npmax(exp(eta), .Machine$double.eps)&quot;, ## &quot;eigen ~ age + rank , family = expression({\\n if (any(y &lt;= 0)) \\n stop(\\&quot;non-positive values not allowed for the &#39;Gamma&#39; family\\&quot;)\\n n &lt;- rep.int(1, nobs)\\n mustart &lt;- y\\n})&quot;, ## &quot;eigen ~ age + rank , family = function (mu) \\nall(is.finite(mu)) &amp;&amp; all(mu &gt; 0)&quot;, ## &quot;eigen ~ age + rank , family = function (eta) \\nTRUE&quot;, &quot;eigen ~ age + rank , family = function (object, nsim) \\n{\\n wts &lt;- object$prior.weights\\n if (any(wts != 1)) \\n message(\\&quot;using weights as shape parameters\\&quot;)\\n ftd &lt;- fitted(object)\\n shape &lt;- MASS::gamma.shape(object)$alpha * wts\\n rgamma(nsim * length(ftd), shape = shape, rate = shape/ftd)\\n}&quot; ## ) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -0.37057 -0.04053 0.01389 0.06207 0.14965 ## ## Coefficients: ## Estimate Std. Error t value ## (Intercept) 0.237425 0.159228 1.491 ## age -0.027929 0.014937 -1.870 ## rank -0.006943 0.008129 -0.854 ## ## (Dispersion parameter for Gamma family taken to be 0.01815169) ## ## Null deviance: 0.32879 on 14 degrees of freedom ## Residual deviance: 0.24701 on 12 degrees of freedom ## AIC: -14.212 ## ## Number of Fisher Scoring iterations: 5 ## ## in 分析結果は、ant関数を用いることで確認できる。 実データの回帰係数とランダムネットワークの回帰係数の分布の比較は以下のように可視化できる(図4.11)。 r_glm_ants &lt;- ant(glm_ants) 図4.11: 実データの回帰係数とランダムネットワークの回帰係数の分布の比較 検定結果は以下の通り。p.leftとp_rightはランダムネットワークの係数が実際の係数よりも小さい/大きい確率を表す。snaパッケージを用いた場合と少し異なる結果が得られており、順位の関連も有意である。この違いはパッケージごとのアルゴリズムの違いに起因？ r_glm_ants$model ## ## Call: ## c(&quot;eigen ~ age + rank , family = Gamma&quot;, &quot;eigen ~ age + rank , family = log&quot;, ## &quot;eigen ~ age + rank , family = function (mu) \\nlog(mu)&quot;, &quot;eigen ~ age + rank , family = function (eta) \\npmax(exp(eta), .Machine$double.eps)&quot;, ## &quot;eigen ~ age + rank , family = function (mu) \\nmu^2&quot;, &quot;eigen ~ age + rank , family = function (y, mu, wt) \\n-2 * wt * (log(ifelse(y == 0, 1, y/mu)) - (y - mu)/mu)&quot;, ## &quot;eigen ~ age + rank , family = function (y, n, mu, wt, dev) \\n{\\n n &lt;- sum(wt)\\n disp &lt;- dev/n\\n -2 * sum(dgamma(y, 1/disp, scale = mu * disp, log = TRUE) * wt) + 2\\n}&quot;, ## &quot;eigen ~ age + rank , family = function (eta) \\npmax(exp(eta), .Machine$double.eps)&quot;, ## &quot;eigen ~ age + rank , family = expression({\\n if (any(y &lt;= 0)) \\n stop(\\&quot;non-positive values not allowed for the &#39;Gamma&#39; family\\&quot;)\\n n &lt;- rep.int(1, nobs)\\n mustart &lt;- y\\n})&quot;, ## &quot;eigen ~ age + rank , family = function (mu) \\nall(is.finite(mu)) &amp;&amp; all(mu &gt; 0)&quot;, ## &quot;eigen ~ age + rank , family = function (eta) \\nTRUE&quot;, &quot;eigen ~ age + rank , family = function (object, nsim) \\n{\\n wts &lt;- object$prior.weights\\n if (any(wts != 1)) \\n message(\\&quot;using weights as shape parameters\\&quot;)\\n ftd &lt;- fitted(object)\\n shape &lt;- MASS::gamma.shape(object)$alpha * wts\\n rgamma(nsim * length(ftd), shape = shape, rate = shape/ftd)\\n}&quot; ## ) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -0.37057 -0.04053 0.01389 0.06207 0.14965 ## ## Coefficients: ## Estimate Std. Error t value p.left p.rigth p.one.side ## (Intercept) 0.237425 0.159228 1.491102 0.999000 0.001000 0.002000 ## age -0.027929 0.014937 -1.869800 0.000000 1.000000 0.000000 ## rank -0.006943 0.008129 -0.854057 0.014000 0.986000 0.028000 ## lower.ci uper.ci mean ## (Intercept) 0.196741 0.215635 0.206 ## age -0.025772 -0.023820 -0.025 ## rank -0.006612 -0.005626 -0.006 ## ## (Dispersion parameter for Gamma family taken to be 0.01815169) ## ## Null deviance: 0.32879 on 14 degrees of freedom ## Residual deviance: 0.24701 on 12 degrees of freedom ## AIC: -14.212 ## ## Number of Fisher Scoring iterations: 5 4.3.3 Pre-network permutationの欠点 以上のように、pre-network permutationは観察バイアスや観察場所/期間の影響を排除することのできる強力な手法であり、多くの研究で用いられている(Farine, 2017; Farine &amp; Carter, 2022; Farine &amp; Whitehead, 2015)。一方で、ここ数年の研究によってpre-network permutationは相関分析や回帰分析の検定を行う手法としては適切でないことが指摘されるようになっている(Farine &amp; Carter, 2022; Puga‐Gonzalez et al., 2021; Weiss et al., 2021)。 回帰分析を例にとって考えてみよう。回帰分析の目的は説明変数(X)と応答変数(Y)に関連があるかを調べることなので、その帰無仮説は「両者の間に関連がない(\\(\\beta = 0\\))」である。Node permutationでは隣接行列の行と列に対してパーミュテーションを行うことで、ネットワークの構造自体は保ちつつ、XとYの関連がランダムなネットワークを作り出すことができていた(第4.1節と第4.2節を参照)。 一方で、pre-network permutationは生のassociation/交渉データに対してパーミュテーションを行うので、ネットワークの構造自体に大きな変化が生じてしまい、辺の重みや中心性指標の分布が大きく変わってしまう(Weiss et al., 2021)。その結果、現実世界における辺の重みや中心性指標の分布からは乖離してしまい、適切な帰無分布にならなくなってしまう可能性がある(Farine &amp; Carter, 2022)。一般的に、pre-network permutationによって辺の重みや中心性指標の分布のばらつきは小さくなってしまうので(つまり、実際のデータの値のほうが極端になる傾向があるので)、第一種の過誤を犯す確率が高くなってしまう(図4.12)。 図4.12: Pre-network permutationを繰り返すことで値の分布のばらつきが小さくなる。Weiss et al. (2021)から引用。 この問題を解消するため、Farine &amp; Carter (2022) はnode permutationとpre-network permutationの手法を組み合わせたdouble permutation法を提唱し、この手法を用いることでそれぞれの手法を単独で用いるよりも誤った結論を導いてしまう可能性が低くなることを指摘している。一方で Weiss et al. (2021) は、①Generalized affiliation indicesなどの交絡要因をはじめから除外できる指標を用いること、②観察バイアスや観察場所や期間の情報を明示的にモデルに取り込むこと(e.g., 観察回数を説明変数に入れたり、ランダム効果に場所や期間を入れるなど)(c.f. Franks et al., 2021)でnode permutationだけでも適切な検定ができることを指摘している。 いずれにしても、ここ数年だけでもパーミュテーション検定の妥当性を検証する論文が多数出ていることからもわかるように(Evans et al., 2020; Farine &amp; Carter, 2022; Franks et al., 2021; Hart et al., 2022; Puga‐Gonzalez et al., 2021; Weiss et al., 2021)、どのような分析方法が最も適切かについてはまだ結論が出ていないのが現状だ。今後新たにどのような検証結果が出るかに注視していく必要があるだろう。 References Bejder, L., Fletcher, D., &amp; BrÄger, S. (1998). A method for testing association patterns of social animals. Anim. Behav., 56(3), 719–725. Evans, J. C., Fisher, D. N., &amp; Silk, M. J. (2020). The performance of permutations and exponential random graph models when analyzing animal networks. Behav. Ecol., 31(5), 1266–1276. Farine, D. R. (2017). A guide to null models for animal social network analysis. Methods Ecol. Evol., 8(10), 1309–1320. Farine, D. R., &amp; Carter, G. G. (2022). Permutation tests for hypothesis testing with animal social network data: Problems and potential solutions. Methods Ecol. Evol., 13(1), 144–156. Farine, D. R., &amp; Whitehead, H. (2015). Constructing, conducting and interpreting animal social network analysis. J. Anim. Ecol., 84(5), 1144–1163. Franks, D. W., Weiss, M. N., Silk, M. J., Perryman, R. J. Y., &amp; Croft, D. P. (2021). Calculating effect sizes in animal social network analysis. Methods Ecol. Evol., 12(1), 33–41. Hart, J. D. A., Weiss, M. N., Brent, L. J. N., &amp; Franks, D. W. (2022). Common permutation methods in animal social network analysis do not control for non-independence. Behav. Ecol. Sociobiol., 76(11), 151. Puga‐Gonzalez, I., Sueur, C., &amp; Sosa, S. (2021). Null models for animal social network analysis and data collected via focal sampling: Pre‐network or node network permutation? Methods Ecol. Evol., 12(1), 22–32. Weiss, M. N., Franks, D. W., Brent, L. J. N., Ellis, S., Silk, M. J., &amp; Croft, D. P. (2021). Common datastream permutations of animal social network data are not appropriate for hypothesis testing using regression models. Methods Ecol. Evol., 12(2), 255–265. Whitehead, H., Bejder, L., &amp; Ottensmeyer, C. A. (1999). Testing association patterns of social animals. Anim. Behav., 57(5), 26–29. Whitehead, H., Bejder, L., &amp; Ottensmeyer, C. A. (2005). Testing association patterns: Issues arising and extensions. Anim. Behav., 69(5), e1. "],["Chapter4-4.html", "4.4 パーミュテーション検定以外の統計的検定方法", " 4.4 パーミュテーション検定以外の統計的検定方法 前節まではパーミュテーション検定に焦点を当ててネットワークデータの統計的検定の枠組みを説明してきた。この手法はネットワークデータの検定に最もよく使用されるものではあるが、これ以外にも統計的検定の手法は存在する(Farine, 2017; Farine &amp; Carter, 2022)。 4.4.1 指数ランダムグラフモデルと確率的アクター志向モデル パーミュテーション検定以外によく用いられる手法としては、指数ランダムグラフモデル(expoential random graph model: ERGM)があげられる。ERGMは、グラフ上の辺をランダムに除いたり加えたりすることで生じるネットワークの変化をもとに、様々な要因(ノードの属性やノード間の関係)がネットワーク構造に与える影響を調べる手法である。具体的な理論や方法については、鈴木 (2017) や Borgatti et al. (2022) を参照。ERGMがネットワークデータに対する検定方法として不適切であることを指摘する研究者もいる一方で(Farine, 2017)、パーミュテーション検定と同等かそれ以上にうまく機能する手法であると考える研究者もいる(Evans et al., 2020)。 そのほかに経時的なネットワークデータを用いた手法として確率的アクター志向モデル(stochastic actor-oriented model)などもよく用いられる。詳細については 鈴木 (2017) や Borgatti et al. (2022) を参照。 4.4.2 ランダム化を用いない方法 パラメトリックな検定方法であっても、GLMMなどの混合モデルを用いてデータの非独立性や観察バイアスなどの情報をモデルに取り込むことで、パーミュテーション検定よりも適切な分析を行うことができると主張する研究者もいる(Hart et al., 2022)。また、P値ばかりに着目した分析を行うのは望ましくなく、ベイズ統計の枠組みを用いるなどして効果量により焦点を当てた分析を行うべきだという主張もある(Franks et al., 2021; Hart et al., 2022)。今後、パラメトリックな分析方法だけでもネットワークデータを適切に分析できるのかが検証されることが期待される(Farine &amp; Carter, 2022)。 References Borgatti, S. P., Everett, M. G., Johnson, J. C., &amp; Agneessens, F. (2022). Analyzing social networks using R. SAGE. Evans, J. C., Fisher, D. N., &amp; Silk, M. J. (2020). The performance of permutations and exponential random graph models when analyzing animal networks. Behav. Ecol., 31(5), 1266–1276. Farine, D. R. (2017). A guide to null models for animal social network analysis. Methods Ecol. Evol., 8(10), 1309–1320. Farine, D. R., &amp; Carter, G. G. (2022). Permutation tests for hypothesis testing with animal social network data: Problems and potential solutions. Methods Ecol. Evol., 13(1), 144–156. Franks, D. W., Weiss, M. N., Silk, M. J., Perryman, R. J. Y., &amp; Croft, D. P. (2021). Calculating effect sizes in animal social network analysis. Methods Ecol. Evol., 12(1), 33–41. Hart, J. D. A., Weiss, M. N., Brent, L. J. N., &amp; Franks, D. W. (2022). Common permutation methods in animal social network analysis do not control for non-independence. Behav. Ecol. Sociobiol., 76(11), 151. 鈴木努. (2017). R で学ぶデータサイエンス 8 ネットワーク分析 第2版 (金明哲., Ed.). 共立出版. "],["sessioninfo.html", "実行環境", " 実行環境 sessionInfo() ## R version 4.2.2 (2022-10-31 ucrt) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 10 x64 (build 22621) ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=Japanese_Japan.utf8 LC_CTYPE=Japanese_Japan.utf8 ## [3] LC_MONETARY=Japanese_Japan.utf8 LC_NUMERIC=C ## [5] LC_TIME=Japanese_Japan.utf8 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] aninet_0.2.0.0 vegan_2.6-4 lattice_0.20-45 ## [4] permute_0.9-7 fontregisterer_0.3 systemfonts_1.0.4 ## [7] extrafont_0.18 lemon_0.4.6 ggsci_2.9 ## [10] concaveman_1.1.0 ggforce_0.4.1 ggdag_0.2.7 ## [13] dagitty_0.3-1 kableExtra_1.3.4 knitr_1.41 ## [16] DT_0.26 patchwork_1.1.2 data.table_1.14.6 ## [19] see_0.7.4 report_0.5.5 parameters_0.20.0 ## [22] performance_0.10.1 modelbased_0.8.5 insight_0.18.8 ## [25] effectsize_0.8.2 datawizard_0.6.5 correlation_0.8.3 ## [28] bayestestR_0.13.0 easystats_0.6.0 forcats_0.5.2 ## [31] stringr_1.5.0 dplyr_1.0.10 purrr_1.0.0 ## [34] readr_2.1.3 tidyr_1.2.1 tibble_3.1.8 ## [37] tidyverse_1.3.2 hwig_0.0.2 assortnet_0.12 ## [40] clValid_0.7 cluster_2.1.4 igraph_1.3.5 ## [43] ANTs_0.0.1 sna_2.7 network_1.18.0 ## [46] statnet.common_4.7.0 asnipe_1.1.16 ggraph_2.1.0 ## [49] ggplot2_3.4.0 tidygraph_1.2.2 ## ## loaded via a namespace (and not attached): ## [1] readxl_1.4.1 backports_1.4.1 plyr_1.8.8 ## [4] splines_4.2.2 crosstalk_1.2.0 digest_0.6.31 ## [7] htmltools_0.5.4 viridis_0.6.2 fansi_1.0.3 ## [10] magrittr_2.0.3 googlesheets4_1.0.1 tzdb_0.3.0 ## [13] graphlayouts_0.8.4 modelr_0.1.10 Kendall_2.2.1 ## [16] extrafontdb_1.0 svglite_2.1.1 timechange_0.1.1 ## [19] colorspace_2.0-3 rvest_1.0.3 ggrepel_0.9.2 ## [22] haven_2.5.1 xfun_0.36 tcltk_4.2.2 ## [25] crayon_1.5.2 jsonlite_1.8.4 lme4_1.1-31 ## [28] glue_1.6.2 polyclip_1.10-4 gtable_0.3.1 ## [31] gargle_1.2.1 emmeans_1.8.3 webshot_0.5.4 ## [34] V8_4.2.2 Rttf2pt1_1.3.8 scales_1.2.1 ## [37] mvtnorm_1.1-3 DBI_1.1.3 Rcpp_1.0.9 ## [40] viridisLite_0.4.1 xtable_1.8-4 htmlwidgets_1.6.1 ## [43] httr_1.4.4 ellipsis_0.3.2 pkgconfig_2.0.3 ## [46] farver_2.1.1 sass_0.4.4 dbplyr_2.2.1 ## [49] utf8_1.2.2 labeling_0.4.2 tidyselect_1.2.0 ## [52] rlang_1.0.6 munsell_0.5.0 cellranger_1.1.0 ## [55] tools_4.2.2 visNetwork_2.1.2 cachem_1.0.6 ## [58] cli_3.6.0 generics_0.1.3 broom_1.0.2 ## [61] evaluate_0.19 fastmap_1.1.0 yaml_2.3.6 ## [64] fs_1.5.2 nlme_3.1-160 xml2_1.3.3 ## [67] compiler_4.2.2 rstudioapi_0.14 curl_4.3.3 ## [70] reprex_2.0.2 tweenr_2.0.2 bslib_0.4.2 ## [73] stringi_1.7.8 highr_0.10 Matrix_1.5-1 ## [76] nloptr_2.0.3 vctrs_0.5.1 pillar_1.8.1 ## [79] lifecycle_1.0.3 jquerylib_0.1.4 estimability_1.4.1 ## [82] R6_2.5.1 bookdown_0.31 gridExtra_2.3 ## [85] codetools_0.2-18 boot_1.3-28 MASS_7.3-58.1 ## [88] gtools_3.9.4 assertthat_0.2.1 withr_2.5.0 ## [91] mgcv_1.8-41 parallel_4.2.2 hms_1.1.2 ## [94] grid_4.2.2 coda_0.19-4 class_7.3-20 ## [97] minqa_1.2.5 rmarkdown_2.19 googledrive_2.0.0 ## [100] lubridate_1.9.0 References Balasubramaniam, K. N., Beisner, B. A., Berman, C. M., De Marco, A., Duboscq, J., Koirala, S., Majolo, B., Macintosh, A. J. J. J., McFarland, R., Molesti, S., Ogawa, H., Petit, O., Schino, G., Sosa, S., Sueur, C., Thierry, B., Waal, F. B. M. M. de, &amp; McCowan, B. (2018). The influence of phylogeny, social style, and sociodemographic factors on macaque social network structure. Am. J. Primatol., 80(1), e22727. Bejder, L., Fletcher, D., &amp; BrÄger, S. (1998). A method for testing association patterns of social animals. Anim. Behav., 56(3), 719–725. Borgatti, S. P., Everett, M. G., Johnson, J. C., &amp; Agneessens, F. (2022). Analyzing social networks using R. SAGE. Brock, G., Pihur, V., Datta, S., &amp; Datta, S. (2008). clValid: An R package for cluster validation. J. Stat. Softw., 25, 1–22. Butts, C. T. (2008). Social network analysis with sna. J. Stat. Softw., 24, 1–51. Campbell, L. A. D., Tkaczynski, P. J., Lehmann, J., Mouna, M., &amp; Majolo, B. (2018). Social thermoregulation as a potential mechanism linking sociality and fitness: Barbary macaques with more social partners form larger huddles. Sci. Rep., 8(1), 6074. Canteloup, C., Hoppitt, W., &amp; Waal, E. van de. (2020). Wild primates copy higher-ranked individuals in a social transmission experiment. Nat. Commun., 11(1), 459. Chang, W. (2018). R graphics cookbook: Practical recipes for visualizing data. “O’Reilly Media, Inc.” Cheney, D. L., Silk, J. B., &amp; Seyfarth, R. M. (2016). Network connections, dyadic bonds and fitness in wild female baboons. Royal Society Open Science, 3(7), 160255. Croft, D. P., Madden, J. R., Franks, D. W., &amp; James, R. (2011). Hypothesis testing in animal social networks. Trends in Ecology and Evolution, 26(10), 502–507. Croft, D., James, R., &amp; Krause, J. (2008). 動物の社会ネットワーク分析 (島田将喜., Trans.). 東海大学出版部. Csardi, G., Nepusz, T., &amp; Others. (2006). The igraph software package for complex network research. InterJournal, Complex Systems, 1695(5), 1–9. Dekker, D., Krackhardt, D., &amp; Snijders, T. A. B. (2007). Sensitivity of MRQAP tests to collinearity and autocorrelation conditions. Psychometrika, 72(4), 563–581. Duboscq, J., Romano, V., Sueur, C., &amp; Macintosh, A. J. J. (2016). Network centrality and seasonality interact to predict lice load in a social primate. Sci. Rep., 6(FEBRUARY), 22095. Dunn, P. K., &amp; Smyth, G. K. (2018). Generalized linear models with examples in R. Springer New York. Evans, J. C., Fisher, D. N., &amp; Silk, M. J. (2020). The performance of permutations and exponential random graph models when analyzing animal networks. Behav. Ecol., 31(5), 1266–1276. Farine, D. R. (2013). Animal social network inference and permutations for ecologists inRusingasnipe. Methods Ecol. Evol., 4(12), 1187–1194. Farine, D. R. (2014). Measuring phenotypic assortment in animal social networks: Weighted associations are more robust than binary edges. Anim. Behav., 89, 141–153. Farine, D. R. (2017). A guide to null models for animal social network analysis. Methods Ecol. Evol., 8(10), 1309–1320. Farine, D. R., &amp; Carter, G. G. (2022). Permutation tests for hypothesis testing with animal social network data: Problems and potential solutions. Methods Ecol. Evol., 13(1), 144–156. Farine, D. R., &amp; Whitehead, H. (2015). Constructing, conducting and interpreting animal social network analysis. J. Anim. Ecol., 84(5), 1144–1163. Franks, D. W., Weiss, M. N., Silk, M. J., Perryman, R. J. Y., &amp; Croft, D. P. (2021). Calculating effect sizes in animal social network analysis. Methods Ecol. Evol., 12(1), 33–41. Gilby, I. C., Brent, L. J. N., Wroblewski, E. E., Rudicell, R. S., Hahn, B. H., Goodall, J., &amp; Pusey, A. E. (2013). Fitness benefits of coalitionary aggression in male chimpanzees. Behav. Ecol. Sociobiol., 67(3), 373–381. Godde, S., Humbert, L., Côté, S. D., Réale, D., &amp; Whitehead, H. (2013). Correcting for the impact of gregariousness in social network analyses. Anim. Behav., 85(3), 553–558. Hart, J. D. A., Weiss, M. N., Brent, L. J. N., &amp; Franks, D. W. (2022). Common permutation methods in animal social network analysis do not control for non-independence. Behav. Ecol. Sociobiol., 76(11), 151. Hemelrijk, C. K. (1990a). A matrix partial correlation test used in investigations of reciprocity and other social interaction patterns at group level. J. Theor. Biol., 143(3), 405–420. Hemelrijk, C. K. (1990b). Models of, and tests for, reciprocity, unidirectionality and other social interaction patterns at a group level. Anim. Behav., 39(6), 1013–1029. Hobaiter, C., Poisot, T., Zuberbühler, K., Hoppitt, W., &amp; Gruber, T. (2014). Social network analysis shows direct evidence for social transmission of tool use in wild chimpanzees. PLoS Biol., 12(9), e1001960. Hoppitt, W. J. E., &amp; Farine, D. R. (2018). Association indices for quantifying social relationships: How to deal with missing observations of individuals or groups. Anim. Behav., 136, 227–238. Kawazoe, T., &amp; Sosa, S. (2019). Social networks predict immigration success in wild japanese macaques. Primates, 60(3), 213–222. Krause, J., James, R., Franks, D. W., &amp; Croft, D. P. (2015). Animal social networks. Oxford University Press. Lehmann, J., Majolo, B., &amp; McFarland, R. (2016). The effects of social network position on the survival of wild barbary macaques, macaca sylvanus. Behav. Ecol., 27(1), 20–28. MacIntosh, A. J. J., Jacobs, A., Garcia, C., Shimizu, K., Mouri, K., Huffman, M. A., &amp; Hernandez, A. D. (2012). Monkeys in the middle: Parasite transmission through the social network of a wild primate. PLoS One, 7(12), 15–21. Mantel, N. (1967). The detection of disease clustering and a generalized regression approach. Cancer Res., 27(2), 209–220. Newman, M. E. J. (2004). Analysis of weighted networks. Phys. Rev. E Stat. Nonlin. Soft Matter Phys., 70(5 Pt 2), 056131. Page, L., Brin, S., Motwani, R., &amp; Winograd, T. (1999). The PageRank citation ranking: Bringing order to the web. Stanford InfoLab. Puga-Gonzalez, I., Sosa, S., &amp; Sueur, C. (2019). Editorial: Social networks analyses in primates, a multilevel perspective. Primates, 60, 163–165. Puga‐Gonzalez, I., Sueur, C., &amp; Sosa, S. (2021). Null models for animal social network analysis and data collected via focal sampling: Pre‐network or node network permutation? Methods Ecol. Evol., 12(1), 22–32. Shimada, M., &amp; Sueur, C. (2018). Social play among juvenile wild japanese macaques (macaca fuscata) strengthens their social bonds. Am. J. Primatol., 80(1). Silk, J. B., Altmann, J., &amp; Alberts, S. C. (2006). Social relationships among adult female baboons (papio cynocephalus) i. Variation in the strength of social bonds. Behav. Ecol. Sociobiol., 61(2), 183–195. Sosa, S., Puga-Gonzalez, I., Hu, F., Pansanel, J., Xie, X., &amp; Sueur, C. (2020). A multilevel statistical toolkit to study animal social networks: The animal network toolkit software (ANTs) R package. Sci. Rep., 10(1), 12507. Sosa, S., Sueur, C., &amp; Puga-Gonzalez, I. (2021). Network measures in animal social network analysis: Their strengths, limits, interpretations and uses. Methods Ecol. Evol., 12(1), 10–21. Sueur, C., Jacobs, A., Amblard, F., Petit, O., &amp; King, A. J. (2011). How can social network analysis improve the study of primate behavior? American Journal of Primatology, 73(8), 703–719. Sueur, C., Petit, O., De Marco, A., Jacobs, A. T., Watanabe, K., &amp; Thierry, B. (2011). A comparative network analysis of social style in macaques. Anim. Behav., 82(4), 845–852. Weiss, M. N., Franks, D. W., Brent, L. J. N., Ellis, S., Silk, M. J., &amp; Croft, D. P. (2021). Common datastream permutations of animal social network data are not appropriate for hypothesis testing using regression models. Methods Ecol. Evol., 12(2), 255–265. Whitehead, H. (2008). Analyzing animal societies. The University of Chicago Press. Whitehead, H., Bejder, L., &amp; Ottensmeyer, C. A. (1999). Testing association patterns of social animals. Anim. Behav., 57(5), 26–29. Whitehead, H., Bejder, L., &amp; Ottensmeyer, C. A. (2005). Testing association patterns: Issues arising and extensions. Anim. Behav., 69(5), e1. Wickham, H., &amp; Grolemund, G. (2016). R for data science: Import, tidy, transform, visualize, and model data. “O’Reilly Media, Inc.” 大東健太郎. (2010). 線形モデルから一般化線形モデル（GLM）へ. 雑草研究, 55(4), 268–274. 松村優哉., 湯谷啓明., 紀ノ定保礼., &amp; 前田和. (2021). RユーザのためのRstudio[実践]入門 tidyverseによるモダンな分析フローの世界 改訂2版. 技術評論社. 鈴木努. (2017). R で学ぶデータサイエンス 8 ネットワーク分析 第2版 (金明哲., Ed.). 共立出版. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
