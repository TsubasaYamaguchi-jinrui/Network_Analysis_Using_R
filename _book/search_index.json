[["index.html", "Network Analysis Using R 本稿の目的", " Network Analysis Using R Tsubasa Yamaguchi 2022-11-05 本稿の目的 本稿はネットワーク分析の簡単な概要と、Rで分析を行う方法をまとめたものである。 本稿で扱うのは、以下の内容である。 社会ネットワーク分析の概要(第1章) rawデータからマトリックス(隣接行列)を作成する方法(第2章) 各ネットワーク指標の解説と算出法(第3章) ネットワークデータでの統計分析（第??章) 参考にしたのは主に以下の文献である。 なお、本稿の作成に使用したファイルとRのコードは筆者のGithubですべて閲覧できる。 鈴木努(2017) ネットワーク分析 第2版 (鈴木, 2017) Whitehead(2008) Analyzing Animal Societies (Whitehead, 2008) Croft et al. (2008) Exploring Animal Social Network (Croft et al., 2008) Farine &amp; Whitehead (2015) Constructing, conducting and interpreting animal social network analysis (Farine &amp; Whitehead, 2015) Farine (2017) A guide to null models for animal social network analysis (Farine, 2017) Sosa et al. (2020) A multilevel statistical toolkit to study animal social networks: the Animal Network Toolkit Software (ANTs) R package. (Sosa et al., 2020) References Croft, D., James, R., &amp; Krause, J. (2008). 動物の社会ネットワーク分析 (島田将喜., Trans.). 東海大学出版部. Farine, D. R. (2017). A guide to null models for animal social network analysis. Methods Ecol. Evol., 8(10), 1309–1320. Farine, D. R., &amp; Whitehead, H. (2015). Constructing, conducting and interpreting animal social network analysis. J. Anim. Ecol., 84(5), 1144–1163. Sosa, S., Puga-Gonzalez, I., Hu, F., Pansanel, J., Xie, X., &amp; Sueur, C. (2020). A multilevel statistical toolkit to study animal social networks: The animal network toolkit software (ANTs) R package. Sci. Rep., 10(1), 12507. Whitehead, H. (2008). Analyzing animal societies. The University of Chicago Press. 鈴木努. (2017). R で学ぶデータサイエンス 8 ネットワーク分析 第2版 (金明哲., Ed.). 共立出版. "],["パッケージの読み込み.html", "0. パッケージの読み込み", " 0. パッケージの読み込み 本稿では、基本的にネットワークデータのハンドリングにはtidygraphパッケージを用いる。このパッケージを使うことで、データフレームとしてネットワークデータを扱うことができるので非常に便利である。ネットワークグラフの描画にはggraphパッケージを用いる。このパッケージでは、基本的にggplot2と同じ文法でネットワークグラフを描くことができる。 各指標の算出や統計分析には、主にasnipeパッケージ、ANTsパッケージ、igraphパッケージ、snaパッケージを用いる。 tidygraph ggraph asnipe(Farine, 2013) ANTS(Sosa et al., 2020) igraph(Csardi et al., 2006) sna(Butts, 2008) ## ネットワーク分析関連 library(tidygraph) library(ggraph) library(asnipe) library(sna) library(ANTs) library(igraph) library(clValid) ## データハンドリング library(tidyverse) library(easystats) ## グラフや表関連 library(patchwork) library(DT) library(knitr) library(kableExtra) library(dagitty) library(ggdag) library(ggforce) library(concaveman) library(ggsci) ## フォント関連 library(extrafont) require(systemfonts) なお、本稿はRの基本操作とtidyverseパッケージによるデータハンドリングができることを前提としている。tidyverseパッケージを用いたデータ処理については、以下の書籍などを参照。 R for Data Science (Wickham &amp; Grolemund, 2016) 電子書籍, 日本語 R Graphics Coocbook 2nd Edition (Chang, 2018) 電子書籍, 日本語 RユーザのためのRstudio[実践]入門~tidyverseによるモダンな分析フローの世界 改訂2版 (松村 et al., 2021) 出版社サイト References Butts, C. T. (2008). Social network analysis with sna. J. Stat. Softw., 24, 1–51. Chang, W. (2018). R graphics cookbook: Practical recipes for visualizing data. “O’Reilly Media, Inc.” Csardi, G., Nepusz, T., &amp; Others. (2006). The igraph software package for complex network research. InterJournal, Complex Systems, 1695(5), 1–9. Farine, D. R. (2013). Animal social network inference and permutations for ecologists inRusingasnipe. Methods Ecol. Evol., 4(12), 1187–1194. Sosa, S., Puga-Gonzalez, I., Hu, F., Pansanel, J., Xie, X., &amp; Sueur, C. (2020). A multilevel statistical toolkit to study animal social networks: The animal network toolkit software (ANTs) R package. Sci. Rep., 10(1), 12507. Wickham, H., &amp; Grolemund, G. (2016). R for data science: Import, tidy, transform, visualize, and model data. “O’Reilly Media, Inc.” 松村優哉., 湯谷啓明., 紀ノ定保礼., &amp; 前田和. (2021). RユーザのためのRstudio[実践]入門 tidyverseによるモダンな分析フローの世界 改訂2版. 技術評論社. "],["c1.html", "1 社会ネットワーク分析の概説 1.1 社会ネットワーク分析(SNA)とは 1.2 社会ネットワークの基礎", " 1 社会ネットワーク分析の概説 1.1 社会ネットワーク分析(SNA)とは 社会ネットワークとは，相互に社会的なつながりをもつ個体の集まりのことを指す(Krause et al., 2015)。多くの生物において、集団を構成する個体たちはランダムランダム・均一に他個体と関わりあっているわけではなく、その関係の強度やタイプ、ダイナミクスは非常に多様である。社会ネットワークは、このような多様な関係によって構成されている(Croft et al., 2008)。 霊長類のように多くの個体が集団生活を行う種においては、個体の行動は一対一の社会関係だけではなく、集団全体の関係構造(e.g., 誰と誰がどのような関係を持つか)に強く影響を受ける。例えば、個体\\(A\\)が個体\\(B\\)に攻撃を仕掛けるかは、個体\\(B\\)が誰と/何頭と親密な関係を持つかや、その関係の強度に大きく依存するだろう。また、どのように行動や感染症等が個体間を伝播するのかにも、ネットワーク構造が大きくかかわっている。以上のことから、集団で生活する種を対象に研究を行う際には、その背後にある社会ネットワークについて理解することが非常に重要だと分かる(Krause et al., 2015; Sueur, Jacobs, et al., 2011)。 社会ネットワーク分析（SNA: Social Network Analysis）とは，集団内の2個体間の社会関係に基づいて社会ネットワークを描写することで，その社会関係の構造や構成個体の特性を調べる分析手法のことである(Croft et al., 2008; Krause et al., 2015)。SNAの手法を用いることで、社会ネットワークの構造が個体の行動に与える影響などを検討することが可能になる。 近年、霊長類でもSNAの手法を用いた研究がかなり増加している(Sueur, Jacobs, et al., 2011)。例えば、以下のような研究がある。このような研究を理解するためにもSNAの手法を学ぶことは有用だ。 オス間の親和的交渉のネットワークが移籍の成否や繁殖成功に与える影響を調べた研究(Gilby et al., 2013; Kawazoe &amp; Sosa, 2019) メス間の親和的交渉のネットワークがメスの適応度に与える影響を調べた研究(Cheney et al., 2016; Lehmann et al., 2016) 毛づくろいネットワークが寄生虫への感染に与える影響(Duboscq et al., 2016; MacIntosh et al., 2012) 異なる行動指標のネットワーク間の関連を調べた研究(Campbell et al., 2018; Shimada &amp; Sueur, 2018) 種間のネットワークを比較した研究(Balasubramaniam et al., 2018; Sueur, Petit, et al., 2011) 1.2 社会ネットワークの基礎 1.2.1 グラフ SNAでは、ネットワークの構造を頂点(ノード)と辺(エッジ)の集合によって表す。これを、グラフと呼ぶ。頂点は個体などを、辺は何らかの個体間の社会関係を表す。 関係の有無(1か0か)だけを考慮するグラフと、関係の強さ(交渉頻度など)も考慮するグラフがある。後者は特に重み付きグラフといい、関係の強さを「重み(weight)」という。グラフでは、エッジの太さで関係の強さを表す(図1.1)。 関係の向きを考える(\\(A \\rightarrow B\\)と\\(A \\leftarrow B\\)を区別)グラフを有向グラフ、考えないグラフを無向グラフという。有向グラフの場合は、辺に矢印を用いることが多い(図1.1のB)。 図1.1: 例1. 無向グラフ(A)と有向グラフ(B)の例 1.2.2 隣接行列(マトリックス) ネットワーク分析では、データを隣接行列(adjacency matrix)の形で表現することが多い。隣接行列はグラフのノード間の関係が記された行列で、ノードの数が\\(n\\)個ならば、\\(n \\times n\\)の正方行列になる。Rの分析でも、基本的に隣接行列を用いることが多い。 Rでは、matrix()関数によって以下のように作成できる。 mat_example &lt;- matrix(## 数値のベクトル c(0,0,0,2, 1.5,0,2,0, 3,0,0,1, 0,1,3,0), ## 行数と列数 ncol = 4, nrow = 4, ## TRUEなら、1行目から順に数値を入れていく byrow = TRUE) ## 列名と行名を入れられる colnames(mat_example) &lt;- c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;) rownames(mat_example) &lt;- c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;) ## 完成したのがこちら mat_example %&gt;% kable(digits = 2, align = &quot;c&quot;,caption = &quot;作成した隣接行列&quot;) %&gt;% kable_styling(font_size = 10, full_width = FALSE) 表1.1: 作成した隣接行列 A B C D A 0.0 0 0 2 B 1.5 0 2 0 C 3.0 0 0 1 D 0.0 1 3 0 Excel等で作成したcsvファイルをデータフレームとして読み込み、それをマトリックスに変換する方法もある。 ## 1列目を行名に指定 mat_example2 &lt;- read.csv(&quot;data/example.csv&quot;, row.names = 1) ## マトリックスに変換 mat_example2 &lt;- as.matrix(mat_example2) mat_example2 %&gt;% kable(digits = 2, align = &quot;c&quot;) %&gt;% kable_styling(font_size = 10, full_width = FALSE) A B C D E F G H A 0.00 0.55 0.15 0.93 0.86 0.29 0.63 0.24 B 0.41 0.00 0.86 0.95 0.20 0.99 0.36 0.59 C 0.09 0.41 0.00 0.87 0.63 0.85 0.29 0.80 D 0.83 0.68 0.07 0.00 0.60 0.54 0.14 0.42 E 0.80 0.82 0.34 0.68 0.00 0.70 0.41 0.43 F 0.80 0.05 0.78 0.17 0.95 0.00 0.04 0.37 G 0.75 0.42 0.90 0.95 0.51 0.16 0.00 0.05 H 0.87 0.16 0.02 0.05 0.31 0.85 0.13 0.00 1.2.3 Rでのグラフの描画 本稿ではggraphパッケージを用いる。このパッケージを用いる利点は主に以下の2点である。 tidygraphと併用することで、データフレーム形式のデータをそのままグラフにできる。それによって、データの加工とグラフの描画をシームレスに行いやすい。 ggplotパッケージの拡張なので、ggplotと同じ文法で描ける。 1.2.3.1 tbl_graphクラスへの変換 ggraphでグラフを描くには、データをtbl_graphクラスに変換する必要がある。隣接行列をas_tbl_graph()で変換してあげればよい。すると、ノードの名前nameと辺リスト(辺の始点、終点、重みが書いてあるリスト)が入ったオブジェクトを返してくれる。 ## 有向グラフであれば directed = TRUE、無向グラフならFALSE graph_mat_example2 &lt;- as_tbl_graph(mat_example2, directed = TRUE) graph_mat_example2 ## # A tbl_graph: 8 nodes and 56 edges ## # ## # A directed simple graph with 1 component ## # ## # Node Data: 8 × 1 (active) ## name ## &lt;chr&gt; ## 1 A ## 2 B ## 3 C ## 4 D ## 5 E ## 6 F ## # … with 2 more rows ## # ## # Edge Data: 56 × 3 ## from to weight ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 2 0.552 ## 2 1 3 0.153 ## 3 1 4 0.930 ## # … with 53 more rows なお、各ノードの名前以外の情報もグラフに反映させたい場合は、以下のように情報を追加できる。ここでは、各個体の年齢の情報を追加した。 graph_mat_example2 %&gt;% mutate(age = c(12,10,15,6,20,13,8,7)) -&gt; graph_mat_example2 graph_mat_example2 ## # A tbl_graph: 8 nodes and 56 edges ## # ## # A directed simple graph with 1 component ## # ## # Node Data: 8 × 2 (active) ## name age ## &lt;chr&gt; &lt;dbl&gt; ## 1 A 12 ## 2 B 10 ## 3 C 15 ## 4 D 6 ## 5 E 20 ## 6 F 13 ## # … with 2 more rows ## # ## # Edge Data: 56 × 3 ## from to weight ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 2 0.552 ## 2 1 3 0.153 ## 3 1 4 0.930 ## # … with 53 more rows グラフに使用するデータを絞り込むなどの作業をする場合は、一度隣接行列を辺リストのデータフレームに変換してから(mat.to.edgl()で可能)データフレームを加工し、その後にas_tbl_graph()を用いるとよい。以下では、重みが0.7以上の辺のみを抽出している。 mat_example2 %&gt;% ## 辺リストのデータフレームに変換 mat.to.edgl() %&gt;% ## weightが0.5以上のものに限定する filter(weight &gt;= 0.5) %&gt;% ## tbl_graphクラスに変換 as_tbl_graph(directed = TRUE) %&gt;% mutate(age = c(12,10,15,6,20,13,8,7)) -&gt; graph_mat_example2_b graph_mat_example2 ## # A tbl_graph: 8 nodes and 56 edges ## # ## # A directed simple graph with 1 component ## # ## # Node Data: 8 × 2 (active) ## name age ## &lt;chr&gt; &lt;dbl&gt; ## 1 A 12 ## 2 B 10 ## 3 C 15 ## 4 D 6 ## 5 E 20 ## 6 F 13 ## # … with 2 more rows ## # ## # Edge Data: 56 × 3 ## from to weight ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 2 0.552 ## 2 1 3 0.153 ## 3 1 4 0.930 ## # … with 53 more rows 1.2.3.2 ggraphを用いた描画 ggraphでグラフを描画するときには、主に以下の3つを指定してあげればよい。 レイアウト: グラフでノードと辺をどのような規則に基づいて配置するかを決める。 例. line: 一直線、circle: 円上、nicely: いい感じに?、randomly: ランダムに、… 詳細はこちらやこちらを参照。 ノード: geom_node_*()(*には色々入る)という関数群でノードについて指定。関数の中でsize =で大きさ、color =で色、shape =で形などをggplotと同じように指定できる。 例. geom_node_point(): 普通のノード、geom_node_text(): ノードのラベル、… 辺(エッジ): geom_edge_*()(*には色々入る)という関数群でノードについて指定。関数の中でwidth =で太さ、color =で色などをggplotと同じように指定できる。 例: geom_edge_link(): 直線、geom_edge_fan(): 曲線、… 図1.2は実際に以下のコードで描いた例である。 layout = \"nicely\"とすると、グラフが見やすいように配置してくれる。関係のある(= 辺がある)個体同士はより近くに配置される傾向があるため、絶対とはいえないが、結果的に多くの個体と繋がっている個体が中心部に来る傾向がある。 何らかの指標を出さない限りグラフのみから何かを結論付けることはできないが、パッと見て関係構造の全体図を掴んだり、仮説を立てたりしようとする際にはグラフを見ることが非常に有用である。 graph_mat_example2_b %&gt;% # layoutの指定 ggraph(layout = &quot;nicely&quot;)+ # 曲線のエッジ、weightを太さに geom_edge_fan(aes(width = weight), ## 矢印について指定 arrow = arrow(angle = 15, type = &quot;closed&quot;,length = unit(0.18, &quot;inches&quot;)), ## 矢印の終点のノードからの距離 end_cap = circle(2.5,&quot;mm&quot;), ## 矢印の始点のノードからの距離 start_cap = circle(2.5,&quot;mm&quot;), ## 透明度(alpha)と色(color)指定 alpha =0.7, color = &quot;grey60&quot;)+ # エッジの太さの範囲を決める scale_edge_width(range = c(0,1.3))+ ## 四角のノード。大きさは年齢によって変化するとする。 geom_node_point(aes(size = age), shape = 18)+ ## ノードのラベルは個体名 scale_size(range = c(3,6))+ geom_node_text(aes(label = name), ## ノードと重ならないようにする repel=TRUE, size =6)+ theme_graph()+ ## 縦横比 theme(aspect.ratio = 0.7) 図1.2: ggraphで描いたグラフの例 References Balasubramaniam, K. N., Beisner, B. A., Berman, C. M., De Marco, A., Duboscq, J., Koirala, S., Majolo, B., Macintosh, A. J. J. J., McFarland, R., Molesti, S., Ogawa, H., Petit, O., Schino, G., Sosa, S., Sueur, C., Thierry, B., Waal, F. B. M. M. de, &amp; McCowan, B. (2018). The influence of phylogeny, social style, and sociodemographic factors on macaque social network structure. Am. J. Primatol., 80(1), e22727. Campbell, L. A. D., Tkaczynski, P. J., Lehmann, J., Mouna, M., &amp; Majolo, B. (2018). Social thermoregulation as a potential mechanism linking sociality and fitness: Barbary macaques with more social partners form larger huddles. Sci. Rep., 8(1), 6074. Cheney, D. L., Silk, J. B., &amp; Seyfarth, R. M. (2016). Network connections, dyadic bonds and fitness in wild female baboons. Royal Society Open Science, 3(7), 160255. Croft, D., James, R., &amp; Krause, J. (2008). 動物の社会ネットワーク分析 (島田将喜., Trans.). 東海大学出版部. Duboscq, J., Romano, V., Sueur, C., &amp; Macintosh, A. J. J. (2016). Network centrality and seasonality interact to predict lice load in a social primate. Sci. Rep., 6(FEBRUARY), 22095. Gilby, I. C., Brent, L. J. N., Wroblewski, E. E., Rudicell, R. S., Hahn, B. H., Goodall, J., &amp; Pusey, A. E. (2013). Fitness benefits of coalitionary aggression in male chimpanzees. Behav. Ecol. Sociobiol., 67(3), 373–381. Kawazoe, T., &amp; Sosa, S. (2019). Social networks predict immigration success in wild japanese macaques. Primates, 60(3), 213–222. Krause, J., James, R., Franks, D. W., &amp; Croft, D. P. (2015). Animal social networks. Oxford University Press. Lehmann, J., Majolo, B., &amp; McFarland, R. (2016). The effects of social network position on the survival of wild barbary macaques, macaca sylvanus. Behav. Ecol., 27(1), 20–28. MacIntosh, A. J. J., Jacobs, A., Garcia, C., Shimizu, K., Mouri, K., Huffman, M. A., &amp; Hernandez, A. D. (2012). Monkeys in the middle: Parasite transmission through the social network of a wild primate. PLoS One, 7(12), 15–21. Shimada, M., &amp; Sueur, C. (2018). Social play among juvenile wild japanese macaques (macaca fuscata) strengthens their social bonds. Am. J. Primatol., 80(1). Sueur, C., Jacobs, A., Amblard, F., Petit, O., &amp; King, A. J. (2011). How can social network analysis improve the study of primate behavior? American Journal of Primatology, 73(8), 703–719. Sueur, C., Petit, O., De Marco, A., Jacobs, A. T., Watanabe, K., &amp; Thierry, B. (2011). A comparative network analysis of social style in macaques. Anim. Behav., 82(4), 845–852. "],["c2.html", "2 データの読み込みとマトリックスの作成 2.1 2個体間のassociationを記録したデータフレーム 2.2 Group by individual", " 2 データの読み込みとマトリックスの作成 R上でSNAを行うためには、個体間の関係データを隣接行列にしなければならないことが多い。しかし多くの場合、個体間のassociationの生データは隣接行列の形では表されていない。例えば個体追跡のデータでは、以下(表??)のように1分ごとに毛づくろい相手のIDを記録したものをまずExcelファイルなどに記入する、というようなことが多いだろう。ここでは、R上でこのような生データから隣接行列を作成する方法を学ぶ。 表2.1: 生データの例 min groomer groomee 1 A B 2 A B 3 A C 4 B A 5 B A 2.1 2個体間のassociationを記録したデータフレーム ここでは、2個体間のassociation(例えば、毛づくろいや近接)等を記録したデータフレームから隣接行列を作る。 例えば、以下は金華山島\\(B_1\\)群で2018年時点で6歳以上のメスを個体追跡した際のデータであり、1分間の瞬間サンプリングで以下を記録したデータフレームである。 no_focal: 個体追跡セッション番号 subject: 追跡個体名 time: 個体追跡開始からの経過時間 activity: 個体の活動(G: 毛づくろい、R: 休息、F: 採食、M: 移動、O: その他) TG: 樹上(T)にいたか地上(G)にいたか groomer: activityが毛づくろいだったときのgroomer geoomee: activityが毛づくろいだったときのgroomer groom &lt;- read_csv(&quot;data/focal_demo.csv&quot;) groom %&gt;% head(50) %&gt;% datatable(rownames = FALSE) 追跡したメスのIDは以下のとおりである。 adult &lt;- c(&quot;Kil&quot;,&quot;Kit&quot;,&quot;Koh&quot;,&quot;Kur&quot;,&quot;Kun&quot;,&quot;Kor&quot;,&quot;Ntr&quot;, &quot;Ten&quot;,&quot;Aka&quot;,&quot;Ako&quot;,&quot;Tam&quot;,&quot;Tot&quot;,&quot;Hen&quot;,&quot;Hot&quot;, &quot;Mal&quot;,&quot;Mik&quot;,&quot;Mei&quot;) このデータをもとに、個体追跡中にメス間が毛づくろいをした頻度を示したマトリックスを作成する。 ここで、頻度は以下の式で表すものとする。 \\(G_{AB}\\): \\(A\\)から\\(B\\)への毛づくろい頻度 \\(x_{AB}\\): \\(A\\)から\\(B\\)への毛づくろいが確認された瞬間サンプリングポイント数 \\(y_A\\): \\(A\\)の個体追跡時間(瞬間サンプリングポイント総数) \\(y_B\\): \\(B\\)の個体追跡時間(瞬間サンプリングポイント総数) \\[ G_{AB} = \\frac{x_{AB}}{y_{A} + y_{B}} \\] 分母となる各個体の個体追跡時間(\\(y_A, y_B, ...\\))を算出する。 groom %&gt;% group_by(subject) %&gt;% summarise(duration = n()) -&gt; duration duration %&gt;% datatable(rownames = FALSE) 追跡個体がのactivityが毛づくろいで、かつ地上にいたポイントのみを抽出する。 また、毛づくろい相手が大人だったのみを抽出。 groom_G &lt;- groom %&gt;% filter(activity == &quot;G&quot;) %&gt;% filter(Groomer %in% adult &amp; Groomee %in% adult) 毛づくろい頻度はANTsパッケージのdf.to.mat()関数で以下のように求められる。 groom_mat &lt;- df.to.mat(groom_G, ## 行動の行い手を表す列 actor = &quot;Groomer&quot;, ## 行動の受け手を表す列 receiver = &quot;Groomee&quot;, ## 追跡時間 tobs = duration$duration, ## 交渉の方向を考慮するか。FALSEでする。 sym = FALSE) 隣接行列は以下のようになる(表2.2)。 表2.2: 方向性を考慮した毛づくろい頻度の隣接行列 Aka Ako Hen Hot Kil Kit Koh Kor Kun Kur Mal Mei Mik Ntr Tam Ten Tot Aka 0.00 0.04 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 Ako 0.07 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.01 0.00 Hen 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.01 0.00 0.00 0.00 0.00 0.00 Hot 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 Kil 0.00 0.00 0.00 0.00 0.00 0.01 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 Kit 0.00 0.00 0.00 0.00 0.02 0.00 0.01 0.00 0.00 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 Koh 0.00 0.00 0.00 0.00 0.01 0.01 0.00 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 Kor 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.01 0.02 0.00 0.00 0.00 0.01 0.00 0.00 0.00 Kun 0.00 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.00 Kur 0.00 0.00 0.00 0.00 0.01 0.01 0.00 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 Mal 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.02 0.00 0.00 0.00 0.01 Mei 0.01 0.01 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 Mik 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.03 0.00 0.00 0.00 0.00 0.00 0.00 Ntr 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.01 0.00 0.00 0.01 0.00 0.00 0.01 0.00 Tam 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 Ten 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.01 0.00 0.00 0.00 Tot 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.01 0.00 0.00 0.01 0.00 0.00 0.00 0.01 0.00 0.00 もし交渉の方向性を考慮しない場合は、sym = TRUEとすればよい。 groom_mat_b &lt;- df.to.mat(groom_G, ## 行動の行い手を表す列 actor = &quot;Groomer&quot;, ## 行動の受け手を表す列 receiver = &quot;Groomee&quot;, ## 追跡時間 tobs = duration$duration, sym = TRUE) その場合の隣接行列は以下の通り(表2.3)。 表2.3: 方向性を考慮しない毛づくろい頻度の隣接行列 Aka Ako Hen Hot Kil Kit Koh Kor Kun Kur Mal Mei Mik Ntr Tam Ten Tot Aka 0.00 0.11 0.00 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.00 0.00 Ako 0.11 0.00 0.01 0.00 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.02 0.00 0.01 0.00 0.01 0.00 Hen 0.00 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.01 0.00 0.00 0.01 0.01 0.00 Hot 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 Kil 0.00 0.00 0.00 0.00 0.00 0.04 0.02 0.00 0.01 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 Kit 0.00 0.00 0.00 0.00 0.04 0.00 0.03 0.01 0.00 0.02 0.00 0.00 0.00 0.00 0.00 0.00 0.00 Koh 0.00 0.00 0.00 0.00 0.02 0.03 0.00 0.02 0.01 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.00 Kor 0.00 0.01 0.00 0.00 0.00 0.01 0.02 0.00 0.01 0.02 0.00 0.00 0.01 0.01 0.00 0.01 0.01 Kun 0.00 0.00 0.00 0.00 0.01 0.00 0.01 0.01 0.00 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.00 Kur 0.00 0.00 0.00 0.00 0.01 0.02 0.00 0.02 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.01 0.00 Mal 0.00 0.00 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.04 0.00 0.00 0.00 0.01 Mei 0.01 0.02 0.01 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.01 0.01 0.00 0.00 0.00 Mik 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.01 0.01 0.00 0.04 0.01 0.00 0.01 0.01 0.00 0.00 Ntr 0.00 0.01 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.01 0.00 0.01 0.01 0.00 0.00 0.01 0.01 Tam 0.00 0.00 0.01 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.02 Ten 0.00 0.01 0.01 0.00 0.00 0.00 0.00 0.01 0.00 0.01 0.00 0.00 0.00 0.01 0.00 0.00 0.00 Tot 0.00 0.00 0.00 0.01 0.00 0.00 0.00 0.01 0.00 0.00 0.01 0.00 0.00 0.01 0.02 0.00 0.00 グラフを描画すると図2.1のようになる。ノードの大きさは順位を、辺の太さは毛づくろい頻度を表す。血縁個体同士(同じアルファベットで始まる個体)は交渉頻度が高く、近くに配置されていることが分かる。順位の低い個体がネットワークの周辺にいることが多いことも分かるだろう。 ## 順位 rank &lt;- c(9,10,13,14,1,2,3,6,5,4,15,17,16,7,11,8,12) groom_mat_b %&gt;% as_tbl_graph(directed = FALSE) %&gt;% ## 順位の情報を入れる mutate(rank = rank) %&gt;% ggraph(layout = &quot;nicely&quot;)+ # 曲線のエッジ、weightを太さに geom_edge_fan(aes(width = weight), ## 透明度(alpha)と色(color)指定 alpha =0.7, color = &quot;grey60&quot;)+ # エッジの太さの範囲を決める scale_edge_width(range = c(0.3,3))+ ## 四角のノード。大きさは年齢によって変化するとする。 geom_node_point(aes(size = -rank), shape = 18)+ ## ノードのラベルは個体名 scale_size(range = c(1,5))+ geom_node_text(aes(label = name), ## ノードと重ならないようにする repel=TRUE, size =6)+ theme_graph()+ ## 縦横比 theme(aspect.ratio = 0.7)+ labs(width = &quot;毛づくろい頻度&quot;) 図2.1: 毛づくろい頻度ネットワークのグラフ 2.2 Group by individual 個体間のassociationを表したデータには、以下のようにある時点・場所において確認された個体を0/1で記録した”group by individual”と呼ばれる形式のものもある。 例えば、以下は金華山島\\(B_1\\)群で2021年交尾期の各観察日に9歳以上のメスが観察されたか否かを示したものである。 presence &lt;- read_csv(&quot;data/presence_demo.csv&quot;) presence %&gt;% datatable(rownames = FALSE) このようなデータでは、同じグループで観察された個体をassociateしていたとみなすことが多い(=gambit of the group)(Farine &amp; Whitehead, 2015)。Group by individualの形式のデータでは、以下のような指標で個体間の強さを表すことが多い。なお、各指標の詳細については Hoppitt &amp; Farine (2018) を参照。 \\(x\\): 個体\\(a\\)と\\(b\\)が一緒に観察された回数 \\(y_a\\): \\(a\\)だけが確認された回数 \\(y_b\\): \\(b\\)だけが確認された回数 \\(y_{ab}\\): \\(a\\)と\\(B\\)が共に観察されたが、associateはしてない回数(今回の例では存在しない) \\(y_{null}\\) どちらも観察されなかった回数 SRI: simple ratio index \\(= x/(y_a + y_b + y_{ab} + x)\\) ▶ 単純に一緒に観察された割合。観察ミス(個体がいたにもかかわらずいなかったと記録してしまうこと)が少ない場合にはこちらで問題ない。 HWI: half-weight index \\(= x/(\\frac{1}{2}(y_a + y_b) + y_{ab} + x)\\) ▶ 観察ミスが多いと考えられる場合、補正を行う。 asnipeパッケージのget_network()関数では、こうしたデータかSRIやHWIを算出し、マトリックスを作成することが可能である。 presence_mat &lt;- get_network(presence %&gt;% dplyr::select(-date), ## gambit of the group data_format = &quot;GBI&quot;, ## &quot;HWI&quot;の場合は、&quot;HWI&quot; association_index = &quot;SRI&quot;) ## Generating 15 x 15 matrix 得られた隣接行列は以下の通り(表2.4)。 表2.4: SRIの隣接行列 Mik Kil Koh Aka Ntr Ten Tot Hen Hot Mei Ako Kor Mal Kit Kun Mik 0.00 0.43 0.45 0.63 0.41 0.46 0.41 0.39 0.32 0.43 0.45 0.43 0.32 0.42 0.42 Kil 0.43 0.00 0.98 0.45 0.93 0.95 0.95 0.94 0.80 0.98 0.80 0.98 0.88 0.95 0.95 Koh 0.45 0.98 0.00 0.45 0.95 0.95 0.95 0.94 0.78 0.98 0.80 0.98 0.86 0.95 0.95 Aka 0.63 0.45 0.45 0.00 0.44 0.46 0.42 0.42 0.39 0.43 0.53 0.43 0.35 0.43 0.41 Ntr 0.41 0.93 0.95 0.44 0.00 0.90 0.90 0.89 0.76 0.93 0.77 0.93 0.86 0.93 0.93 Ten 0.46 0.95 0.95 0.46 0.90 0.00 0.93 0.89 0.76 0.95 0.77 0.95 0.83 0.93 0.93 Tot 0.41 0.95 0.95 0.42 0.90 0.93 0.00 0.89 0.78 0.95 0.77 0.95 0.86 0.95 0.95 Hen 0.39 0.94 0.94 0.42 0.89 0.89 0.89 0.00 0.81 0.92 0.76 0.92 0.91 0.92 0.92 Hot 0.32 0.80 0.78 0.39 0.76 0.76 0.78 0.81 0.00 0.78 0.65 0.78 0.79 0.78 0.78 Mei 0.43 0.98 0.98 0.43 0.93 0.95 0.95 0.92 0.78 0.00 0.78 0.98 0.86 0.95 0.95 Ako 0.45 0.80 0.80 0.53 0.77 0.77 0.77 0.76 0.65 0.78 0.00 0.78 0.70 0.78 0.78 Kor 0.43 0.98 0.98 0.43 0.93 0.95 0.95 0.92 0.78 0.98 0.78 0.00 0.88 0.95 0.95 Mal 0.32 0.88 0.86 0.35 0.86 0.83 0.86 0.91 0.79 0.86 0.70 0.88 0.00 0.88 0.88 Kit 0.42 0.95 0.95 0.43 0.93 0.93 0.95 0.92 0.78 0.95 0.78 0.95 0.88 0.00 0.98 Kun 0.42 0.95 0.95 0.41 0.93 0.93 0.95 0.92 0.78 0.95 0.78 0.95 0.88 0.98 0.00 グラフを描画すると図2.2のようになる。ノードの大きさは年齢、色は順位を、辺の太さはSRIを表す。MikとAkaは他の個体と一緒にいることが少ないことが分かるだろう(年齢も影響しそう？)。順位の高い個体はネットワークの中心にいることが多い? age &lt;- c(18,17,15,15,13,13,13,13,13,13,12,11,11,10,9) rank2 &lt;- c(16,1,3,9,7,8,12,13,14,17,10,6,15,2,5) presence_mat %&gt;% as_tbl_graph(directed = FALSE) %&gt;% ggraph(layout = &quot;nicely&quot;)+ # 曲線のエッジ、weightを太さに geom_edge_link(aes(width = weight), ## 透明度(alpha)と色(color)指定 alpha =0.7, color = &quot;grey67&quot;)+ # エッジの太さの範囲を決める scale_edge_width(range = c(0,2))+ ## 四角のノード。大きさは年齢によって変化するとする。 geom_node_point(aes(size = age, color = rank2),shape = 16)+ ## ノードのラベルは個体名 scale_size(range = c(1,5))+ geom_node_text(aes(label = name), ## ノードと重ならないようにする repel=TRUE, size =6)+ theme_graph()+ ## 縦横比 theme(aspect.ratio = 0.7) 図2.2: SRIネットワークのグラフ References Farine, D. R., &amp; Whitehead, H. (2015). Constructing, conducting and interpreting animal social network analysis. J. Anim. Ecol., 84(5), 1144–1163. Hoppitt, W. J. E., &amp; Farine, D. R. (2018). Association indices for quantifying social relationships: How to deal with missing observations of individuals or groups. Anim. Behav., 136, 227–238. "],["c3.html", "3 ネットワーク指標の算出 3.1 ノードについての諸指標(中心性指標) 3.2 ネットワーク構造の諸指標", " 3 ネットワーク指標の算出 本章では、ネットワークの構造や構成個体の特徴を表すための指標について概説し、それらをRで算出する方法を学ぶ。指標を算出することで定量的な分析が可能になり、グラフを見るだけでは定性的にしか言えなかったことを示すことができるようになる。 本稿では主にANTsパッケージ、またはsnaパッケージで指標の算出を行う。各指標についての説明は 鈴木 (2017) や Sosa et al. (2020) 、 Farine &amp; Whitehead (2015) なども参照。 3.1 ノードについての諸指標(中心性指標) ここでは、各ノードのネットワーク内での特性を表す指標についてまとめる。中心性指標は、いずれもあるノードがそのグラフでどのくらい「中心的」であるかを表す指標である。以下で見るように、中心性を評価する方法は数多く提案されている。 基本的には、いずれもANTsパッケージのmet.*()関数で出力できる(*には中心性指標の名前)。これらの関数は、各ノードについて算出した中心性を各ノードの属性データ(例えば年齢や順位など)を記したデータフレームに追加していってくれるので、分析を行う際に非常に便利である。 属性データの例(年齢と順位) attr &lt;- data.frame(name = c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;), age = c(12,13,12,11,14,15,18,9), rank = c(2,3,4,1,8,1,7,6)) attr %&gt;% datatable(rownames = FALSE, width = &quot;55%&quot;) 3.1.1 次数中心性(Degree centrality) 最も簡便で適用範囲の広い中心性が次数中心性である(鈴木, 2017)。重みなしグラフについて算出でき、各ノードに辺で接続しているノードの数を、そのノードの次数中心性とする。例えば、図3.1では、Aの次数中心性は5、Dの次数中心性は3である。 図3.1: 次数中心性算出のための無向グラフの例 ANTsパッケージでは、met.degreeで求められる。以下のようにdf =に属性が入ったデータフレームを指定することで、算出した次数中心性をそのデータフレームに追加してくれる。 met.degree(mat_undir, ## 属性データフレーム df = attr, ## 個体IDの列番号 dfid = 1) %&gt;% kable(align = &quot;c&quot;) %&gt;% kable_styling(font_size = 12, full_width = FALSE) name age rank degree A 12 2 5 B 13 3 3 C 12 4 2 D 11 1 3 E 14 8 3 F 15 1 2 G 18 7 1 H 9 6 1 有向グラフでは、他のノードから入ってくる辺の数である入次数(indegree)と他のノードへ入っていく辺の数である出次数(outdegree)が区別される。図3.2では、Aの入次数は2、出次数は3である。 図3.2: 次数中心性算出のための有向グラフの例 ANTsパッケージでは、それぞれmet.indegree()とmet.outdegree()で求められる。 ## このようにすれば、2つの中心性指標を共に属性データに結合できる。 met.indegree(mat_dir, ## 属性データフレーム df = attr, ## 個体IDの列番号 dfid = 1) -&gt; attr_b met.outdegree(mat_dir, ## 属性データフレーム(入次数の情報も含む) df = attr_b, ## 個体IDの列番号 dfid = 1) %&gt;% kable(align = &quot;c&quot;) %&gt;% kable_styling(font_size = 12, full_width = FALSE) name age rank indegree outdegree A 12 2 2 3 B 13 3 3 1 C 12 4 1 2 D 11 1 1 2 E 14 8 1 0 F 15 1 2 1 G 18 7 1 3 H 9 6 1 0 3.1.2 重み付き中心性(Strength centrality) 重み付き中心性は、各ノードに接続している辺の重みの合計で表される中心性である。図3.3は表3.1の隣接行列(mat_undir_b)のグラフである。グラフの辺上の数字は重みを表す。このとき、Aの重み付き中心性は\\(3 + 2+ 2+ 1 +1=9\\)、Cの重み付き中心性は\\(3 + 2 = 5\\)である。 表3.1: 隣接行列(mat_undir_b) A B C D E F G H A 0 2 3 1 2 1 0 0 B 2 0 2 0 0 0 1 0 C 3 2 0 0 0 0 0 0 D 1 0 0 0 3 0 0 1 E 2 0 0 3 0 2 0 0 F 1 0 0 0 2 0 0 0 G 0 1 0 0 0 0 0 0 H 0 0 0 1 0 0 0 0 図3.3: 重み付き中心性算出のための無向グラフの例 ANTsパッケージでは、met.strength()で求められる。まお、ANTsパッケージでは常に有向グラフとして計算されてしまうようなので、1/2してあげる必要がある。 met.strength(mat_undir_b/2, ## 属性データフレーム df = attr, ## 個体IDの列番号 dfid = 1) %&gt;% kable(align = &quot;c&quot;) %&gt;% kable_styling(font_size = 12, full_width = FALSE) name age rank strength A 12 2 9 B 13 3 5 C 12 4 5 D 11 1 5 E 14 8 7 F 15 1 3 G 18 7 1 H 9 6 1 なお、有向データについては次数中心性と同じようにinstrengthとoutstrengthで区別することもできる。その場合は、それぞれANTsパッケージのmet.indegree()とmet.outstrength()で算出できる。 おまけ snaパッケージでは、次数中心性と重み付き中心性を全てdegree()関数で求められる。 sna::degree(mat_undir_b, ## 重みなしの場合 TRUE ignore.eval = FALSE, ## 有向グラフの場合は &quot;digraph&quot;, gmode = &quot;graph&quot;, ## indegreeの場合は &quot;indegree&quot;、outdegreeの場合は&quot;outdegree&quot;, cmode = &quot;freeman&quot;) ## [1] 9 5 5 5 7 3 1 1 3.1.3 固有ベクトル中心性(Eigenvector centrality) 次数中心性や重み付け中心性は、あるノードに接続する辺の数や重みの合計に基づく中心性指標であった。つまり、例えば毛づくろい頻度ネットワークでは、多くの個体と毛づくろいしている個体や、毛づくろい頻度の合計が多い個体の中心性が高く評価される。しかし、この方法は中心性を評価する指標として適切ではない場合がある。例えば、毛づくろいを通してある行動がネットワーク内をどのように伝播するかを考えるとき、毛づくろい相手の多い個体と毛づくろいすることは、毛づくろい相手の少ない個体と毛づくろいするよりも高く評価するべきかもしれない。 このことを考慮するためは、あるノードの中心性を評価するときに、そのノードと繋がっているノードの中心性の大きさを反映させる必要がある。例えば、あるノードの中心性がそれとつながるノードの中心性の和に比例する方法が考えられる。このとき、ある無向グラフの隣接行列を\\(A = (a_{ij})\\)とし、そこに含まれるノードの中心性を成分とする列ベクトルを\\(c=c_i\\)とすると、ノード\\(i\\)の中心性\\(c_i\\)は次のように表現できる。ただし、\\(\\lambda\\)は正の比例定数である。 \\[ \\begin{aligned} c_i &amp;= \\frac{1}{\\lambda} \\sum_{j=1}^{n} a_{ij}c_j \\end{aligned} \\] 行列とベクトルで表すと、以下のように書ける。 \\[ \\begin{aligned} c &amp;= \\frac{1}{\\lambda} Ac\\\\ \\therefore \\lambda c &amp;= Ac \\end{aligned} \\] 例えば、4個体について以下の隣接行列\\(A\\)と中心性を成分とするベクトル\\(c\\)を考える。 $$ \\[\\begin{aligned} &amp;A = (a_{ij}) = \\begin{pmatrix} 0 &amp; 1 &amp; 0 &amp; 0\\\\ 1 &amp; 0 &amp; 1 &amp; 1\\\\ 0 &amp; 1 &amp; 0 &amp; 1\\\\ 0 &amp; 1 &amp; 1 &amp; 0\\\\ \\end{pmatrix}\\\\ \\\\ &amp;c = \\begin{pmatrix} c_1\\\\ c_2\\\\ c_3\\\\ c_4 \\end{pmatrix} \\end{aligned}\\] $$ このとき、以下のような式を満たす\\(c\\)と\\(\\lambda\\)を求めることになる。 $$ \\[\\begin{aligned} \\lambda \\begin{pmatrix}c_1\\\\ c_2\\\\ c_3\\\\ c_4 \\end{pmatrix} &amp;= \\begin{pmatrix} 0 &amp; 1 &amp; 0 &amp; 0\\\\ 1 &amp; 0 &amp; 1 &amp; 1\\\\ 0 &amp; 1 &amp; 0 &amp; 1\\\\ 0 &amp; 1 &amp; 1 &amp; 0 \\end{pmatrix} \\begin{pmatrix} c_1\\\\ c_2\\\\ c_3\\\\ c_4\\\\ \\end{pmatrix}\\\\ \\\\ \\therefore \\lambda \\begin{pmatrix} c_1\\\\ c_2\\\\ c_3\\\\ c_4\\\\ \\end{pmatrix} &amp;= \\begin{pmatrix} c_2\\\\ c_1 +c_3+ c_4\\\\ c_2+c_4\\\\ c_2+c_3\\\\ \\end{pmatrix} \\end{aligned}\\] $$ ここで、これを満たす\\(\\lambda\\)は正方行列\\(A\\)の固有値、\\(c\\)は固有ベクトルになる1。つまり、隣接行列の固有ベクトルを求めれば、隣接するノードの中心性を反映した中心性を求めることができる(なお、固有値と固有ベクトルの組み合わせは\\(A\\)の列数と同じだけある)。特に絶対値が最大となる固有値に対応する第1固有ベクトルを中心性指標としたものを、固有ベクトル中心性(eigenvector centrality)という。 あるノードの固有ベクトル中心性は、そのノードにつながるノードの中心性を反映しているが、それらのノードは更にそれらにつながるノードの中心性を反映している。このように、固有ベクトル中心性は、そのノードから辺をたどって到達できるすべてのノードの中心性を反映している。 先ほどの例の\\(A\\)の第1固有ベクトルは以下のように求められる。固有ベクトルは負の値をとることもあるため、絶対値をとることが多い。また、最大値を1とした比で表すことも多い。 A = matrix(c(0,1,0,0, 1,0,1,1, 0,1,0,1, 0,1,1,0), nrow = 4, byrow = TRUE) ## 第1固有ベクトル。絶対値をとる。 evc &lt;- abs(eigen(A)$vectors[,1]) ## 最大値を1とするようにする evc/max(evc) ## [1] 0.4608111 1.0000000 0.8546377 0.8546377 ANTsパッケージではmet.eigen()関数で、snaパッケージではevcent()関数で固有ベクトル中心性を求められる。前者は最大が1になるように変形しているのに対し、後者はそのような変形はしていない(定数倍しただけなので、分析上はどちらでも構わない)。 ## ANTs met.eigen(A) ## [1] 0.4608111 1.0000000 0.8546377 0.8546377 ## sna sna::evcent(A) ## [1] 0.2818452 0.6116285 0.5227207 0.5227207 以上は重みなしグラフについて算出を行ったが、重み付きグラフについても同様に算出できる。 隣接行列mat_undir_b(表3.1)ついて、それぞれ重み付き中心性(左)と固有ベクトル中心性(右)の値をノードの大きさに反映させたグラフが図3.4である。 set.seed(123) ## 重み付き中心性の算出 met.strength(mat_undir_b/2, df = attr, dfid = 1) -&gt; attr_st ## 固有ベクトル中心性の算出 met.eigen(mat_undir_b, df = attr_st, dfid = 1) -&gt; attr_st_evc ## 重み付き中心性のグラフ mat_undir_b %&gt;% as_tbl_graph(directed = FALSE) %&gt;% ## `tbl_graph`に重み付き中心性の情報を追加 mutate(strength = attr_st_evc$strength) %&gt;% ggraph(layout = &quot;nicely&quot;)+ geom_node_point(aes(size = strength), shape = 16, color = &quot;black&quot;)+ scale_size(range = c(6,13))+ geom_edge_link(aes(width = weight),color = &quot;grey65&quot;, end_cap = circle(0.5,&quot;cm&quot;), start_cap = circle(0.5,&quot;cm&quot;))+ geom_node_text(aes(label = name), color = &quot;white&quot;)+ scale_edge_width(range = c(1,3))+ labs(title = &quot;重み付き中心性&quot;)+ theme_graph() -&gt; p_strength ## 固有ベクトル中心性のグラフ mat_undir_b %&gt;% as_tbl_graph(directed = FALSE) %&gt;% ## `tbl_graph`に固有ベクトル中心性の情報を追加 mutate(eigen = attr_st_evc$eigen) %&gt;% ggraph(layout = &quot;nicely&quot;)+ geom_node_point(aes(size = eigen), shape = 16, color = &quot;black&quot;)+ scale_size(range = c(6,13))+ geom_edge_link(aes(width = weight),color = &quot;grey65&quot;, end_cap = circle(0.5,&quot;cm&quot;), start_cap = circle(0.5,&quot;cm&quot;))+ geom_node_text(aes(label = name), color = &quot;white&quot;)+ scale_edge_width(range = c(1,3))+ labs(title = &quot;固有ベクトル中心性&quot;)+ theme_graph() -&gt; p_eigen p_strength + p_eigen 図3.4: 重み付き中心性(左)と固有ベクトル中心性(右)の値をノードの大きさに反映させたグラフ 3.1.4 PageRank 固有ベクトル中心性は、分離したグラフや有向グラフの中心性分析には使えない。PageRankは固有ベクトルに基づきながら、これらのグラフにも摘要できる中心性指標である。もともとはウェブページの評価法として、Googleの創業者であるラリー・ペイジやセルゲイ・ブリンらによって開発され(Page et al., 1999)、他ページからのリンクが多いページほどランキングが高く、ランキングの高いページからのリンクや、他のページへのリンクが少ないページからのリンクを高く評価するというアルゴリズムに従う。詳細な算出方法は複雑なので、ここでは説明しない。詳しくは 鈴木 (2017) を参照。 PageRankはigraphパッケージを用いて算出できる。表3.2の隣接行列(mat_dir_b)のPageRankを算出する。 表3.2: 隣接行列(mat_dir_b) A B C D E F G H A 0 2 0 1 0 1 0 0 B 0 0 2 0 0 0 1 0 C 3 2 0 0 0 0 0 0 D 1 0 0 0 0 0 0 0 E 2 0 0 3 0 0 0 0 F 0 0 0 0 2 0 0 2 G 0 1 0 0 0 1 0 0 H 0 0 0 1 0 0 0 0 igraphパッケージでデータを扱う際には、まず隣接行列をigraphクラスにしなくてはならない。graph_from_adjacency_matrix()関数でigraphクラスに変換した後、page.rank()関数でPageRankを算出する。 mat_dir %&gt;% ## 隣接行列をgraphに変換 graph_from_adjacency_matrix(weighted = NULL, mode = &quot;directed&quot;) %&gt;% ## PageRankの算出 page.rank(directed = TRUE) -&gt; page_rank page_rank$vector ## A B C D E F G ## 0.12584798 0.18619542 0.14217932 0.07093242 0.06542177 0.12576921 0.19354160 ## H ## 0.09011228 PageRankの値をノードの大きさに反映したグラフが図3.5である。 set.seed(123) mat_dir_b %&gt;% as_tbl_graph(directed = TRUE) %&gt;% ## `tbl_graph`にPageRankの情報を追加 mutate(PageRank = page_rank$vector) %&gt;% ggraph(layout = &quot;nicely&quot;)+ geom_node_point(aes(size = PageRank),shape = 16, color = &quot;black&quot;)+ scale_size(range = c(6,13))+ geom_edge_fan(aes(width = weight), color = &quot;grey65&quot;, arrow = arrow(angle = 30, length = unit(4,units = &quot;mm&quot;), type = &quot;closed&quot;), end_cap = circle(0.5,&quot;cm&quot;), start_cap = circle(0.5,&quot;cm&quot;))+ geom_node_text(aes(label = name), color = &quot;white&quot;)+ scale_edge_width(range = c(0,2))+ labs(title = &quot;PageRank&quot;)+ theme_graph()+ scale_x_continuous(expand = c(0.05,0.05))+ scale_y_continuous(expand = c(0.05,0.05))-&gt; p_pr p_pr 図3.5: PageRankの値をノードの大きさに反映させたグラフ 3.1.5 媒介中心性(Betweeness centrality) ネットワークにおける媒介や伝達に着目した中心性に媒介中心性がある。媒介中心性は、他のノード同士をつなぐ最短経路上に位置するノードは、ノード間の仲介や情報の伝達に与える影響が大きいという点で有力であり、より多くのノード間の最短経路上にあるノードほどその影響力が大きいとする指標である。 ノード\\(i\\)の媒介中心性は以下の式で定式化される。なお、\\(g_{jk}\\)はノード\\(j\\)と\\(k\\)の間の最短経路数であり、\\(g_{ij}(i)\\)はノード\\(j\\)と\\(k\\)の間の最短経路のうちノード\\(i\\)を通るものの数である。無向グラフの場合、\\(j &lt; k\\)である。 \\[ C_b(i) = \\sum_{i \\neq j \\neq k} \\frac {g_{jk}(i)}{g_{jk}} \\] ANTsパッケージではmet.betweeness()関数で、snaパッケージではsna::betweeness()関数で媒介中心性を求められる。表3.2の隣接行列(mat_dir_b)について算出すると、以下のようになる。 ## ANTs met.betweenness(mat_dir_b, ## 重みなしならTRUE binary = FALSE, ## 無向グラフならTRUE sym = FALSE, ## 最もstrengthが重みの合計が高い経路を最短とする shortest.weight = TRUE, df = attr, dfid = 1) %&gt;% kable(align = &quot;c&quot;) %&gt;% kable_styling(font_size = 12, full_width = FALSE) name age rank norm.short.outbetweenness A 12 2 22.0 B 13 3 13.5 C 12 4 1.0 D 11 1 8.5 E 14 8 2.5 F 15 1 15.0 G 18 7 5.5 H 9 6 5.5 ## sna sna::betweenness(mat_dir_b, ## 無向グラフなら&quot;undirected&quot; cmode = &quot;directed&quot;, ## 重みなしならTRUE ignore.eval = FALSE) ## [1] 22.0 13.5 1.0 8.5 2.5 15.0 5.5 5.5 媒介中心性の値をノードの大きさに反映したグラフが図3.6である。 図3.6: 媒介中心性の値をノードの大きさに反映させたグラフ 3.1.6 情報中心性(Information centrality) 媒介中心性は最短経路以外の経路や、経路の長さを考慮していなかった。しかし、実際の情報の伝達は最短経路のみでなされるとは限らないし、情報伝達に関わる人が多いほど情報の精度が下がるような可能性もある。そこで、ノード間の最短経路以外の経路や経路の長さを考慮した指標として、情報中心性が考案された。 情報中心性の算出では、経路が短いほど高く評価されるように経路の長さの逆数で重みづけされる。例えば、図3.7のノード\\(2\\)と\\(4\\)について考える。これらのノードの間の経路には\\(2-1-4\\)と\\(2-3-1-4\\)の2通りがあり、それぞれの長さは2と3である。ただし、2つの経路には\\(1-4\\)という共通の経路が存在する。 図3.7: 情報中心性算出のための無向グラフの例 このとき、ノード\\(2\\)と\\(4\\)について以下の行列\\(D_{24}\\)を考える。なお、行列の対角成分にはそれぞれの経路の長さが、それ以外の成分には2つの経路で共通する辺の数が入る。 \\(D_{24} = \\begin{pmatrix} 2 &amp; 1 \\\\1 &amp; 3\\end{pmatrix}\\) そして、この行列の逆行列2\\(D_{24}^{-1}\\)の各行の成分の合計を、各経路の情報量とする。この場合、\\(0.6-0.2 = 0.4\\)が経路\\(2-1-4\\)の、\\(-0.2 + 0.4 = 0.2\\)が経路\\(2-3-1-4\\)の情報量である。また、その和(\\(0.4+0.2=0.6\\))をノード\\(2\\)と\\(4\\)のペアについての情報量(\\(I_{24}\\))とする。このように全てのノードペアについての情報量を算出する(自身との情報量は\\(I_{ii} = \\infty\\)である)。 \\(D_{24}^{-1} = \\begin{pmatrix} 0.6 &amp; -0.2 \\\\ -0.2 &amp; 0.4 \\end{pmatrix}\\) このとき、各ノード\\(i\\)の情報中心性(\\(C_{inf}(i)\\))は、ノード\\(i\\)が含まれるノードペアの情報量の調和平均3になる。数式では以下のように書ける。ただし、\\(n\\)は全ノードの数である。 \\(C_{inf}(i) = \\frac{n}{\\sum_{j=1}^n 1/I_{ij}}\\) 情報中心性はsnaパッケージのinfocent()関数で求められる。表3.2の隣接行列(mat_dir_b)について算出すると、以下のようになる。 infocent(mat_dir_b, ##無向グラフなら &quot;graph&quot; gmode = &quot;digraph&quot;) ## [1] 1.881874 1.408537 1.157895 1.439252 1.483146 1.714286 1.200000 1.168142 情報中心性の値をノードの大きさに反映したグラフを、それぞれPageRankと媒介中心性の値をノードの大きさに反映した2つのグラフと並べたものがが図3.8である。 図3.8: PageRank・媒介中心性・情報中心性の値をノードの大きさに反映させたグラフ 3.2 ネットワーク構造の諸指標 ここでは、ネットワーク全体の構造の特徴を表す指標についてまとめる。 3.2.1 密度(Density) 密度は、社会ネットワークにおける関係の緊密さの指標になりうる。密度が低いとき、社会ネットワーク内の個体間の直接的な関係は少なく、両者の関係は媒介者を通じた間接的なものが多いということができる(Croft et al., 2008)。 重み無しグラフの場合: 実際の辺の数をグラフに張ることが可能な辺の最大数で割ったもの ノードの数を\\(n\\)、実際の辺の数を\\(m\\)としたとき、\\(2m/n(n-1)\\)(無向グラフ)または\\(m/n(n-1)\\)(有向グラフ) 重み付きグラフの場合: 全辺の重みの合計をグラフに張ることが可能な辺の最大数で割ったもの ノードの数を\\(n\\)、重みの合計を\\(w\\)としたとき、\\(2w/n(n-1)\\)(無向グラフ)または\\(2m/n(n-1)\\)(有向グラフ) ここでは、表3.1の隣接行列を用いて密度を算出する。 ANTsパッケージでは、met.density()で計算可能。ただし、重みなしグラフとして算出されるよう。また、list()関数で複数の隣接行列をリスト化することで、同時に2つ以上の隣接行列について密度を算出できる。 met.density(mat_undir_b) ## Density ## 0.3571429 ## リスト化 list_mat &lt;- list(mat_undir_b, mat_dir_b) met.density(list_mat) ## [[1]] ## [1] 0.3571429 ## ## [[2]] ## [1] 0.2678571 snaパッケージでは、gden()で計算可能。ignore.value = FALSEとすると重み付きグラフとして扱われる。ANTsパッケージと同様、リスト化した複数の隣接行列の密度を同時に算出できる。 ## 重み付き gden(mat_undir_b, ## 重み無グラフならば、TRUE ignore.eval = FALSE, ## 有向グラフならば &quot;digraph&quot; mode = &quot;graph&quot;) ## [1] 0.6428571 ## リスト化 gden(list_mat) ## [1] 0.6428571 0.4464286 3.2.2 同類性(Assortativity) ネットワーク内において、次数などの中心性指標の似ているノード同士が結びつきやすい/結びつきにくいかを表したのが同類性である。ネットワーク内の辺の両端にあるノードの中心性指標の相関係数を算出したものであり、-1から1の値をとる(重み付きグラフの場合は、それで重み付けされているよう)。計算方法の詳細は Farine (2014) を参照。 ここでは例として、第2章で算出した毛づくろい頻度ネットワークgroom_mat_b(表2.3)の媒介中心性について次数相関を調べる。ANTsパッケージでは、met.assortativity()関数で算出できる。引数attr =で調べたいノードの中心性指標などを指定する。 met.assortativity(groom_mat_b, ## 各ノードの固有ベクトル中心性 attr = met.betweenness(groom_mat_b, binary = FALSE, sym = FALSE), ## 重みなしの場合 FALSE weighted = TRUE)$assortativity.cat -&gt; assortativity_bet assortativity_bet ## [1] -0.1275022 係数は-0.128なので、媒介中心性の似ているノード同士は結びつきにくいという弱い傾向が得られた。なお、以下のようにするとnode label permutation(詳細は??)で生成したランダムなネットワークの同類性を指定した数だけ生成してくれる。それらの何%より実際の同類性の数値が大きい/小さいかを検討することで、統計的な検定が行える。今回の例では、実測値はランダムな値の97%より小さいので、片側検定の場合はランダムな場合より有意に小さいと言える(図3.9)。 ## node label permutationで生成したランダムなネットワーク100個についてassortativityを算出 met.assortativity(groom_mat_b, ## 各ノードの固有ベクトル中心性 attr = met.betweenness(groom_mat_b, binary = FALSE, sym = FALSE), ## 重みなしの場合 FALSE weighted = TRUE, ## node label permutationをするか perm.nl = TRUE, ## permutationの数 nperm = 10000) -&gt; nlperm_bet ### ランダムなassortativityの何%より小さい？ sum(nlperm_bet &gt; assortativity_bet)/10000 ## [1] 0.973 図3.9: ランダムなネットワークの同類性の分布(灰色)と実測値(赤) attr =には、中心性指標だけでなく、順位や性別などの様々な個体の属性(連続値・離散値どちらも可)を指定することができる。例えば、同じ順位カテゴリ(低順位: m、中順位: m、高順位: h)の個体同士が結びつきやすいかを調べる場合は、以下のように個体ごとのカテゴリを指定してあげればよい。係数はかなり高く(0.48)、有意に同順位カテゴリ―の個体同士がよく結びつく傾向がある。 rank &lt;- c(&quot;m&quot;,&quot;m&quot;,&quot;l&quot;,&quot;l&quot;,&quot;h&quot;,&quot;h&quot;,&quot;h&quot;,&quot;h&quot;,&quot;h&quot;,&quot;h&quot;,&quot;l&quot;,&quot;l&quot;,&quot;l&quot;,&quot;m&quot;,&quot;m&quot;,&quot;m&quot;,&quot;m&quot;) met.assortativity(groom_mat_b, ## 各ノードの固有ベクトル中心性 attr = rank, ## 重みなしの場合 FALSE weighted = TRUE)$assortativity.cat -&gt; assortativity_rank assortativity_rank ## [1] 0.4840036 図3.10: ランダムなネットワークの同類性の分布(灰色)と実測値(赤) 3.2.3 推移性(Transitivity) ネットワークにおいて、頂点\\(i\\)と\\(j\\)の間、および頂点\\(j\\)と\\(k\\)の間に関係があり、頂点\\(i\\)と\\(k\\)の間にも関係があるとき、関係が推移的であるという。例えば、図3.11で頂点A, B, Cの関係は推移的だが、頂点A, B, Gは推移的ではない。 図3.11: 推移性の説明のための無向グラフの例 有向グラフの場合は、頂点\\(i\\)から\\(j\\)、頂点\\(j\\)から\\(k\\)に有向辺があり、かつ頂点\\(i\\)から\\(k\\)に有向辺があるとき推移的であるという(図3.12)。 図3.12: 推移性の説明のための有向グラフの例 推移性はネットワーク内で推移的な関係が成り立っている比率を指す。例えば無向グラフの場合には、頂点\\(i\\)と\\(j\\)、\\(j\\)と\\(k\\)の間に辺があるとき、頂点\\(i\\)と\\(k\\)にも辺がある割合である。推移性はネットワークがどの程度クラスター化されているかの指標になる(Farine &amp; Whitehead, 2015)。そのため、クラスター係数と呼ばれることもある。 例として、毛づくろい頻度ネットワークgroom_mat_b(表2.3)の推移性を算出する。推移性はigraphパッケージのtransitivity()関数で求められる。推移性は高い？ ## igraphクラスに変換 graph_groom &lt;- graph_from_adjacency_matrix(groom_mat_b, ## 有向グラフなら &quot;directed&quot; mode= &quot;undirected&quot;, ## 重みなしなら NULL weighted = TRUE) transitivity(graph_groom, ## 有向グラフなら &quot;directed&quot; type = &quot;undirected&quot;) ## [1] 0.6909722 3.2.4 Modularity 霊長類のネットワークの種間比較でよく用いられる指標にNewmanのmodularity(Newman, 2004; Whitehead, 2008)がある。この指標は、ネットワーク内を複数のクラスターに分けたとき、クラスター内の個体間での交渉がクラスター間の個体間の交渉よりどの程度多いかを示したもので、0から1の値をとる。値が高い(1に近い)ほどその差が大きいことを示し、クラスターの分け方が妥当であることを示す。Newman (2004) は、modularityが0.3以上のとき、クラスター間がよく分断されているとしている。例えばマカクの種間比較研究では、血縁ごとにクラスター分けしたとき、寛容性が低い種は高い種よりもmodularityが高い(0.33±0.08 vs 0.21 ±0.03)、つまり交渉がより血縁に偏っていることが分かっている(Sueur, Petit, et al., 2011)。 Modularityは以下のように定式化される(Csardi et al., 2006)。 \\(Q = \\frac{1}{2m} \\sum_{i,j} (A_{ij} - \\gamma \\frac{k_i k_j}{2m}) \\delta(c_i,c_j)\\) なお、\\(m\\)は辺の数、\\(A_{ij}\\)は隣接行列の\\(i\\)行目\\(j\\)列目の成分、\\(k_i\\)と\\(k_j\\)はノード\\(i\\)と\\(j\\)の重み付き中心性を表す(\\(k_i\\)と\\(k_j\\)に固有ベクトル中心性を使っている論文もある(Balasubramaniam et al., 2018))。また、\\(\\delta(c_i,c_j)\\)はノード\\(i\\)と\\(j\\)が同じクラスターに属しているときは1、そうでないときは0になる。なお、\\(\\gamma \\frac{k_i k_j}{2m}\\)の部分は、ランダムに交渉が行割れていると仮定したときの\\(A_{ij}\\)の値である。\\(\\delta\\)はデフォルトでは1だが変化させることができ、大きい値をとるほどクラスター数が多くなる。 ここでは例として、毛づくろい頻度ネットワークgroom_mat_b(表2.2)を用いて、各順位カテゴリ内(低順位・中順位・高順位)の交渉がカテゴリ間の交渉よりどの程度多いかを、\\(Q\\)を算出することで求める。 Rでは、igraphパッケージのmodularity()関数で求めることができる。まずgraph_from_adjacency_matrix()でigraphクラスに変換した後に算出する。modularityは小さく(0.06)、毛づくろいネットワークは順位カテゴリごとにはあまりクラスター化されていないことが分かった(計算結果少しおかしい？)。 ## 順位カテゴリごとに番号を振る rank &lt;- c(2,2,1,1,3,3,3,3,3,3,1,1,1,2,2,2,2) ## igraphに変換 graph_groom &lt;- graph_from_adjacency_matrix(groom_mat_b, ## 有向グラフなら &quot;directed&quot; mode= &quot;undirected&quot;, ## 重みなしなら NULL weighted = TRUE) modularity(graph_groom, ## クラスターの分け方 membership = rank, ## deltaの値 resolution = 1, ## 有向グラフなら TRUE directed = FALSE, weights = NULL) ## [1] 0.06140238 3.2.5 応用例(下位集団の検出) ネットワーク内に下位集団(クラスター)が存在するかを調べる方法はたくさんあるが(詳細は 鈴木, 2017)、ここでは主に2つの方法に焦点を当てて紹介する。 3.2.5.1 Modularityを用いる方法 一つの方法としてmodularityが最大になるような分け方がある。igraphパッケージでは、cluster_optimal()でそのようなクラスタの分け方を算出してくれる。 例として、毛づくろい頻度ネットワークgroom_mat_b(表2.3)について算出する。その結果、4つのクラスターに分類され、そのときのmodularityは0.40だった4。概ね順位ごとに分かれていることが分かる(同じアルファベットから始まる個体が同一家系である)。高順位、中順位(2つに分かれている)、低順位にほぼ綺麗に分かれた。 ## 算出 cluster_optimal(graph_groom, weights = NULL) -&gt; cluster_groom ## 結果 cluster_groom ## IGRAPH clustering optimal, groups: 4, mod: 0.4 ## + groups: ## $`1` ## [1] &quot;Aka&quot; &quot;Ako&quot; &quot;Mei&quot; ## ## $`2` ## [1] &quot;Hen&quot; &quot;Hot&quot; &quot;Mal&quot; &quot;Mik&quot; &quot;Tam&quot; &quot;Tot&quot; ## ## $`3` ## [1] &quot;Kil&quot; &quot;Kit&quot; &quot;Koh&quot; &quot;Kor&quot; &quot;Kun&quot; &quot;Kur&quot; ## ## $`4` ## + ... omitted several groups/vertices ## modularity modularity(cluster_groom,directed = FALSE, weights = NULL) ## [1] 0.4020546 ## なぜか値が一致しない modularity(graph_groom, ## クラスターの分け方 membership = membership(cluster_groom), ## deltaの値 resolution = 1, ## 有向グラフなら TRUE directed = FALSE, weights = NULL) ## [1] 0.06437242 クラスターごとに色分けして図示すると図3.13のようになる。 図3.13: Modularityに基づいてクラスターごとに色分けした毛づくろい頻度のグラフ 3.2.5.2 構造類似性を用いる方法 他の方法として、ノード間でネットワーク内での構造的な位置が類似している程度(= 構造類似性)を用いる方法がある。構造類似性の指標として良く用いられるのがユークリッド距離や相関係数である。このような構造類似性の指標を用い、ネットワーク上における位置の似た頂点をひとまとめにし、ネットワークをより少ないいくつかのブロック同士の関係に分けることをブロックモデリングという。 ユークリッド距離 ノード\\(i\\)と\\(j\\)のユークリッド距離(\\(d_{ij}\\))は隣接行列\\(A = (a_{ij})\\)について以下のように定式化される。\\(d_{ij}\\)が大きいほど類似性は低い。 \\[ d_{ij} = \\sqrt {\\sum_{k =1}^{n}(a_{ij}-a_{jk})^2 + (a_{ki}-a_{kj})^2 } \\] 相関係数 ノード\\(i\\)とノード\\(j\\)の相関係数(\\(r_{ij}\\)は隣接行列\\(A = (a_{ij})\\)について以下のように定式化される。\\(r_{ij}\\)が大きいほど類似性は高い。 \\[ r_{ij} = \\frac{(i列とj列の共分散) + (i行とj行の共分散)}{(i列とi行の標準偏差) \\times (j列とj行の標準偏差)} \\] snaパッケージのequiv.clust()関数を用いることで、構造同値性に基づいたクラスター分析ができる。ここでは、毛づくろい頻度ネットワークgroom_mat_b(表2.3)のユークリッド距離を用いて分析を行う。method =で使用する構造類似性の指標を、clust.method =で階層クラスター分析の方法を指定する(方法の詳細はこちら) 。 ## ユークリッド距離 cluster_groom_euc &lt;- equiv.clust(groom_mat_b, ## 相関係数なら &quot;correlation&quot; method = &quot;euclidean&quot;, ## 海藻クラスター分析の方法 cluster.method = &quot;complete&quot;) クラスター分析に基づくデンドログラムは図3.14のようになる。 図3.14: クラスター分析結果に基づくデンドログラム この結果からblockmodel()関数でブロックモデルを作る。引数h =でクラスター(= ブロック)を作る基準となる高さを、もしくは引数k =でブロック数を指定できる。ここでは、ブロックを3つにしたときの結果を調べる。各個体がどのブロックに振り分けられたかは、表??の通りである。 blockmodel_groom_3 &lt;- blockmodel(## 隣接行列 groom_mat_b, ## クラスター分析結果 cluster_groom_euc, ## `k =`でクラスター数の指定。`h = `でクラスターの基準の高さも指定できる。 k = 3) ## メンバーシップ data.frame(femaleID = blockmodel_groom_3$plabels, block = blockmodel_groom_3$block.membership) %&gt;% arrange(femaleID) -&gt; membership_3 membership_3 %&gt;% pivot_wider(names_from = femaleID, values_from = block) %&gt;% kable(align = &quot;c&quot;) %&gt;% kable_styling(font_size = 8, full_width = FALSE) Aka Ako Hen Hot Kil Kit Koh Kor Kun Kur Mal Mei Mik Ntr Tam Ten Tot 1 1 2 2 3 3 3 3 2 3 2 2 2 2 2 2 2 ブロック数を2から5に変化させたときにmodularityがどうなるかを調べたところ(??)、k = 3の時に最大になるよう(かなり値は小さいが…)。 k = 2:5 map(k, ~blockmodel(## 隣接行列 groom_mat_b, ## クラスター分析結果 cluster_groom_euc, ## `k =`でクラスター数の指定。`h = `でクラスターの基準の高さも指定できる。 k = .)$block.membership) -&gt; member_list data.frame(k = rep(k,each = 17),femaleID = blockmodel_groom_3$plabels, member = c(member_list[[1]],member_list[[2]],member_list[[3]],member_list[[4]])) %&gt;% group_by(k) %&gt;% nest() %&gt;% mutate(member2 = map(data,~arrange(., femaleID)$member)) %&gt;% select(k, member2) %&gt;% group_by(k) %&gt;% mutate(modularity = map(member2, ~modularity(graph_groom, membership = as.factor(.)))) %&gt;% select(k, modularity) %&gt;% unnest(cols = c(modularity)) %&gt;% kable(align = &quot;c&quot;) %&gt;% kable_styling(font_size = 13, full_width = FALSE) k modularity 2 -0.0057464 3 0.0377712 4 -0.0034220 5 -0.0344137 clValidパッケージのclValid()関数では、様々な指標を用いてクラスター分けが妥当か算出してくれるよう。詳しくは、 Brock et al. (2008) もしくはこちらを参照。よく使用される指標であるDunn indexと silhouette widthの結果を見ると、3つのクラスターに分けるのが妥当だと示唆される。 clValid(obj = groom_mat_b, nClust = 2:5, clMethods = &quot;hierarchical&quot;, validation = &quot;internal&quot;, Metric = &quot;euclidean&quot;) -&gt; result summary(result) ## ## Clustering Methods: ## hierarchical ## ## Cluster sizes: ## 2 3 4 5 ## ## Validation Measures: ## 2 3 4 5 ## ## hierarchical Connectivity 2.9290 5.8579 8.8869 11.9270 ## Dunn 0.8946 1.3325 0.6119 0.6219 ## Silhouette 0.5547 0.5632 0.2284 0.1967 ## ## Optimal Scores: ## ## Score Method Clusters ## Connectivity 2.9290 hierarchical 2 ## Dunn 1.3325 hierarchical 3 ## Silhouette 0.5632 hierarchical 3 ３つのクラスターごとに色分けして図示すると図3.15のようになる。 図3.15: 構造類似性に基づいてクラスターごとに色分けした毛づくろい頻度のグラフ 3.2.6 その他 個体間の敵対的交渉の隣接行列を用いた順位序列についての各指標の算出については、筆者の別稿を参照。ここで紹介しきれなかった他の指標やクラスター分析の手法については、Whitehead (2008) , Croft et al. (2008) , 鈴木 (2017) などを参照。 References Balasubramaniam, K. N., Beisner, B. A., Berman, C. M., De Marco, A., Duboscq, J., Koirala, S., Majolo, B., Macintosh, A. J. J. J., McFarland, R., Molesti, S., Ogawa, H., Petit, O., Schino, G., Sosa, S., Sueur, C., Thierry, B., Waal, F. B. M. M. de, &amp; McCowan, B. (2018). The influence of phylogeny, social style, and sociodemographic factors on macaque social network structure. Am. J. Primatol., 80(1), e22727. Brock, G., Pihur, V., Datta, S., &amp; Datta, S. (2008). clValid: An R package for cluster validation. J. Stat. Softw., 25, 1–22. Croft, D., James, R., &amp; Krause, J. (2008). 動物の社会ネットワーク分析 (島田将喜., Trans.). 東海大学出版部. Csardi, G., Nepusz, T., &amp; Others. (2006). The igraph software package for complex network research. InterJournal, Complex Systems, 1695(5), 1–9. Farine, D. R. (2014). Measuring phenotypic assortment in animal social networks: Weighted associations are more robust than binary edges. Anim. Behav., 89, 141–153. Farine, D. R., &amp; Whitehead, H. (2015). Constructing, conducting and interpreting animal social network analysis. J. Anim. Ecol., 84(5), 1144–1163. Newman, M. E. J. (2004). Analysis of weighted networks. Phys. Rev. E Stat. Nonlin. Soft Matter Phys., 70(5 Pt 2), 056131. Page, L., Brin, S., Motwani, R., &amp; Winograd, T. (1999). The PageRank citation ranking: Bringing order to the web. Stanford InfoLab. Sosa, S., Puga-Gonzalez, I., Hu, F., Pansanel, J., Xie, X., &amp; Sueur, C. (2020). A multilevel statistical toolkit to study animal social networks: The animal network toolkit software (ANTs) R package. Sci. Rep., 10(1), 12507. Sueur, C., Petit, O., De Marco, A., Jacobs, A. T., Watanabe, K., &amp; Thierry, B. (2011). A comparative network analysis of social style in macaques. Anim. Behav., 82(4), 845–852. Whitehead, H. (2008). Analyzing animal societies. The University of Chicago Press. 鈴木努. (2017). R で学ぶデータサイエンス 8 ネットワーク分析 第2版 (金明哲., Ed.). 共立出版. 分からない場合はこちら↩︎ 分からない場合はこちら↩︎ 調和平均とは、逆数の平均の逆数である。例えば、1, 2, 4の調和平均は次のようになる。 \\[ \\frac{3}{\\frac{1}{1} + \\frac{1}{2} + \\frac{1}{4}} = \\frac{1}{\\frac{7}{12}} = \\frac{12}{7} \\]↩︎ modularity()で同じメンバーシップにしても再現できないので要検討。算出方法が違う？↩︎ "],["おまけ.-csiの算出.html", "4 おまけ. CSIの算出", " 4 おまけ. CSIの算出 aninetパッケージを用いれば、CSI(Silk et al., 2006)を容易に算出できる。 上で算出すしたメス間の毛づくろいマトリクスと、以下の近接マトリクスを用いて算出する。 prox_mat &lt;- read.csv(&quot;data/prox_f.csv&quot;,row.names=1) %&gt;% as.matrix() rownames(prox_mat) &lt;- colnames(prox_mat) prox_mat %&gt;% data.frame() ## Kil Kit Koh Kun Kor Ntr ## Kil NA 0.148601399 0.10733945 0.029467085 0.04553818 0.04176334 ## Kit 0.148601399 NA 0.09505410 0.064403395 0.06003098 0.03628560 ## Koh 0.107339450 0.095054096 NA 0.059630607 0.08569119 0.02036660 ## Kun 0.029467085 0.064403395 0.05963061 NA 0.03599788 0.02032086 ## Kor 0.045538178 0.060030984 0.08569119 0.035997882 NA 0.06288281 ## Ntr 0.041763341 0.036285603 0.02036660 0.020320856 0.06288281 NA ## Ten 0.028753994 0.033859177 0.02167804 0.035676810 0.07162978 0.07420925 ## Aka 0.012272950 0.003680982 0.02267865 0.014269406 0.01630202 0.04887543 ## Ako 0.019413093 0.016774685 0.01431412 0.009326425 0.03188521 0.04016064 ## Tam 0.009839461 0.041470714 0.02734200 0.018833536 0.06112360 0.03535811 ## Tot 0.023706897 0.039956012 0.03969466 0.007371007 0.13045141 0.03121387 ## Hot 0.012256267 0.009532456 0.00477327 0.047682119 0.01579703 0.00531401 ## Hen 0.012953368 0.007698888 0.02062780 0.003039514 0.03372302 0.03356009 ## Mal 0.016464891 0.010917913 0.01268499 0.044943820 0.02416278 0.02735043 ## Mik 0.038844150 0.030964669 0.02571547 0.016429354 0.04615385 0.02933780 ## Mei 0.013828868 0.020940485 0.01453711 0.004435683 0.03182515 0.04557744 ## Ten Aka Ako Tam Tot Hot ## Kil 0.02875399 0.012272950 0.019413093 0.009839461 0.023706897 0.012256267 ## Kit 0.03385918 0.003680982 0.016774685 0.041470714 0.039956012 0.009532456 ## Koh 0.02167804 0.022678648 0.014314115 0.027341999 0.039694656 0.004773270 ## Kun 0.03567681 0.014269406 0.009326425 0.018833536 0.007371007 0.047682119 ## Kor 0.07162978 0.016302016 0.031885213 0.061123596 0.130451415 0.015797032 ## Ntr 0.07420925 0.048875433 0.040160643 0.035358114 0.031213873 0.005314010 ## Ten NA 0.061754685 0.030087094 0.032560214 0.069555302 0.037511871 ## Aka 0.06175468 NA 0.074620573 0.064176245 0.018974566 0.016905738 ## Ako 0.03008709 0.074620573 NA 0.027802295 0.018455744 0.021126761 ## Tam 0.03256021 0.064176245 0.027802295 NA 0.072121468 0.007583965 ## Tot 0.06955530 0.018974566 0.018455744 0.072121468 NA 0.025055928 ## Hot 0.03751187 0.016905738 0.021126761 0.007583965 0.025055928 NA ## Hen 0.02052655 0.009103977 0.045474614 0.013629480 0.055274262 0.043902439 ## Mal 0.03577441 0.008550855 0.006250000 0.042533081 0.015968064 0.030808081 ## Mik 0.05284888 0.033068783 0.021668029 0.057354302 0.016464132 0.037018756 ## Mei 0.03047619 0.027114529 0.039637599 0.026215645 0.021060276 0.017945267 ## Hen Mal Mik Mei ## Kil 0.012953368 0.016464891 0.03884415 0.013828868 ## Kit 0.007698888 0.010917913 0.03096467 0.020940485 ## Koh 0.020627803 0.012684989 0.02571547 0.014537108 ## Kun 0.003039514 0.044943820 0.01642935 0.004435683 ## Kor 0.033723022 0.024162781 0.04615385 0.031825153 ## Ntr 0.033560091 0.027350427 0.02933780 0.045577443 ## Ten 0.020526551 0.035774411 0.05284888 0.030476190 ## Aka 0.009103977 0.008550855 0.03306878 0.027114529 ## Ako 0.045474614 0.006250000 0.02166803 0.039637599 ## Tam 0.013629480 0.042533081 0.05735430 0.026215645 ## Tot 0.055274262 0.015968064 0.01646413 0.021060276 ## Hot 0.043902439 0.030808081 0.03701876 0.017945267 ## Hen NA 0.030732861 0.03748265 0.029187817 ## Mal 0.030732861 NA 0.14634146 0.051620648 ## Mik 0.037482647 0.146341463 NA 0.030255403 ## Mei 0.029187817 0.051620648 0.03025540 NA 毛づくろいマトリクスからKurのデータを除く(近接マトリクスと合わせるため)。 groom_mat_b &lt;- groom_mat_b[-10,-10] CSIは以下のように求められる。 3つ以上の数値を用いる場合でも、リストに追加していくだけで容易に求まる。 ## 2つのマトリクスをリスト化 list &lt;- list(groom_mat_b, prox_mat) CSI &lt;- dyadic_csi(list) マトリクスは以下の通り。 rownames(CSI) &lt;- rownames(prox_mat) colnames(CSI) &lt;- colnames(prox_mat) CSI %&gt;% data.frame() ## Kil Kit Koh Kun Kor Ntr Ten ## Kil NA 13.1042381 1.5443971 0.98428757 0.6552021 0.60088982 0.7643802 ## Kit 13.1042381 NA 1.8809200 0.92663431 0.8915746 0.78716555 0.5420480 ## Koh 1.5443971 1.8809200 NA 1.23209198 1.2329225 0.61536768 0.3119031 ## Kun 0.9842876 0.9266343 1.2320920 NA 0.5179366 0.31860411 0.5133170 ## Kor 0.6552021 0.8915746 1.2329225 0.51793656 NA 4.64249260 2.6668403 ## Ntr 0.6008898 0.7871655 0.6153677 0.31860411 4.6424926 NA 3.7141526 ## Ten 0.7643802 0.5420480 0.3119031 0.51331698 2.6668403 3.71415256 NA ## Aka 0.1765829 0.5510337 0.3528585 0.23124757 0.4808443 1.25067658 2.5067746 ## Ako 0.2793151 0.4266683 0.3668997 0.13418835 1.4817507 0.97271675 1.1957603 ## Tam 0.1415699 0.6511851 1.4155272 0.54053793 0.8794447 0.50873159 0.4684755 ## Tot 1.1100956 2.5939561 1.6986391 0.28537814 1.8769314 0.44910436 1.0007598 ## Hot 0.1763428 0.1655378 0.2414133 0.71411246 0.2272873 0.07645783 0.5982682 ## Hen 0.2143964 0.6384085 0.5640990 0.04373245 0.4852059 0.79768327 0.3496319 ## Mal 0.2931029 0.3951573 0.9329951 0.64665047 0.5686548 0.39351721 1.0591778 ## Mik 0.5588886 1.2886155 0.9305812 0.23638510 0.8841411 0.55311373 0.7603883 ## Mei 0.1989694 0.5596737 0.2615050 1.49582258 0.4578994 0.65576702 0.4384906 ## Aka Ako Tam Tot Hot Hen Mal ## Kil 0.1765829 0.27931506 0.1415699 1.1100956 0.17634284 0.21439643 0.29310285 ## Kit 0.5510337 0.42666826 0.6511851 2.5939561 0.16553778 0.63840846 0.39515733 ## Koh 0.3528585 0.36689969 1.4155272 1.6986391 0.24141327 0.56409896 0.93299506 ## Kun 0.2312476 0.13418835 0.5405379 0.2853781 0.71411246 0.04373245 0.64665047 ## Kor 0.4808443 1.48175069 0.8794447 1.8769314 0.22728727 0.48520593 0.56865480 ## Ntr 1.2506766 0.97271675 0.5087316 0.4491044 0.07645783 0.79768327 0.39351721 ## Ten 2.5067746 1.19576030 0.4684755 1.0007598 0.59826817 0.34963190 1.05917776 ## Aka NA 1.90676455 0.9233661 0.2730055 0.88451956 1.45426091 0.30513215 ## Ako 1.9067645 NA 0.6435518 0.2655407 1.26192668 0.78528971 0.08992483 ## Tam 0.9233661 0.64355179 NA 1.6194770 4.55522245 0.19610059 0.61196482 ## Tot 0.2730055 0.26554075 1.6194770 NA 1.02074634 1.38464537 0.22974807 ## Hot 0.8845196 1.26192668 4.5552224 1.0207463 NA 1.36152269 0.94998635 ## Hen 1.4542609 0.78528971 0.1961006 1.3846454 1.36152269 NA 0.44218358 ## Mal 0.3051322 0.08992483 0.6119648 0.2297481 0.94998635 0.44218358 NA ## Mik 1.1495203 0.39025653 1.2560417 0.4927983 0.98113130 1.97349575 2.10555702 ## Mei 1.5086270 0.57030471 1.8553611 0.3281259 0.36802291 1.05940524 2.76861473 ## Mik Mei ## Kil 0.5588886 0.1989694 ## Kit 1.2886155 0.5596737 ## Koh 0.9305812 0.2615050 ## Kun 0.2363851 1.4958226 ## Kor 0.8841411 0.4578994 ## Ntr 0.5531137 0.6557670 ## Ten 0.7603883 0.4384906 ## Aka 1.1495203 1.5086270 ## Ako 0.3902565 0.5703047 ## Tam 1.2560417 1.8553611 ## Tot 0.4927983 0.3281259 ## Hot 0.9811313 0.3680229 ## Hen 1.9734957 1.0594052 ## Mal 2.1055570 2.7686147 ## Mik NA 0.6907648 ## Mei 0.6907648 NA References Silk, J. B., Altmann, J., &amp; Alberts, S. C. (2006). Social relationships among adult female baboons (papio cynocephalus) i. Variation in the strength of social bonds. Behav. Ecol. Sociobiol., 61(2), 183–195. "],["実行環境.html", "実行環境", " 実行環境 sessionInfo() ## R version 4.2.0 (2022-04-22 ucrt) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 10 x64 (build 19045) ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=Japanese_Japan.utf8 LC_CTYPE=Japanese_Japan.utf8 ## [3] LC_MONETARY=Japanese_Japan.utf8 LC_NUMERIC=C ## [5] LC_TIME=Japanese_Japan.utf8 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] clValid_0.7 cluster_2.1.3 ggsci_2.9 ## [4] concaveman_1.1.0 ggforce_0.3.3 ggdag_0.2.4 ## [7] dagitty_0.3-1 kableExtra_1.3.4 knitr_1.39 ## [10] DT_0.23 fontregisterer_0.3 systemfonts_1.0.4 ## [13] extrafont_0.18 patchwork_1.1.1 ggraph_2.0.5 ## [16] igraph_1.3.1 tidygraph_1.2.1 report_0.5.1 ## [19] see_0.7.2 correlation_0.8.2 modelbased_0.8.5 ## [22] effectsize_0.7.0.5 parameters_0.18.2 performance_0.9.2 ## [25] bayestestR_0.12.1 datawizard_0.5.1 insight_0.18.2 ## [28] easystats_0.5.2 aninet_0.0.0.9000 forcats_0.5.1 ## [31] stringr_1.4.0 dplyr_1.0.9 purrr_0.3.4 ## [34] readr_2.1.2 tidyr_1.2.0 tibble_3.1.7 ## [37] ggplot2_3.3.6 tidyverse_1.3.1 sna_2.6 ## [40] network_1.17.1 statnet.common_4.6.0 ANTs_0.0.1 ## [43] asnipe_1.1.16 ## ## loaded via a namespace (and not attached): ## [1] readxl_1.4.0 backports_1.4.1 splines_4.2.0 ## [4] crosstalk_1.2.0 TH.data_1.1-1 digest_0.6.29 ## [7] htmltools_0.5.2 viridis_0.6.2 fansi_1.0.3 ## [10] magrittr_2.0.3 tzdb_0.3.0 graphlayouts_0.8.0 ## [13] modelr_0.1.8 Kendall_2.2.1 vroom_1.5.7 ## [16] sandwich_3.0-1 extrafontdb_1.0 svglite_2.1.0 ## [19] colorspace_2.0-3 rvest_1.0.2 ggrepel_0.9.1 ## [22] haven_2.5.0 xfun_0.31 tcltk_4.2.0 ## [25] crayon_1.5.1 jsonlite_1.8.0 lme4_1.1-29 ## [28] survival_3.3-1 zoo_1.8-10 glue_1.6.2 ## [31] polyclip_1.10-0 gtable_0.3.0 emmeans_1.7.4-1 ## [34] webshot_0.5.3 V8_4.2.0 Rttf2pt1_1.3.8 ## [37] scales_1.2.0 mvtnorm_1.1-3 DBI_1.1.2 ## [40] Rcpp_1.0.8.3 viridisLite_0.4.0 xtable_1.8-4 ## [43] bit_4.0.4 htmlwidgets_1.5.4 httr_1.4.3 ## [46] ellipsis_0.3.2 pkgconfig_2.0.3 farver_2.1.0 ## [49] sass_0.4.1 dbplyr_2.1.1 utf8_1.2.2 ## [52] tidyselect_1.1.2 rlang_1.0.2 munsell_0.5.0 ## [55] cellranger_1.1.0 tools_4.2.0 visNetwork_2.1.0 ## [58] cli_3.3.0 generics_0.1.2 broom_0.8.0 ## [61] evaluate_0.15 fastmap_1.1.0 yaml_2.3.5 ## [64] bit64_4.0.5 fs_1.5.2 nlme_3.1-157 ## [67] xml2_1.3.3 compiler_4.2.0 rstudioapi_0.13 ## [70] curl_4.3.2 reprex_2.0.1 tweenr_1.0.2 ## [73] bslib_0.3.1 stringi_1.7.6 highr_0.9 ## [76] lattice_0.20-45 Matrix_1.4-1 nloptr_2.0.1 ## [79] vctrs_0.4.1 pillar_1.7.0 lifecycle_1.0.1 ## [82] jquerylib_0.1.4 estimability_1.3 R6_2.5.1 ## [85] bookdown_0.29 gridExtra_2.3 codetools_0.2-18 ## [88] boot_1.3-28 MASS_7.3-56 gtools_3.9.2 ## [91] assertthat_0.2.1 withr_2.5.0 multcomp_1.4-19 ## [94] parallel_4.2.0 hms_1.1.1 grid_4.2.0 ## [97] class_7.3-20 coda_0.19-4 minqa_1.2.4 ## [100] rmarkdown_2.14 lubridate_1.8.0 Balasubramaniam, K. N., Beisner, B. A., Berman, C. M., De Marco, A., Duboscq, J., Koirala, S., Majolo, B., Macintosh, A. J. J. J., McFarland, R., Molesti, S., Ogawa, H., Petit, O., Schino, G., Sosa, S., Sueur, C., Thierry, B., Waal, F. B. M. M. de, &amp; McCowan, B. (2018). The influence of phylogeny, social style, and sociodemographic factors on macaque social network structure. Am. J. Primatol., 80(1), e22727. Brock, G., Pihur, V., Datta, S., &amp; Datta, S. (2008). clValid: An R package for cluster validation. J. Stat. Softw., 25, 1–22. Butts, C. T. (2008). Social network analysis with sna. J. Stat. Softw., 24, 1–51. Campbell, L. A. D., Tkaczynski, P. J., Lehmann, J., Mouna, M., &amp; Majolo, B. (2018). Social thermoregulation as a potential mechanism linking sociality and fitness: Barbary macaques with more social partners form larger huddles. Sci. Rep., 8(1), 6074. Chang, W. (2018). R graphics cookbook: Practical recipes for visualizing data. “O’Reilly Media, Inc.” Cheney, D. L., Silk, J. B., &amp; Seyfarth, R. M. (2016). Network connections, dyadic bonds and fitness in wild female baboons. Royal Society Open Science, 3(7), 160255. Croft, D., James, R., &amp; Krause, J. (2008). 動物の社会ネットワーク分析 (島田将喜., Trans.). 東海大学出版部. Csardi, G., Nepusz, T., &amp; Others. (2006). The igraph software package for complex network research. InterJournal, Complex Systems, 1695(5), 1–9. Duboscq, J., Romano, V., Sueur, C., &amp; Macintosh, A. J. J. (2016). Network centrality and seasonality interact to predict lice load in a social primate. Sci. Rep., 6(FEBRUARY), 22095. Farine, D. R. (2014). Measuring phenotypic assortment in animal social networks: Weighted associations are more robust than binary edges. Anim. Behav., 89, 141–153. Farine, D. R. (2013). Animal social network inference and permutations for ecologists inRusingasnipe. Methods Ecol. Evol., 4(12), 1187–1194. Farine, D. R. (2017). A guide to null models for animal social network analysis. Methods Ecol. Evol., 8(10), 1309–1320. Farine, D. R., &amp; Whitehead, H. (2015). Constructing, conducting and interpreting animal social network analysis. J. Anim. Ecol., 84(5), 1144–1163. Gilby, I. C., Brent, L. J. N., Wroblewski, E. E., Rudicell, R. S., Hahn, B. H., Goodall, J., &amp; Pusey, A. E. (2013). Fitness benefits of coalitionary aggression in male chimpanzees. Behav. Ecol. Sociobiol., 67(3), 373–381. Hoppitt, W. J. E., &amp; Farine, D. R. (2018). Association indices for quantifying social relationships: How to deal with missing observations of individuals or groups. Anim. Behav., 136, 227–238. Kawazoe, T., &amp; Sosa, S. (2019). Social networks predict immigration success in wild japanese macaques. Primates, 60(3), 213–222. Krause, J., James, R., Franks, D. W., &amp; Croft, D. P. (2015). Animal social networks. Oxford University Press. Lehmann, J., Majolo, B., &amp; McFarland, R. (2016). The effects of social network position on the survival of wild barbary macaques, macaca sylvanus. Behav. Ecol., 27(1), 20–28. MacIntosh, A. J. J., Jacobs, A., Garcia, C., Shimizu, K., Mouri, K., Huffman, M. A., &amp; Hernandez, A. D. (2012). Monkeys in the middle: Parasite transmission through the social network of a wild primate. PLoS One, 7(12), 15–21. Newman, M. E. J. (2004). Analysis of weighted networks. Phys. Rev. E Stat. Nonlin. Soft Matter Phys., 70(5 Pt 2), 056131. Page, L., Brin, S., Motwani, R., &amp; Winograd, T. (1999). The PageRank citation ranking: Bringing order to the web. Stanford InfoLab. Shimada, M., &amp; Sueur, C. (2018). Social play among juvenile wild japanese macaques (macaca fuscata) strengthens their social bonds. Am. J. Primatol., 80(1). Silk, J. B., Altmann, J., &amp; Alberts, S. C. (2006). Social relationships among adult female baboons (papio cynocephalus) i. Variation in the strength of social bonds. Behav. Ecol. Sociobiol., 61(2), 183–195. Sosa, S., Puga-Gonzalez, I., Hu, F., Pansanel, J., Xie, X., &amp; Sueur, C. (2020). A multilevel statistical toolkit to study animal social networks: The animal network toolkit software (ANTs) R package. Sci. Rep., 10(1), 12507. Sueur, C., Jacobs, A., Amblard, F., Petit, O., &amp; King, A. J. (2011). How can social network analysis improve the study of primate behavior? American Journal of Primatology, 73(8), 703–719. Sueur, C., Petit, O., De Marco, A., Jacobs, A. T., Watanabe, K., &amp; Thierry, B. (2011). A comparative network analysis of social style in macaques. Anim. Behav., 82(4), 845–852. Whitehead, H. (2008). Analyzing animal societies. The University of Chicago Press. Wickham, H., &amp; Grolemund, G. (2016). R for data science: Import, tidy, transform, visualize, and model data. “O’Reilly Media, Inc.” 松村優哉., 湯谷啓明., 紀ノ定保礼., &amp; 前田和. (2021). RユーザのためのRstudio[実践]入門 tidyverseによるモダンな分析フローの世界 改訂2版. 技術評論社. 鈴木努. (2017). R で学ぶデータサイエンス 8 ネットワーク分析 第2版 (金明哲., Ed.). 共立出版. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
