# 統計的検定  {#c4}
## なぜrandomizationが必要か？  
マトリックス内の数値やそこから算出されたネットワーク指標は他の個体の指標と互いに関連しあっているため、独立ではない[@Farine2015; @Farine2017]。そのため、統計的検定を行う場合には、randomizationテストを行う必要がある。randomizationには、いくつかの方法がある。  

## node label randomization  {#s3-2}
ネットワークのnode(点)のラベルをランダムにシャッフルし、そうしてできた多数のランダムなネットワークにおける分析結果(例えば、相関係数や回帰分析の係数)を帰無モデルとし、それと実際に得られたネットワークにおける分析結果と比較することで、有意性を判定する方法である[@Farine2015; @Farine2017]。  
![node label randomizationの説明1](image/nl1.png)  
![node label randomizationの説明2](image/nl2.png)

`ANTs`パッケージを用いることで容易に求めることができる。  

### 線形回帰分析  
例えば、上(1.1)で求めた毛づくろいネットワークにおいて、順位や年齢と固有ベクトル中心性に関連があるか知りたいとする。  
以下のような一般化線形モデルを考える。  

- 分布: 正規分布  
- 応答変数: 固有ベクトル中心性  
- 説明変数: 順位、年齢  

それでは、node label permutationを行う  
ここでは、従属変数のラベルをランダム化する。
```{r, warning = FALSE, message = FALSE}
#perm_glm <- perm.net.nl(female_metrics,
 #                       ## ランダマイゼーションするラベル  
  #                      labels = "eigen",
   #                     ## 回数  
    #                    nperm = 10000)
```

分析は以下の通り。  
```{r}
#r <- stat.glm(perm_glm,
 #             formula = eigen ~ age + rank,
  #            family = "gaussian")
```

ランダムなネットワークにおける係数と実際のネットワークにおける係数の比較。  
```{r}
r_ant <- ant(r)
```

結果は以下の通り。  
有意な結果は得られなかった。
```{r}
r_ant$model
```

モデル診断。
```{r}
r_ant$model.diagnostic
```

GLM以外にも、t検定や相関分析、GLMM等を同様に行うことができる。  

### ネットワーク同士の関連の検討  
node label randomizationによってネットワーク同士の関連を調べることもできる。  
例えば、上(1.2)で求めたメスが一緒に確認される割合が、個体間の血縁度や順位差と関連しているか調べるとする。  
イメージとしては、以下のようにネットワーク同士で回帰分析を行うような感じである。  
このような分析をMRQAP検定という[@Dekker2007]。

![MRQAP検定のイメージ](image/MRQAP.png)

分析には、[aninetパッケージ](https://rdrr.io/github/MNWeiss/aninet/man/)を用いる[@Franks2021]。  
```{r}
library(aninet)
```

血縁と順位差マトリクスの読み込み。  
```{r}
kin_mat <- read.csv("data/kin_demo.csv", row.names=1) %>% 
  as.matrix()

rank_mat <- read.csv("data/rank_demo.csv",row.names = 1) %>% 
  as.matrix()

## マトリクスの順番を合わせる
presence_mat <- presence_mat[rownames(kin_mat),rownames(kin_mat)]
```


`glmqap()`関数を用いれば様々な分布を用いたモデリングを行うことができる。  
ここでは、SRIを応答変数とするので、二項分布を用いたモデリングを行う。  
SRIの分母を以下のようにして求める。  
```{r}
denom <- get_denominator(presence %>% dplyr::select(-date),
                         return = "matrix",
                         index = "SRI")

denom <- denom[rownames(kin_mat),colnames(kin_mat)]
```

分析は以下の通り。  
```{r, message = FALSE, cache = TRUE}
#r_qap <- glmqap(presence_mat ~ rank_mat + kin_mat,
 #               ## 分母のマトリクス
  #              weights = denom,
   #             family = "binomial",
    #            nperm = 10000,
     #           permutation = "DSP"
      #        )
```

結果は以下の通り。  
```{r, echo = FALSE}
r_qap$coefficients %>% 
  data.frame() %>% 
  bind_cols(r_qap$stderr %>% data.frame()) %>% 
  bind_cols(r_qap$z %>% data.frame()) %>% 
  bind_cols(r_qap$p %>% data.frame()) %>% 
  set_names("推定値","SE","z値","p値") %>% 
  datawizard::rownames_as_column(var = "説明変数") %>% 
  mutate(説明変数 = str_replace_all(説明変数, c("\\(Intercept\\)" = "切片",
                                        "xkin_mat" = "血縁度",
                                        "xrank_mat" = "順位差"))) 
```

## data stream randomization  
マトリクスを作る前にランダマイゼーションを行うpre-network randomizationという方法もある。  
代表的なものはdata stream randamizationと呼ばれるものである。詳しくは、Farine & Whitehead (2015)参照。  
<br />  

ANTsパッケージでdata stream randomizationを行うことができる。  
ここでは、group by individualの形式で記録したメスの出欠データ(1.2参照)を用いる。  
ランダマイゼーションを行うためには、縦長のデータフレームにする必要がある。  
```{r}
## まずはデータフレームの形に直す。
resence_mat <- presence %>% column_to_rownames("date") %>% 
  as.matrix()

## gbi.to.df関数でデータフレーム形式に  
presence_df <- gbi.to.df(presence_mat)
```

`perm.ds.grp()`でdata stream randomizationを行うことができる。  
ここでは、観察日ごとに個体の出欠を10000回シャッフルするが、もしあれば時間や場所などの情報も`ctrlf`という引数で加えることが可能である。詳しくは、Farine (2017)を参照。
```{r}
#perm_ds <- perm.ds.grp(presence_df,
 #                      scan = "scan",
  #                     nperm = 10000,
   #                    index = "sri")
```

生成された10001(実データ1 + ランダマイゼーション×10000)それぞれについて、ネットワーク指標を算出して、メスの属性データと結合する。やり方は、第2節と同様であるが、`map()`を用いることで10001個のマトリクスそれぞれについて算出できる。    
```{r}
## メスの属性データ
attribute_b <- attribute %>% 
  filter(femaleID != "Tam"&femaleID != "Kur") %>% 
  arrange(femaleID)

list <- map(perm_ds,met.eigen, df = attribute_b, dfid = 1)
```

それでは、算出した値を用いて統計的検定を行う。  
3.1.1と同様に、以下のような線形モデルを考える。  
以下のような一般化線形モデルを考える。  

- 分布: ガンマ分布  
- 応答変数: 固有ベクトル中心性  
- 説明変数: 順位、年齢  

まず、算出したネットワーク指標を一つのデータフレームにまとめ、マトリクスごとにネスト化する。  
```{r}
for(i in 2:10001){
    if(i == 2){
    female_met <- bind_rows(list[[i-1]],list[[i]])
    } else{
    female_met <- bind_rows(female_met,list[[i]])
  }
 }

female_met %>% 
  mutate(perm.no = rep(1:10001,each = 15)) %>% 
  group_by(perm.no) %>% 
  nest() -> female_met_nest
```

`map()`を用いて、それぞれのマトリクスごとにGLMを行う。  
```{r}
r_ds <- map(female_met_nest$data, ~ glm(formula = eigen ~ rank + age, data = .,family = "Gamma"))
```

例えば、1つめのマトリクス(ここでは実測値)の結果は以下のようになる。   
ここで算出されているp値はこんかいは用いることができない(データの独立性を仮定した結果なので)。  
得られた係数(Coefficient)をランダム化されたマトリクスを用いた分析の係数と比較することで有意性を判定する。
```{r}
model_parameters(r_ds[[1]])

coef_rank_r <- r_ds[[1]]$coefficients[[2]]
coef_age_r <-  r_ds[[1]]$coefficients[[3]]  
```


ランダム化された10000個のマトリクスで算出された順位と血縁の係数をまとめたデータフレームを作成する。  
```{r}
coef <- data.frame(coef_rank = 0L,
                   coef_age = 0L) 

for(i in 2:10001){
  coef[i-1,1] <- r_ds[[i]]$coefficients[[2]]
  coef[i-1,2] <- r_ds[[i]]$coefficients[[3]]
}
```

実データの係数がランダム化されたマトリクスの係数のうち95%よりも大きい/小さいときに、実データの係数は有意に大きい/小さいとする。  

**順位**については、以下のような結果になるので(p_upper = 0.0426)、順位の係数はランダムな場合よりも有意に大きい(＝固有ベクトル中心性に有意に正の関連がある)ということができる。    
```{r}
p_upper1 <- sum(coef$coef_rank > coef_rank_r)/10000
p_lower1 <- sum(coef$coef_rank < coef_rank_r)/10000

p_upper1
p_lower1
```

```{r}
coef %>% 
  ggplot(aes(x=coef_rank))+ 
  geom_histogram(bins = 500)+
  geom_vline(xintercept = coef_rank_r,
              color = "red")+
  geom_text(aes(x = 0.0053, y = 60),
            label = str_c("実測値\n","p_upper =", p_upper1),
            hjust=0)+
  theme_bw()
```

**年齢**については、以下のような結果になるので(p_upper = 0.057)、有意な影響はないとなる。     
```{r}
p_upper2 <- sum(coef$coef_age > coef_age_r)/10000
p_lower2 <- sum(coef$coef_age < coef_age_r)/10000

p_upper2
p_lower2
```

```{r}
coef %>% 
  ggplot(aes(x=coef_age))+ 
  geom_histogram(bins = 500)+
  geom_vline(xintercept = coef_age_r,
              color = "red")+
  geom_text(aes(x = 0.045, y = 65),
            label = str_c("実測値\n","p_upper =", p_upper2),
            hjust =0)+
  theme_bw()
```
